<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用AndroidStudio为Unity编译C/C++动态库</title>
    <url>/2021/01/09/BuildAndroidSOForUnity/</url>
    <content><![CDATA[<p>安卓平台是基于Linux，所以动态库是<code>so</code>后缀，在AndroidStudio 中生成动态库有两种方式，一种是通过<code>cmake</code>，另一种是通过<code>ndk-build</code>，本文采用的是<code>ndk-build</code>，目前AS对于这两种方式都支持，但是对于新的项目，官方建议采用CMake来构建。</p>
<a id="more"></a>
<h2 id="安装-AndroidStudio"><a href="#安装-AndroidStudio" class="headerlink" title="安装 AndroidStudio"></a>安装 AndroidStudio</h2><p>软件可以从 <code>Google</code> <a href="https://developer.android.google.cn/studio/" target="_blank" rel="noopener">官网</a>下载，不需要翻墙，安装过程可以参考之前的，需要注意以下几点：</p>
<ul>
<li>编译c/c++需要安装ndk</li>
<li>ndk版本与 unity 一致</li>
<li>安装特定版本ndk，参考<a href="https://developer.android.google.cn/studio/projects/install-ndk" target="_blank" rel="noopener">这里</a></li>
</ul>
<h2 id="编译动态库"><a href="#编译动态库" class="headerlink" title="编译动态库"></a>编译动态库</h2><p>编译主要步骤：</p>
<ol>
<li>创建 Empty 工程</li>
<li>将C/C++文件导入到项目<code>jni</code>文件夹</li>
<li>在<code>jni</code>目录中创建构建脚本，如果是CMake需要创建<code>CMakeLists.txt</code>，如果是<code>ndk-build</code>需要创建<code>Android.mk</code></li>
<li>将构建脚本添加到<code>gradle</code>构建脚本</li>
<li>执行构建</li>
</ol>
<p>下面以编译<code>sqlite</code>为例，详细介绍编译过程</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>首先创建 Android Studio 工程，项目模板选 <code>No Activity</code>即可</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/01_create_proj.PNG">
<p>参数设置，这里 <code>Minimum SDK</code> 要与Unity PlayerSetting 一致，NDK编译过程中会根据该参数匹配编译平台</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/02_create_proj_set.PNG">
<p>创建 <code>jni</code> 文件夹，切换到 <code>Project</code> 视图，在<code>app/src/main</code> 右键选择 <code>New-&gt;Folder-&gt;JNI Folder</code></p>
<img src="/2021/01/09/BuildAndroidSOForUnity/03_create_jni.png">
<p>勾选 <code>Change Folder Location</code>，点击结束</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/04_create_jni_set.png">
<h3 id="导入C-C-源码"><a href="#导入C-C-源码" class="headerlink" title="导入C/C++源码"></a>导入C/C++源码</h3><p>下载 <code>sqlite</code> <a href="https://www.sqlite.org/2020/sqlite-amalgamation-3340000.zip" target="_blank" rel="noopener">源码</a>，解压之后将<code>sqlite3.c</code>、<code>sqlite3.h</code>、<code>sqlite3ext.h</code>复制到<code>jni</code>文件夹内</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/sqlitefiles.png">
<img src="/2021/01/09/BuildAndroidSOForUnity/05_import_src.png">
<h3 id="创建构建脚本"><a href="#创建构建脚本" class="headerlink" title="创建构建脚本"></a>创建构建脚本</h3><p>在<code>jni</code>文件夹创建 <code>ndk-build</code> 构建文件<code>Android.mk</code>，它实际上是 makefile 片段，用于定义构建行为</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/06_create_mk.png">
<p>文件内容如下：</p>
<figure class="highlight mk"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := sqlite3</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES =: sqlite3.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>
<p><code>LOCAL_PATH := $(call my-dir)</code> 语句定义 <code>LOCAL_PATH</code>变量，表明源文件在项目中的位置，宏函数<code>my-dir</code>返回<code>Android.mk</code>文件所在目录；</p>
<p><code>include $(CLEAR_VARS)</code> 包含一个由变量<code>CLEAR_VARS</code>表示的 <code>GNU Makefile</code> 文件，该文件会清除一些 <code>LOCAL_XXX</code> 变量，比如<code>LOCAL_MODULE</code>、<code>LOCAL_SRC_FILES</code>等，但是不会清除 <code>LOCAL_PATH</code>；</p>
<p><code>LOCAL_MODULE := sqlite3</code> 设置要构建的模块的名称，一个模块就是一个动态库（so），模块名称必须唯一，不能包含空格，最终生成会自动添加前缀和后缀，例如上面示例会生成<code>libsqlite3.so</code>;</p>
<p><code>LOCAL_SRC_FILES =: sqlite3.c</code> 列出C/C++ 源文件，多个文件之间用空格分隔，相对路径使用正斜杠(<code>/</code>)，不要使用 Windows 的反斜杠(<code>\</code>)；</p>
<p><code>include $(BUILD_SHARED_LIBRARY)</code> 上面说了，<code>Android.mk</code> 只是 <code>GNU Makefile</code> 片段，我们只需要把这部分片段设置好，再和其他部分组到一块就可以进行编译，所以这里的<code>BUILD_SHARED_LIBRARY</code> 指向的就是其他部分文件，该文件用于构建动态库文件，该文件至少要求已经设置了<code>LOCAL_MODULE</code>和<code>LOCAL_SRC_FILES</code>变量；类似的还有构建静态库的<code>BUILD_STATIC_LIBRARY</code>，构建执行文件的<code>BUILD_EXECUTABLE</code>。</p>
<p>sqlite编译不需要依赖其他库，如果需要添加依赖库，可以设置以下变量：</p>
<ul>
<li><code>LOCAL_C_INCLUDES</code>，附加包含目录，<code>include</code> 搜索路径，相对 ndk 根目录</li>
<li><code>LOCAL_STATIC_LIBRARIES</code>，依赖的静态库列表</li>
<li><code>LOCAL_SHARED_LIBRARIES</code>，依赖的静态库列表</li>
</ul>
<p>默认会生成所有非弃用的ABI生成库，如果要设置为特定的ABI 生成代码，可以按照以下步骤：</p>
<ol>
<li>在<code>jni</code>目录创建 <code>Application.mk</code> 文件</li>
<li>编辑<code>Application.mk</code>，文件内容如下</li>
</ol>
<figure class="highlight mk"><table><tr><td class="code"><pre><span class="line">APP_MODULES := sqlite3</span><br><span class="line"></span><br><span class="line">APP_ABI := all</span><br></pre></td></tr></table></figure>
<p><code>APP_MODULES := sqlite3</code> 要构建的模块列表，与<code>Android.mk</code>中的<code>LOCAL_MODULE</code> 对应</p>
<p><code>APP_ABI := all</code>，指定ABI 类型，值包括<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>、<code>x86_64</code>、<code>all</code>，多个值之间用空格分隔</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>构建是通过执行 <code>ndk-build.cmd</code>完成，为了方便构建，可以借助命令行或者AndroidStudio 的 External tool。</p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;app\src\main&gt;</span><br><span class="line">&lt;ndk&gt;\ndk-build.<span class="built_in">cmd</span></span><br></pre></td></tr></table></figure>
<h4 id="External-Tools"><a href="#External-Tools" class="headerlink" title="External Tools"></a>External Tools</h4><p>添加构建工具，在<code>File-Settings</code>打开设置面板，在<code>Tools/External Tools</code>中，添加编译工具，这里的 <code>Tools Settings - Program</code> 设置为 <code>ndk</code> 的根目录，这里要注意ndk版本。</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/07_create_ext_tool.png">
<p>运行工具</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/08_exe_tool.png">
<p>构建完成之后，可以在 <code>src/main/libs</code> 目录中找到生成的 <code>so</code>文件。</p>
<h2 id="拷贝到-Unity-工程"><a href="#拷贝到-Unity-工程" class="headerlink" title="拷贝到 Unity 工程"></a>拷贝到 Unity 工程</h2><p>将生成的 libs 文件夹，拷贝到 Unity 工程，放到 <code>Plugins/Android/</code> 目录下，检查导入设置是否正确</p>
<img src="/2021/01/09/BuildAndroidSOForUnity/09_unity_plugin.png">
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.unity3d.com/Manual/AndroidNativePlugins.html" target="_blank" rel="noopener">Unity用户手册</a><br><a href="https://developer.android.google.cn/ndk/guides" target="_blank" rel="noopener">NDK开发指南</a></p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>理解async/await异步模型（一）</title>
    <url>/2020/07/16/SynchronizationContextInUnity/</url>
    <content><![CDATA[<p>大概从 Unity 2017 开始就正式支持 <code>.Net 4.x</code> 版本，很多新的语法都支持了，包括 <code>dynamic</code> 动态类型、<code>async/await</code> 异步模型，其中对 <code>async/await</code> 的支持尤其重要，虽然之前可以使用协程来进行异步编程，但是协程存在很多限制，最突出的两个问题是，没有返回值，以及异常处理问题，<code>async/await</code>的出现，很好的解决的这些问题，但是同时又带了一些新的问题。</p>
<p><code>async/await</code>异步模型使用起来很简单，但是要真正的完全理解，其中涉及到很多难理解的概念，比如多线程、线程池、同步上下文、任务调度等等，对于初学者，这些单个概念都不太好理解，<code>MSDN</code> 上面提供的资料也不是很多，同时，本人的能力水平有限，其中难免存在纰漏，但是我还是尽可能的将我的理解表述清楚，便于读者理解。</p>
<p>下面文章从一个简单的例子出发，首先了解一下 <code>async/await</code> 是如何实现异步的。</p>
<a id="more"></a>
<h2 id="async-await是怎么工作的"><a href="#async-await是怎么工作的" class="headerlink" title="async/await是怎么工作的"></a>async/await是怎么工作的</h2><p>在 C# 中，<code>async/await</code>语法的作用其实只是告诉编译器，它所修饰的方法是一个异步方法，需要编译器进行相应的转化，还是直接看一个简单示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AsyncSample sample = <span class="keyword">new</span> AsyncSample();</span><br><span class="line">        sample.DoAsync();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Before: &#123;0&#125;"</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"After: &#123;0&#125;"</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before: 1</span><br><span class="line">After: 4</span><br></pre></td></tr></table></figure>
<p>上面代码比较简单，<code>AsyncSample</code> 类里面包含一个 <code>DoAsync()</code> 方法，可以看到 <code>await</code> 语句前后代码块不在同一个线程内执行，这就很有意思了，为了研究它的原理，先看一下它的反编译结果，我这里使用的是 <a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy</a>，下面结果是对反编译字段进行重新命名的，另外反编译的时候选择 <code>C# 4.0</code> 语法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		AsyncSample sample = <span class="keyword">new</span> AsyncSample();</span><br><span class="line">		sample.DoAsync();</span><br><span class="line">		Console.ReadKey();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncSample</span></span><br><span class="line">&#123;</span><br><span class="line">	[<span class="meta">CompilerGenerated</span>]</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DOAsyncStateMechine</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> AsyncTaskMethodBuilder builder;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> AsyncSample inst;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> TaskAwaiter awaiter;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>		&#123;</span><br><span class="line">			<span class="keyword">int</span> num = state;</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				TaskAwaiter awaiter;</span><br><span class="line">				<span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Console.WriteLine(<span class="string">"Before: &#123;0&#125;"</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">					awaiter = Task.Delay(<span class="number">1000</span>).GetAwaiter();</span><br><span class="line">					<span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">					&#123;</span><br><span class="line">						num = (state = <span class="number">0</span>);</span><br><span class="line">						awaiter = awaiter;</span><br><span class="line">						DOAsyncStateMechine stateMachine = <span class="keyword">this</span>;</span><br><span class="line">						builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					awaiter = awaiter;</span><br><span class="line">					awaiter = <span class="keyword">default</span>(TaskAwaiter);</span><br><span class="line">					num = (state = <span class="number">-1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				awaiter.GetResult();</span><br><span class="line">				Console.WriteLine(<span class="string">"After: &#123;0&#125;"</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception exception)</span><br><span class="line">			&#123;</span><br><span class="line">				state = <span class="number">-2</span>;</span><br><span class="line">				builder.SetException(exception);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			state = <span class="number">-2</span>;</span><br><span class="line">			builder.SetResult();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.MoveNext();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		[<span class="meta">DebuggerHidden</span>]</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function"></span>		&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">AsyncStateMachine(typeof(DOAsyncStateMechine))</span>]</span><br><span class="line">	[<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		DOAsyncStateMechine stateMachine = <span class="keyword">new</span> DOAsyncStateMechine();</span><br><span class="line">		stateMachine.inst = <span class="keyword">this</span>;</span><br><span class="line">		stateMachine.builder = AsyncTaskMethodBuilder.Create();</span><br><span class="line">		stateMachine.state = <span class="number">-1</span>;</span><br><span class="line">		AsyncTaskMethodBuilder builder = stateMachine.builder;</span><br><span class="line">		builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">		<span class="keyword">return</span> stateMachine.builder.Task;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比反编译结果和源码，可以法线变化的只是 <code>AsyncSample</code> 类，变化主要有三点：</p>
<ul>
<li><code>DoAsync()</code>方法去掉了 <code>async</code> 修饰；</li>
<li><code>DoAsync()</code>方法实现完全被重写；</li>
<li>增加了 <code>DOAsyncStateMechine</code> 嵌套类，这是一个状态机类型，状态机的主体是 <code>MoveNext()</code>，因为源码里只有一个<code>await</code>，所以这里有三个状态，如下图所示：</li>
</ul>
<div><div class="graphviz">digraph finite_state_machine {
    rankdir=LR;
    size="8,5"

    entry [shape=circle label="入口"]
    stage1[label="Before"]
    stage2[label="Delay"]
    stage3[label="After"]
    exit [shape= circle label="结束"]

    entry -> stage1 [label="state != 0"]
    entry -> stage3 [label = "state == 0"]
    stage1 -> stage2 [label="执行任务"];
    stage2 -> stage3 [label="awaiter.IsCompleted == true"];
    stage3 -> exit;
    stage2 -> exit[label="awaiter.IsCompleted == false"];
}</div></div>

<p>下面梳理一下状态机执行流程，从 <code>DoAsync()</code> 开始：</p>
<ol>
<li>首先构建状态机，初始 <code>builder</code> 成员，并将状态机的初始状态设置为 <code>-1</code>；</li>
<li>然后调用 <code>builder.Start(ref stateMachine)</code> 该方法会调用状态机的 <code>MoveNext()</code> 函数；</li>
<li>在 <code>MoveNext()</code> 中，由于初始 <code>state == -1</code> 因此进入第一阶段，执行<code>Before</code> 部分代码；</li>
<li>然后紧接着进入阶段二，执行 <code>Task.Delay(1000)</code>，该方法返回一个 <code>Task</code> 类型对象，调用 <code>Task.GetAwaiter()</code> 获取 <code>TaskAwaiter</code> 对象，然后通过<code>IsCompleted</code>属性判断任务是否完成，如果完成，则直接跳转到阶段三；如果没有完成，则会将 <code>state</code>设置为0，然后调用<code>builder.builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine)</code>并退出状态机，它会在任务结束之后，再次调用状态机；</li>
<li>任务完成后，再次调用状态机的 <code>MoveNext()</code>，此时直接进入到阶段三，至此整个状态机执行完毕。</li>
</ol>
<p>通过上面的过程，大致的了解了编译器对 <code>async/await</code> 代码做了什么，能够知道为什么一个 <code>await</code> 语句就能够做到异步执行，但是这里还没有解决开头提出的问题，为什么 <code>await</code> 语句前后执行线程不同？ <code>TaskAwaiter</code> 内部是如何工作的？ 以及 <code>builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine)</code> 内部是如何实现的？</p>
<p>这里为了方便理解，采用了<code>Task.Delay</code>来进行演示，如果换成<code>Task.Run(Action)</code>又会稍微复杂一点，为了研究明白这些问题，后序将会按照以下两大块来分别研究：</p>
<ul>
<li>任务是如何异步的执行的？</li>
<li>任务是如何检测结束的？</li>
<li>任务结束之后，是如何执行后续任务的？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的过程，能够初步了解 <code>async/await</code>是怎么一个工作机制，就是通过状态机定义一系列的状态转换，<code>awaiter</code> 语句前后代码安排在特定的状态执行。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中反射获取基类静态成员</title>
    <url>/2020/03/29/ReflectStaticMemberInCsharp/</url>
    <content><![CDATA[<p>今天在实现单例的时候，通过继承泛型基类，子类型就可以拥有静态 Instance 属性成员，但是当我通过子类类型获取 Instance 对象时，却没有办法获取到，原因是因为反射时，虽然会在继承的基类中进行查找，但是只限于实例成员，对于静态成员是不进行继承查找的。</p>
<a id="more"></a>
<p>下面看一下具体的代码。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SubA inst = Create&lt;SubA&gt;();</span><br><span class="line">        Console.WriteLine(inst);  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Create&lt;T&gt;()</span><br><span class="line">        <span class="keyword">where</span> T:<span class="keyword">class</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type closeType = <span class="keyword">typeof</span>(Singleton&lt;&gt;).MakeGenericType(<span class="keyword">typeof</span>(T));</span><br><span class="line">        <span class="keyword">if</span>(closeType.IsAssignableFrom(<span class="keyword">typeof</span>(T)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不能获取 PropertyInfo，因为静态成员不会进行查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span>(T).GetProperty(<span class="string">"Instance"</span>, BindingFlags.Static | BindingFlags.Public)?.GetValue(<span class="literal">null</span>) <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Activator.CreateInstance&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Singleton&lt;T&gt;</span><br><span class="line">    where T : class, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">SingletonWrapper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">SingletonWrapper</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> SingletonWrapper.instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubA:Singleton&lt;SubA&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码没有办法正确的获取到 <code>Instance</code> 对象，因为 C# 不会在基类中查找静态成员，因此只能在 <code>Singleton&lt;T&gt;</code> 中进行查找，修改获取方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type closeType = <span class="keyword">typeof</span>(Singleton&lt;&gt;).MakeGenericType(<span class="keyword">typeof</span>(T));</span><br><span class="line"><span class="keyword">if</span>(closeType.IsAssignableFrom(<span class="keyword">typeof</span>(T)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//return typeof(T).GetProperty("Instance", BindingFlags.Static | BindingFlags.Public)?.GetValue(null) as T;</span></span><br><span class="line">    <span class="keyword">return</span> closeType.GetProperty(<span class="string">"Instance"</span>)?.GetValue(<span class="literal">null</span>) <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外这种方式实现单例，存在一个问题，特别需要注意，还是接着上面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GSubA</span>:<span class="title">SubA</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GSubB</span>:<span class="title">SubA</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class SubB : Singleton&lt;SubB&gt;&#123;&#125;</span><br><span class="line">public class SubC : Singleton&lt;SubC&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">bool</span> isSame = GSubA.Instance == GSubB.Instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">isSame = SubB.Instance == SubC.Instance;</span><br></pre></td></tr></table></figure>
<p>首先解释第二条为什么为 false，虽然看上去都是继承自 <code>Singleton&lt;T&gt;</code> 基类，但是其他是继承自不同的类型，<code>Singleton&lt;T&gt;</code> 叫做<code>开放类型</code>，当给泛型参数指定具体类型时，就变为<code>闭合类型</code>，也就是说 C# 会在运行时，创建两个新的类型 <code>Singleton&lt;SubB&gt;</code> 和 <code>Singleton&lt;SubC&gt;</code>，不同的类型，其静态成员肯定是不同的。</p>
<p>在理解了上面的解释之后，在看第一条就容易理解了，因为 <code>GSubA</code>和<code>GSubB</code>都继承自同一类型 <code>SubA</code>，所以对应的 <code>Instance</code> 成员相同。</p>
<p>总结一下就两点：</p>
<ul>
<li>C# 反射静态成员时，不会在继承结构中查找，只能通过使用静态声明类型来获取；</li>
<li>泛型类会根据泛型参数不同，生成不同的闭合类型。</li>
</ul>
]]></content>
      <categories>
        <category>c#</category>
      </categories>
  </entry>
  <entry>
    <title>Unity WebGL 开发（三）</title>
    <url>/2020/03/13/UnityWebGLDev3/</url>
    <content><![CDATA[<p>这是 WebGL 部分的第三篇，主要包括性能问题、内存、与浏览器的交互三部分内容。</p>
<a id="more"></a>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>WebGL 应用在 GPU 上的性能应该与原生应用接近，因为 WebGL 也会使用 gpu 进行硬件加速，并且从 WebGL API 转换到操作系统的图形 API 性能消耗非常小。</p>
<p>CPU 方面，WebGL 平台将代码转换为 WebAssembly，它的性能取决于浏览器，各个浏览器之间的对比可以参考<a href="https://blogs.unity3d.com/2018/09/17/webassembly-load-times-and-performance/?_ga=2.216349718.1890713557.1584018786-504656146.1571931117" target="_blank" rel="noopener">这里</a>。</p>
<p>还有一些其他因素会影响性能，这里主要是 JavaScript 不支持多线程，Unity做的很多多线程优化在 WebGL 平台不起作用。</p>
<p>为了达到最优的性能，建议最终发布时，将 Exception support 设置为 none。</p>
<p>当设置了 <code>runInBackground</code>之后，即使画布或者浏览器失去焦点之后，仍然会在后台运行，然后有些浏览器会对后台运行的标签进行限制，如果 WebGL 内容所在标签不可见之后，将会每秒更新一次，这将会造成 Time.deltaTime 比实际要慢，这是因为 Unity 有个 Time.maximumDeltaTime 设置，这个值默认为 0.1，Time.deltaTime 不会小于此值，就是说实际已经过了 1秒，但是系统只步进了 0.1 秒。</p>
<p>如果想以低帧率运行，可以通过 <code>Application.targetFrameRate</code> 进行设置，如果不需要限制，将该参数设置为 -1，而非一个非常高的值。</p>
<h2 id="内嵌资源"><a href="#内嵌资源" class="headerlink" title="内嵌资源"></a>内嵌资源</h2><p>有些 .net 程序集中会内嵌一些资源，默认情况下，WebGL 在打包时是不打包这些资源的，目的是为了减少内容的大小，如果有些 API 确实需要这些资源，可以通过以下代码进行设置：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebGLEditorScript</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"WebGL/Enable Embedded Resources"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnableErrorMessageTesting</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        PlayerSettings.SetPropertyBool(<span class="string">"useEmbeddedResources"</span>, <span class="literal">true</span>, BuildTargetGroup.WebGL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启用设置之后，项目中 .net 程序集的内嵌资源都会打包到 WebGL 发布内容中。</p>
<h2 id="WebGL-内存"><a href="#WebGL-内存" class="headerlink" title="WebGL 内存"></a>WebGL 内存</h2><p>内存是制约 WebGL 内容复杂度的一个重要因素，WebGL 内容运行在浏览器中，可用的内存大小取决于浏览器的类型和设备类型，主要由以下几点决定：</p>
<ul>
<li>浏览器是 32 位还是 64 位；</li>
<li>浏览器是否给每个标签分配单独进程；</li>
<li>浏览器的 JavaScript 引擎所需内存。</li>
</ul>
<p>下图是 Unity WebGL 在浏览器运行时的内存情况</p>
<img src="/2020/03/13/UnityWebGLDev3/image04.png">
<p>可以看出，除了 Unity Heap 之外，还需要浏览器分配额外的内存，理解这一点有助于帮助后续的内存优化。</p>
<p>DOM、Unity Heap、Asset Data、Code 这几块内存在加载之后将会常驻内存，其他的像 AssetBundle、WebAudio 等都是由代码进行控制加载和卸载。</p>
<h3 id="Unity-Heap"><a href="#Unity-Heap" class="headerlink" title="Unity Heap"></a>Unity Heap</h3><p>UnityHeap 包括几部分组成：</p>
<ul>
<li>静态对象内存 ： 和 Unity 版本和项目代码有关；</li>
<li>栈内存 ： 通常在 <code>5mb</code> 左右；</li>
<li>动态内存 ：可以增长的部分，主要用于 GC 缓冲区，运行时生成的对象都在该内存段中；</li>
<li>未分配内存；</li>
</ul>
<p>UnityHeap 的大小可以通过 PlayerSetting-&gt;Memory Size 来设置，默认为 256Mb，在 JavaScript 中，UnityHeap 是通过 TypedArray 来表示的，即一旦分配之后就不能增大或减小，并且这部分内存是不返还给浏览器的。</p>
<p>通常一个空的项目只需要 16Mb 即可运行，堆内存大小可以根据项目复杂度进行调整，但是需要记住，<font color="red">Unity Heap越大，所能使用的用户就越少</font>。因此在实际项目中为了尽可能的减小 Unity Heap 的大小，我们通常需要将我们的项目整个跑一遍，然后通过 Profiler 来查看最终用了多少内存，然后调整一个稍大的值(16整数倍)即可满足需要。</p>
<h3 id="资源数据（Asset-Data）"><a href="#资源数据（Asset-Data）" class="headerlink" title="资源数据（Asset Data）"></a>资源数据（Asset Data）</h3><p>在编译 WebGL 项目时，Unity 会创建一个<code>a.data</code>文件，它包含了项目的所有场景和资源，因为 WebGL 不能访问系统的文件系统，因此只能在开始之前进行下载，然后解压到浏览器分配的一块连续内存，并且会一直常驻在内存中，所以，如果想要提高加载速度，应该尽可能的降低资源的大小。</p>
<p>另一种有推荐的方法是采用 AssetBundle，它具备以下几点优势：</p>
<ul>
<li>加载时间完全受控，不需要再开始前进行全部加载；</li>
<li>可以进行卸载，不需要常驻内存；</li>
<li>分配在堆内存中，不需要浏览器其他额外分配内存；</li>
<li>可以使用浏览器缓存。</li>
</ul>
<h3 id="内存相关问题"><a href="#内存相关问题" class="headerlink" title="内存相关问题"></a>内存相关问题</h3><p>在调试过程中如果遇到内存相关的问题，首先要区分是浏览器分配失败，还是 Unity 从预分配块中分配失败。如果时浏览器分配失败，这说明 WebGL 内容内存占用过大，应该降低资源大小；如果时 Unity 从块中分配内存失败，这说明在 PlayerSetting 中设置的内存太小，应该适当增加。</p>
<p>那么如何判断这两种情况，不同的浏览器可能显示的结果不同，但是一般的，如果在控制台看到类似 <code>Out of memory</code>的错误，通常是浏览器分配失败；如果在加载内容时发生崩溃，并且没有显示什么错误，造成这种问题的原因很多，但通常都是 Unity 内存分配失败。</p>
<h3 id="Large-Allocation"><a href="#Large-Allocation" class="headerlink" title="Large-Allocation"></a>Large-Allocation</h3><p>服务器在相应资源请求是，可以在 Http 头中标记 Large-Allocation，它高速浏览器（目前只有火狐支持）我要使用大量的内存，这可以解决 32 位中堆内存分配问题。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在堆内存中分配的对象，当没有任何引用指向它们时，将会被当做垃圾进行回收，在 WebGL 平台也是如此。和其他平台不同的是，GC 调用的时机不同，在其他平台，为了执行GC，通常会暂停所有线程，然后检查各个线程栈进行垃圾回收，但是在 WebGL 这是行不通的，因为 WebGL 是单线程，因此只在已知栈为空时WebGL 才进行 GC 调用（目前是每帧结束调用一次）。</p>
<p>这通常不会有什么问题，因为每帧的产生的垃圾内存很少，但是下面一段代码时不可行的，因为 WebGL 是单线程，在循环过程中，根本没有机会执行 GC 操作，所以造成的结果就是垃圾越来越多，最后内存分配失败。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> hugeString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    hugeString += <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于内存的更多信息，可以参考<a href="https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/?_ga=2.221042840.1890713557.1584018786-504656146.1571931117" target="_blank" rel="noopener">Understanding Memory in Unity WebGL</a>，和<a href="https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/?_ga=2.148709303.1890713557.1584018786-504656146.1571931117" target="_blank" rel="noopener">Unity WebGL Memory: The Unity Heap</a>。</p>
<h2 id="与浏览器交互"><a href="#与浏览器交互" class="headerlink" title="与浏览器交互"></a>与浏览器交互</h2><p>在构建 WebGL 项目中，可能会需要与 Html 中的元素进行交互，或者通过 WebAPI 实现某些功能，这些都需要和浏览器的 JavaScript 进行交互，下面介绍一下应该怎么做。</p>
<h3 id="从-C-调用-JavaScript-代码"><a href="#从-C-调用-JavaScript-代码" class="headerlink" title="从 C# 调用 JavaScript 代码"></a>从 C# 调用 JavaScript 代码</h3><p>为了调用 JavaScript 代码，首先需要将 JavaScript 文件后缀名修改为 <code>.jslib</code>，并且放到 <code>Assets/Plugins/WebGL</code> 目录，JavaScript 文件需要按照下面的格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mergeInto(LibraryManager.library, &#123;</span><br><span class="line"></span><br><span class="line">  Hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">"Hello, world!"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  HelloString: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(Pointer_stringify(str));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  PrintFloatArray: <span class="function"><span class="keyword">function</span> (<span class="params">array, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    <span class="built_in">console</span>.log(HEAPF32[(array &gt;&gt; <span class="number">2</span>) + i]);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  AddNumbers: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  StringReturnValueFunction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> returnStr = <span class="string">"bla"</span>;</span><br><span class="line">    <span class="keyword">var</span> bufferSize = lengthBytesUTF8(returnStr) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> buffer = _malloc(bufferSize);</span><br><span class="line">    stringToUTF8(returnStr, buffer, bufferSize);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  BindWebGLTexture: <span class="function"><span class="keyword">function</span> (<span class="params">texture</span>) </span>&#123;</span><br><span class="line">    GLctx.bindTexture(GLctx.TEXTURE_2D, GL.textures[texture]);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 C# 端，按照下面格式进行导入。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">HelloString</span>(<span class="params"><span class="keyword">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PrintFloatArray</span>(<span class="params"><span class="keyword">float</span>[] array, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">AddNumbers</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">string</span> <span class="title">StringReturnValueFunction</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">BindWebGLTexture</span>(<span class="params"><span class="keyword">int</span> texture</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Hello();</span><br><span class="line"></span><br><span class="line">        HelloString(<span class="string">"This is a string."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span>[] myArray = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">        PrintFloatArray(myArray, myArray.Length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = AddNumbers(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        Debug.Log(result);</span><br><span class="line"></span><br><span class="line">        Debug.Log(StringReturnValueFunction());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> texture = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>, TextureFormat.ARGB32, <span class="literal">false</span>);</span><br><span class="line">        BindWebGLTexture(texture.GetNativeTextureID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递参数和返回值时，需要注意以下几点：</p>
<ul>
<li>数值类型不需要进行转换即可传输，其他类型需要转换为指针进行传输；</li>
<li>向 JavaScript 传 string 类型，需要调用 <code>Pointer_strigify(str)</code> 转化为 JavaScript 字符串；</li>
<li>从 JavaScript 返回 string 类型，需要使用 <code>_malloc</code>和<code>stringToUTF8</code>，具体参考上面<code>StringReturnValueFunction</code>方法；</li>
<li>数组类型可以通过 <code>HEAP8</code>等类型进行访问，具体参考上面<code>PrintFloatArray</code>方法；</li>
<li>要从 JavaScript 访问贴图，可以通过 <code>GL.textures</code> 字典，键值为 texture 的指针值。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>JavaScript</th>
<th>C#</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAP8</td>
<td>sbyte</td>
</tr>
<tr>
<td>HEAPU8</td>
<td>byte</td>
</tr>
<tr>
<td>HEAP16</td>
<td>short</td>
</tr>
<tr>
<td>HEAPU16</td>
<td>ushort</td>
</tr>
<tr>
<td>HEAP32</td>
<td>int</td>
</tr>
<tr>
<td>HEAPU32</td>
<td>uint</td>
</tr>
<tr>
<td>HEAPF32</td>
<td>float</td>
</tr>
<tr>
<td>HEAPF64</td>
<td>double</td>
</tr>
</tbody>
</table>
</div>
<h3 id="JavaScript-调用-C-代码"><a href="#JavaScript-调用-C-代码" class="headerlink" title="JavaScript 调用 C# 代码"></a>JavaScript 调用 C# 代码</h3><p>从 JavaScript 调用 C#方法，需要获取 <code>unityInstance</code> 对象的 <code>SendMessage</code> 函数，具体格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unityInstance.SendMessage(objectName,methodName,value);</span><br></pre></td></tr></table></figure>
<ul>
<li>objectName : 场景中物体的名称；</li>
<li>methodName ： 要调用的方法的名称；</li>
<li>value ：传递的参数，只能值数值类型、字符串、或为空。</li>
</ul>
<h3 id="调用-C-方法"><a href="#调用-C-方法" class="headerlink" title="调用 C 方法"></a>调用 C 方法</h3><p>在其他平台如果想要调用 C 函数，需要将 C 代码编译为动态链接库，而在 WebGL 平台则是通过<code>emscripten</code> 工具将 C 的源码转换为 JavaScript 代码，所以需要将 C 源码文件，放到 <code>Assets/Plugins/WebGL</code> 目录中。C 代码的编写和其他平台类似，如果时 C++ 代码，需要导出 C 声明接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">Hello</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">AddNumbers</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebGL-模板"><a href="#WebGL-模板" class="headerlink" title="WebGL 模板"></a>WebGL 模板</h2><p>unity 在打包 WebGL时，会将 player 嵌套进一个 Html 文件中，Unity 有两个内置的 hmtl 模板可以选择，但是在正式生产中，我们可能需要根据自己的需要，进行定制，可以按照下面的方法进行模板定制。</p>
<p>首先必须将自定义模板放到 <code>Assets/WebGLTemplates/模板名称</code> 文件夹内，每个模板必须包含一个 <code>index.html</code>文件，依赖的资源也需要放置到该文件夹内，当模板创建完成之后，可以在<code>PlayerSetting</code>中选择创建的模板，可以通过 <code>thumbnail.png</code>（128*128 像素）文件给刚创建的模板，添加一个预览图标，方便进行选择。</p>
<p><code>index.html</code> 文件至少需要包含三个元素：</p>
<ul>
<li>WebGL Loader 的脚本标签：<code>&lt;script src=&quot;%UNITY_WEBGL_LOADER_URL%&quot;&gt;&lt;/script&gt;</code>;</li>
<li>实例化脚本标签：<code>&lt;script&gt; var unityInstance = UnityLoader.instantiate(&quot;unityContainer&quot;, &quot;%UNITY_WEBGL_BUILD_URL%&quot;);&lt;/script&gt;</code>;</li>
<li>一个 div 标签,包含一个 id 属性，其值为实例化中的第一个参数：’\<div id="unityContainer">\</div>‘。</li>
</ul>
<h3 id="UnityLoader-instantiate-container-url-override"><a href="#UnityLoader-instantiate-container-url-override" class="headerlink" title="UnityLoader.instantiate(container, url, override)"></a>UnityLoader.instantiate(container, url, override)</h3><p>container，用于展示内容的容器，通常传入 div 的 id；<br>url，打包时 json 文件地址，通常指定一个宏：<code>%UNITY_WEBGL_BUILD_URL%</code>；<br>override，可选项，用于重写某些预制行为。</p>
<h3 id="模板中可以使用的宏"><a href="#模板中可以使用的宏" class="headerlink" title="模板中可以使用的宏"></a>模板中可以使用的宏</h3><p>可以通过宏来获取打包内容的信息，宏的格式为 <code>%宏名称%</code>，在打包时会将这些宏进行展开，可用的宏列表如下：</p>
<ul>
<li>UNITY_WEBGL_BUILD_URL ： PlayerSetting 中的 ProductName;</li>
<li>UNITY_WEBGL_LOADER_URL : UnityLoader.js 的 url;</li>
<li>UNITY_WEBGL_BUILD_URL : 生成的 json 文件的 url;</li>
<li>UNITY_WIDTH,UNITY_WIDTH : Player 的宽度和高度（像素值）;</li>
<li>UNITY_CUSTOM_SOME_TAG : 如果使用了 <code>UNITY_CUSTOM_XXX</code>这种格式的宏，当选中这个模板时，Unity 将会在属性面板中显示一个输入框，可以设置标签的值。</li>
</ul>
<h3 id="添加进度条"><a href="#添加进度条" class="headerlink" title="添加进度条"></a>添加进度条</h3><p>Unity WebGL 会提供一个默认的加载进度条，当然可以进行自定义。通过重写 <code>UnityLoader.instantiate</code> 中的 <code>override</code> 的 onProgress 行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unityInstance = UnityLoader.instantiate(<span class="string">"unityContainer"</span>, <span class="string">"%UNITY_WEBGL_BUILD_URL%"</span>, &#123;<span class="attr">onProgress</span>: UnityProgress&#125;);</span><br></pre></td></tr></table></figure>
<p>UnityProgress 方法包含两个参数，第一个参数表示 unityInstance 对象，第二个参数表示加载进度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnityProgress</span>(<span class="params">unityInstance, progress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!unityInstance.Module)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!unityInstance.logo) &#123;</span><br><span class="line">    unityInstance.logo = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    unityInstance.logo.className = <span class="string">"logo "</span> + unityInstance.Module.splashScreenStyle;</span><br><span class="line">    unityInstance.container.appendChild(unityInstance.logo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!unityInstance.progress) &#123;</span><br><span class="line">    unityInstance.progress = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    unityInstance.progress.className = <span class="string">"progress "</span> + unityInstance.Module.splashScreenStyle;</span><br><span class="line">    unityInstance.progress.empty = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    unityInstance.progress.empty.className = <span class="string">"empty"</span>;</span><br><span class="line">    unityInstance.progress.appendChild(unityInstance.progress.empty);</span><br><span class="line">    unityInstance.progress.full = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    unityInstance.progress.full.className = <span class="string">"full"</span>;</span><br><span class="line">    unityInstance.progress.appendChild(unityInstance.progress.full);</span><br><span class="line">    unityInstance.container.appendChild(unityInstance.progress);</span><br><span class="line">  &#125;</span><br><span class="line">  unityInstance.progress.full.style.width = (<span class="number">100</span> * progress) + <span class="string">"%"</span>;</span><br><span class="line">  unityInstance.progress.empty.style.width = (<span class="number">100</span> * (<span class="number">1</span> - progress)) + <span class="string">"%"</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress == <span class="number">1</span>)</span><br><span class="line">    unityInstance.logo.style.display = unityInstance.progress.style.display = <span class="string">"none"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity WebGL 开发（二）</title>
    <url>/2020/03/13/UnityWebGLDev2/</url>
    <content><![CDATA[<p>在前文中，主要写了一些关于 WebGL 发布、调试、以及开发限制等问题，本文主要是关于 WebGL平台中的图形渲染、网络、音频相关的东西，WebGL 是在 OpenGL ES 发展来的，WebGL 1.0 基于 OpenGL ES 2.0，WebGL 2.0 基于 OpenGL ES 3.0，目前主流火狐和 Chrome 已经支持 WebGL 2.0，而 Safari 和 Edge 还不支持 2.0。</p>
<a id="more"></a>
<h2 id="渲染相关"><a href="#渲染相关" class="headerlink" title="渲染相关"></a>渲染相关</h2><h3 id="Camera-Clear"><a href="#Camera-Clear" class="headerlink" title="Camera Clear"></a>Camera Clear</h3><p>WebGL 在每帧最后都会清除<code>frame buffer</code>，即使 <code>Camera.clearFlags</code> 设置了 <code>DontClear</code> 也不起作用，如果需要改变这种默认行为，可以通过修改发布模板中的 <code>index.html</code> 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">UnityLoader.instantiate(<span class="string">"unityContainer"</span>, <span class="string">"%UNITY_WEBGL_BUILD_URL%"</span>, &#123;</span><br><span class="line">    Module: &#123;</span><br><span class="line">        <span class="string">"webglContextAttributes"</span>: &#123;<span class="string">"preserveDrawingBuffer"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h3><p>Unity WebGL 平台只在支持 WebGL 2.0 下支持延迟渲染，WebGL 1.0 将会采用前向渲染。</p>
<h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><p>只支持 <code>baked GI</code>，实时 GI 不支持，此外，只支持 <code>Non-Directional</code>光照贴图。</p>
<h3 id="MovieTexture"><a href="#MovieTexture" class="headerlink" title="MovieTexture"></a>MovieTexture</h3><p>WebGL 不支持通过 MovieTexture 播放视频，一种替代的方法是，使用 Html5 的视频组件。</p>
<h3 id="字体渲染"><a href="#字体渲染" class="headerlink" title="字体渲染"></a>字体渲染</h3><p>WebGL 支持动态字体，但是由于它不能访问本机文件系统，所以使用到的字体文件必须放到项目当中。（包括 Fallback fonts，以及粗体和斜体字体）</p>
<blockquote>
<p>为了提高性能，建议在 WebGL 中使用 TMP 来替代默认的 UGUI 文本组件，使用静态字体来替代动态字体。</p>
</blockquote>
<h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>绝大部分的浏览器和 GPU 都支持抗锯齿，只需要在 <code>Quality</code> 设置中启用抗锯齿即可，但是在 WebGL 1.0 中存在一些限制：</p>
<ul>
<li>不能在运行时启用/禁用，必须在系统发布时就确定；</li>
<li>多重采样（multi sampleing 2x、4x…)没有作用，只有开启、关闭两个状态；</li>
<li>如果 Camera 上又任何<code>Post-Processing-Effect</code>，都会引起抗锯齿失效；</li>
<li>HDR 和抗锯齿是不兼容的，如果开启抗锯齿，就需要关闭 <code>Camera</code>上的 <code>Allow HDR</code>选项。</li>
</ul>
<p>WebGL2.0 不存在以上限制。</p>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p>处于安全考虑，JavaScript 没有直接访问 IP 套接字的权限，所以 <code>System.Net</code> 命名空间下的全部类型，<code>System.Net.Sockets</code> 命名空间下的部分类型，在 WebGL 平台是不支持的，同样的还有 <code>UnityEngine.Network*</code> 前缀的类型。</p>
<p>如果需要访问网络，有以下几种选择：</p>
<ul>
<li>使用<code>WWW</code>；</li>
<li>使用<code>UnityWebRequest</code>；</li>
<li>使用新的 Unity Networking 模块；</li>
<li>在 JavaScript 中 WebSocket 或 WebRTC。</li>
</ul>
<h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><p>在 WebGL 平台，<code>WWW</code>和<code>UnityWebRequest</code>都是用 JavaScript 的<code>XMLHttpRequest</code>来实现，通过浏览器来处理 <code>WWW</code> 请求。</p>
<p>假设我们把 WebGL 内容部署在服务器 A，而在运行时，我们需要用 <code>WWW</code> 从另一个服务器 B 下载资源，这就需要 B 服务器通过 <code>CORS</code> 进行授权，如果服务器 B 没有进行 <code>CORS</code> 设置，那么将会在控制台看到如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://myserver.com/. This can be fixed by moving the resource to the same domain or enabling CORS.</span><br></pre></td></tr></table></figure>
<p>更多 CORS 信息可以参考<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="不要使用阻塞代码"><a href="#不要使用阻塞代码" class="headerlink" title="不要使用阻塞代码"></a>不要使用阻塞代码</h3><p>不要是阻塞代码来等待 WWW 或 WebRequest 完成，比如下面代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!www.isDone)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因为 WebGL 是单线程，而 XMLHttpRequest 又是异步方法，整个一直执行 while 循环，而不能更新 XMLHttpRequest 响应信息，可以使用协程和 yield 来等待下载完成。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>在新版 unity 网络模块中，可以设置 <code>Networking.NetworkManager.useWebSockets</code> 来启用 <code>WebSocket</code> 协议。</p>
<p>目前浏览器基本 都支持 WebSocket 和 WebRTC（Safari 不支持），但是Unity 没有公开这两个 API，如果要使用的话，可以使用 JavaScript 插件。</p>
<h2 id="音频相关"><a href="#音频相关" class="headerlink" title="音频相关"></a>音频相关</h2><p>与其他平台采用 FMOD 音频引擎不同， WebGL 由于不支持多线程，因此采用基于 WebApi 的音频控制模块，让浏览器来控制音频的混合和播放，因此 WebGL 音频使用存在很多限制，下面列举 WebGL 平台支持的音频功能，如果没有列出，则说明 WebGL 平台不支持该功能。</p>
<h3 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h3><p>支持属性：</p>
<ul>
<li>clip</li>
<li>dopplerLevel</li>
<li>ignoreListenerPause</li>
<li>ignoreListenerVolume</li>
<li>isPlaying</li>
<li>loop</li>
<li>maxDistance</li>
<li>minDistance</li>
<li>mute</li>
<li>pitch (只支持正值)</li>
<li>playOnAwake</li>
<li>rolloffMode</li>
<li>time</li>
<li>timeSamples</li>
<li>velocityUpdateMode</li>
<li>volume</li>
</ul>
<p>支持函数：</p>
<ul>
<li>Pause</li>
<li>Play</li>
<li>PlayDelayed</li>
<li>PlayOneShot</li>
<li>PlayScheduled</li>
<li>SetScheduledEndTime</li>
<li>SetScheduledStartTime</li>
<li>Stop</li>
<li>UnPause</li>
<li>PlayClipAtPoint</li>
</ul>
<h3 id="AudioListener"><a href="#AudioListener" class="headerlink" title="AudioListener"></a>AudioListener</h3><p>所有的 API 都支持</p>
<h3 id="AudioClip"><a href="#AudioClip" class="headerlink" title="AudioClip"></a>AudioClip</h3><p>WebGL 总是将音频剪辑压缩格式设置为 ACC，因为该格式在浏览器支持比较广泛。</p>
<p>支持的属性：</p>
<ul>
<li>length</li>
<li>loadState</li>
<li>samples</li>
</ul>
<p>支持的方法：</p>
<ul>
<li>AudioClip.Create ：部分支持，传递给该方法的 stream 参数必须为 false，并且调用时整个音频已经加载完成；</li>
<li>AudioClip.SetData ：部分支持，只能进行整体设置，忽略传递的 offsetSamples 参数。</li>
</ul>
<h3 id="SystemInfo-supportsAudio"><a href="#SystemInfo-supportsAudio" class="headerlink" title="SystemInfo.supportsAudio"></a>SystemInfo.supportsAudio</h3><p>WebGL 平台没有实现该参数，总是返回 true。</p>
<h3 id="WWW-audioClip"><a href="#WWW-audioClip" class="headerlink" title="WWW.audioClip"></a>WWW.audioClip</h3><p>只有浏览器原生支持的音频格式，才能够通过通过 WWW.audioClip 进行加载，详细的支持格式可以查询<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats" target="_blank" rel="noopener">这里</a>。</p>
<p>如果只是选择音频格式，可以看下面的表格。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>意图</th>
<th>推荐格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用的压缩格式</td>
<td>MP3</td>
</tr>
<tr>
<td>有损压缩</td>
<td>FLAC</td>
</tr>
<tr>
<td>未压缩</td>
<td>WAV</td>
</tr>
</tbody>
</table>
</div>
<p>视频格式选择</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>意图</th>
<th>推荐格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用格式，开放格式</td>
<td>WebM</td>
</tr>
<tr>
<td>通用格式</td>
<td>MP4</td>
</tr>
<tr>
<td>高压缩比</td>
<td>3GP</td>
</tr>
<tr>
<td>旧设备兼容性好</td>
<td>QuickTime（mov）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Microphone"><a href="#Microphone" class="headerlink" title="Microphone"></a>Microphone</h3><p>不支持</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity WebGL 开发（一）</title>
    <url>/2020/03/12/UnityWebGLDev/</url>
    <content><![CDATA[<p>Unity3D 中的 WebGL 平台旨在替代以前的 UnityPlayer 平台，随着目前多数浏览器都已经能够很好的支持 Html5，因此 WebGL 也更加成熟，为了将项目发布为 WebGL 平台，在打包的时候，Unity 利用 Emscripten 工具链，将引擎的 C/C++ 代码转换为 WebAssembly（一种浏览器可以执行的格式，更加高效），而 C#代码则需要先通过 <code>IL2CPP</code>转换为 C/C++代码，在转换为 WebAssembly。</p>
<a id="more"></a>
<p>虽然目前 Unity3d WebGL 程序能够在大部分主流浏览器上运行，但是也存在一定差异，另外，<font color="red">在手机浏览器上是无法正常运行 WebGL 程序的</font>。</p>
<p>另外由于平台限制，有些功能在 WebGL 上是不支持的:</p>
<ul>
<li>不支持多线程，因为 JavaScript 不支持多线程，所以 <code>System.Threading</code> 命名空间下的类不要使用；</li>
<li>不能在 Vs 中进行断点调试，后面会介绍如何进行调试；</li>
<li>不能直接使用 Socket，包括 <code>System.Net</code>下的任何类型，以及 <code>System.Net.Sockets</code> 下的部分类型，以及 <code>UnityEngine.Network</code>，如果需要在 WebGL 平台使用网络功能，可以使用 <code>WWW</code>或者 <code>UnityWebRequest</code>这些都是基于 <code>Http</code>协议的实现，如要需要高实时性，可以选择 <code>WebSockets</code>或者 <code>WebRTC</code>;</li>
<li>WebGL 1.0是基于 OpenGL ES 2.0，WebGL 2.0基于 OpenGL ES 3.0，所以存在相应的限制；</li>
<li>WebGL 音频是基于自定义的后台，只具备基本的音频功能；</li>
<li>WebGL 是 AOT(ahead of time，即静态编译)平台，因此不能使用 <code>System.Reflection.Emit</code> 下的类型进行代码生成，IL2CPP和 IOS 也是如此。</li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>Unity WebGL 虽然在大部分浏览器上都支持，但是支持程度以及性能表现不一样，另外，在移动设备上是不支持的，虽然在一些高端设备上有可能运行，但是绝大部分设备是没有那么大内存来支持 Unity WebGL 的。</p>
<p>下表列出了<code>Firefox</code>、<code>Chrome</code>、<code>Safri</code>、<code>Edge</code>各个浏览器的支持情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Firefox</th>
<th>Chrome</th>
<th>Safari</th>
<th>Edge</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebAssembly</td>
<td>支持 (Firefox52及之后)</td>
<td>支持 (Chrome 57及之后)</td>
<td>支持 （Safari 11及之后）</td>
<td>支持 （Edge 16）</td>
</tr>
<tr>
<td>WebGL 1.0</td>
<td>支持<sup>1</sup></td>
<td>支持 <sup>1</sup></td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>WebGL 2.0</td>
<td>Firefox 51 及之后</td>
<td>Chrome 56 及之后</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Web Audio</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>全屏</td>
<td>支持</td>
<td>支持</td>
<td>Safari 10.1</td>
<td>支持</td>
</tr>
<tr>
<td>光标锁定</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>Edge13 及之后</td>
</tr>
<tr>
<td>游戏手柄支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>IndexedDB（PlayerPrefs、WWW.LoadFromCacheOrDownload 涉及）</td>
<td>Firefox43 及更高</td>
<td>支持</td>
<td>支持（但是 iFrame 中不支持）</td>
<td>支持</td>
</tr>
<tr>
<td>WebSockets （Networking 涉及）</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>WebRTC（WebCamTexture 涉及）</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>静态编译 asm.js</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>Large-Allocation Http 响应头<sup>2</sup></td>
<td>Firefox 53 或更高</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Brotli 压缩算法（减少打包大小）</td>
<td>支持</td>
<td>支持</td>
<td>Safari 11 或更高</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<p>说明：</p>
<ol>
<li>浏览器厂商为了稳定性，通常会采用黑名单/白名单的方式，针对不同的显卡驱动进行功能限制，在 chrome 中可以通过输入 <code>chrome://gpu</code> 来查看当前 gpu 的状态，或者可以在<a href="https://www.khronos.org/webgl/wiki/BlacklistsAndWhitelists" target="_blank" rel="noopener">这里</a>查询；</li>
<li>Large-Allocation 响应头是高速浏览器需要分配大量内存，目前只有 Firefox 支持。</li>
</ol>
<h2 id="编译运行-WebGl-项目"><a href="#编译运行-WebGl-项目" class="headerlink" title="编译运行 WebGl 项目"></a>编译运行 WebGl 项目</h2><p>WebGL 项目打包之后，会生成如下文件结构：</p>
<ul>
<li>index.html</li>
<li>TemplateData - 包括logo、加载进度条，只有模板选择 Default 时才有）</li>
<li>StreamingAssets - 项目中的 StreamingAssets 文件夹(WebGL平台下 Application.streamingAssetsPath 的值为 <code>http://youer_host_url:port/StreamingAssets</code>)</li>
<li>Build<ul>
<li>UnityLoader.js - 加载 unity 内容的脚本</li>
<li><em>myproject</em>.json - PlayerSetting 中的部分设置以及其他资源的 Url，给 UnityLoader 用的</li>
<li><em>myproject</em>.wasm.framework.unityweb - JavaScript 运行时和插件</li>
<li><em>myproject</em>.wasm.code.unityweb - 编译完成的 WebAssembly</li>
<li><em>myproject</em>.wasm.memory.unityweb - </li>
<li><em>myproject</em>.data.unityweb - 项目中的资源和场景</li>
</ul>
</li>
</ul>
<p>Build 文件夹下载 *.unityweb 文件，可能是压缩文件，由 PlayerSetting/publishing setting/Compression Format 设置。</p>
<p>生成完毕之后，可以用浏览器打开 <code>index.html</code> 文件，由于 Chrome 不允许运行本地文件，因此需要将生成文件放到 Web 服务器，或者通过 unity 的 <code>Build And Run</code>，unity 会在编译完成之后启动一个本机 web 服务器。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><p>可以获得什么：</p>
<ul>
<li>内置 Console，方便查看错误；</li>
<li>可读性良好的 JavaScript，Release 版的会压缩代码，不具备可读性；</li>
<li>查看调用堆栈；</li>
<li>可以连接 Unity Profiler 进行性能调试；</li>
</ul>
<p>缺点：</p>
<ul>
<li>增大发布内容</li>
</ul>
<p>WebGL 平台不要在 Vs 中进行调试，而要使用 Chrome 的开发者工具进行调试，常见错误：</p>
<p>Problem:The build runs out of memory<br>这通常在 32 位浏览器上出现，原因是内容占用内存过大，浏览器分配内存失败。</p>
<p>Problem:Files saved to Application.persistentDataPath do not persist<br>持久化文件没有保存完成，Unity WebGL 将所有持久化数据（PlayerPrefs、缓存）都保存到浏览器的 IndexedDB 中，在开发者工具中，可以通过 <code>Application</code> 标签页查看，这一API 是异步的，所以不知道什么时候能够完成。</p>
<p>Error message: Incorrect header check<br>通常是服务器配置不正确。</p>
<p>Error message: Decompressing this format (1) is not supported on this platform<br>通常是加载 LZMA 压缩格式的 AssetBundle 时发生，WebGL 平台不支持 LZMA 格式，改用 LZ4 格式压缩。</p>
<h3 id="重要发布设置"><a href="#重要发布设置" class="headerlink" title="重要发布设置"></a>重要发布设置</h3><h4 id="Disable-HW-Statistics"><a href="#Disable-HW-Statistics" class="headerlink" title="Disable HW Statistics"></a>Disable HW Statistics</h4><p>默认不勾选，表示将会在加载内容时，向 Unity 发送你的硬件信息、用户信息等，建议勾选上，因为国内网络访问 Unity 服务器比较慢，会降低内容的加载速度。</p>
<p>如果勾选的话，在 Chrome 中可以看到它会向 <code>https://config.uca.cloud.unity3d.com/</code> 发送请求，可以看到他的发送内容。</p>
<h4 id="代码裁剪"><a href="#代码裁剪" class="headerlink" title="代码裁剪"></a>代码裁剪</h4><p>Strip Engine Code</p>
<p>默认勾选，表示对于项目中没有用到类型，将会把那一部分代码剔除掉，从而减少编译大小，提高运行时的性能。Unity 会扫描项目中所有从 UnityObject 继承的类型，包括检查它的内部引用以及序列化字段，将会移除没有任何引用的类型，从而减少发布大小，生成的代码也更少、更快、内存占用更少。</p>
<p>代码裁剪可能引起的问题：</p>
<p>可能会裁剪掉实际用到的类型，比如预制体包含一个类型 A，而将该预制体打包到 AssetBundle 之中，Unity 就可能将 A 类型裁剪掉，运行时将在控制到看到错误 <code>Could not produce class with ID XXX</code>，可以按照下面两步来解决该问题：</p>
<ol>
<li>根据提示 ID，查找裁剪的类型，查找地址：<a href="https://docs.unity3d.com/Manual/ClassIDReference.html" target="_blank" rel="noopener">这里</a>；</li>
<li>将该类型在脚本中引用一下，或者在创建 Assets 目录下 <code>link.xml</code>，格式如下。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine.Collider"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">liner</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想要查看裁剪之后 Unity 包含了内些类型，可以在打包之后，找到文件 <code>Temp/StagingArea/Data/il2cppOutput/UnityClassRegistration.cpp</code> 进行查看，除此之外没有其他更加方便的方法。</p>
<p>另一一点需要知道的是 <code>Strip Engine Code</code>选项只是针对 Unity 的本机代码，对于托管代码来说，总是会进行代码裁剪，IL2CPP 通过托管 DLL，以及代码脚本中的静态引用，来进行代码裁剪，如果代码中使用反射来获取类型，那么同样的，该类型有可能被裁剪掉，因此也需要添加到 <code>linker.xml</code>中。</p>
<p>Enable Exceptions</p>
<p>该设置主要用来设置如何处理程序中的异常：</p>
<ul>
<li>None 不需要异常支持，性能最好，发布包最小，但是任何错误都会引起系统停止；</li>
<li>Explicitly Thrown Exceptions Only ： 默认设置，能够捕获由代码中 throw 抛出的异常，并且能够正确执行 finally 语句块，这将会引起生成大 JavaScript 代码更长、更慢，但这通常只在代码引起瓶颈时才要考虑；</li>
<li>Full Without Stacktrace：能够捕捉如下异常：<ul>
<li>throw 抛出的异常</li>
<li>空引用异常，Null Reference</li>
<li>数组越界</li>
</ul>
</li>
<li>Full With Stacktrace：和上面多了一个调用栈信息，通常应该在调试阶段使用，并且在 64 位浏览器中测试。</li>
</ul>
<p>Data Caching</p>
<p>默认启用，会使用资源缓存到浏览器的 IndexedDB 数据库，在后面运行的时候不用再次从服务器下载资源，不同浏览器的缓存策略也不尽相同。</p>
<p>如果只是想进行空引用检查和数组越界检查，而不想完全支持异常，可以通过如下代码来支持：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebGLEditorScript</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"WebGL/EnableNullChecks"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnableNullChecks</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        PlayerSettings.SetPropertyString(<span class="string">"additionalIl2CppArgs"</span>, <span class="string">"--emit-null-checks --enable-array-bounds-check"</span>,UnityEditor.BuildTargetGroup.WebGL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="降低发布尺寸"><a href="#降低发布尺寸" class="headerlink" title="降低发布尺寸"></a>降低发布尺寸</h3><p>WebGl 平台的内容是需要用户通过浏览器，从 Web 服务器上进行下载，所以控制好发布大小，减少用户的加载时间是非常有必要的，可以通过以下几种方式帮助实现：</p>
<ul>
<li>贴图采用有损压缩格式，即 Crunch Compression；</li>
<li>不要使用开发版本发布；</li>
<li>可以酌情考虑将 Enable Exception 设置为 None；</li>
<li>启用 Strip Engine Code</li>
<li>特别关注第三方托管库，因为它可能依赖很多系统库，造成 Strip Engine Code 不能有效减少尺寸。</li>
<li>启用 Compression Format</li>
</ul>
<h3 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h3><p>因为 WebGL 在启动之前，需要将所有的资源预加载完成，因此减少启动时间的一个有效方式就是减少系统资源，或者说减少发布资源，可以利用 AssetBundle 将资源从主包中分离出来，这样，只需要加载一个非常小的加载场景即可，另外 AssetBundle 还能帮助资源管理。</p>
<p>在 WebGl 平台使用 AssetBundle 有以下几点需要注意：</p>
<ul>
<li>AssetBundle 中包括主包中没有的类型时，会引起资源加载失败，最好是在 AssetBundle 中不要打包新类型；</li>
<li>WebGL 不支持多线程，而AssetBundle 数据在 Http 下载完成后才可用，因此，AssetBundle 就需要在主线程进行解压缩，这会引起主线阻塞，LZMA 在 WebGL 平台是不可用的，因为它是整包压缩，可以采用 LZ4 压缩，它是单个资源独立压缩，即加载单个资源时，不需要解压整个资源包，如果需要更小的资源包格式，可以采用 gzip 或者 brotli 进行二次压缩，不过这需要 web 服务器进行相应的配置；</li>
<li>支持 WWW.LoadFromCacheOrDownload 方法，它采用浏览器的 IndexedDB 来实现缓存；</li>
</ul>
<h3 id="改变-Build-文件夹位置"><a href="#改变-Build-文件夹位置" class="headerlink" title="改变 Build 文件夹位置"></a>改变 Build 文件夹位置</h3><p>当把发布完成的内容放到服务器时，可能需要将 Build 文件夹放到其他的位置，这里需要修改两个地方:</p>
<ol>
<li>index.html 中修改 json 文件的 url；</li>
<li>修改 json 文件中各个 url，其中的相对位置，会认为是相对 json 文件的位置。</li>
</ol>
<h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p>IL2CPP 采用增量式编译，代码的编译结果会缓存到 <code>Library/il2cpp_cache</code>，如果代码没有变化，将不会进行再次编译，如果需要进行重新编译，只需要删除该文件夹即可。</p>
<h2 id="压缩打包"><a href="#压缩打包" class="headerlink" title="压缩打包"></a>压缩打包</h2><p>前面提过在 <code>PlayerSetting</code> 中可以设置发布内容的压缩格式，分别是：</p>
<ul>
<li>gzip ： 默认格式，压缩率不如 brotli，但是打包速度要快一些，并且 <code>http</code> 和 <code>https</code>都支持；</li>
<li>brotli ： 压缩率最好，但是打包速度要慢，但是只有 <code>https</code> 协议中支持；</li>
<li>disabled ： 不压缩。</li>
</ul>
<p>目前主流的浏览器都已经支持了压缩格式，能够在 <code>http(s)</code>传输过程中，将压缩的数据进行解压，这在效率上要比 js 进行解压要快很多。</p>
<p>另外，unity 在发布时也提供了 js 实现的解压器，如果浏览器解压失败的话，将会采用 js 解压的方式，当然这会带来一些性能损失，增长内容加载时间。</p>
<p>为了让浏览器在 <code>http(s)</code>传输过程中进行解压，需要Web 服务器通过 http(s)头来告诉浏览器，传输内容的压缩格式，就需要对 Web 服务器进行相应的设置。</p>
<h3 id="Apache-服务器设置"><a href="#Apache-服务器设置" class="headerlink" title="Apache 服务器设置"></a>Apache 服务器设置</h3><p>设置 <code>Build</code> 文件夹中的 <code>.htaccess</code> 文件，如果没有进行创建：</p>
<p>gzip 压缩格式设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_mime.c</span>&gt;</span></span><br><span class="line">  AddEncoding gzip .unityweb</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>grotli 压缩设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_mime.c</span>&gt;</span></span><br><span class="line">  AddEncoding gzip .unityweb</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="IIS-服务器设置"><a href="#IIS-服务器设置" class="headerlink" title="IIS 服务器设置"></a>IIS 服务器设置</h3><p>IIS 默认是无法访问未知的 MIME 类型，所以需要先给 <code>.unityweb</code> 指定 MIME 类型，这里有两种方式：</p>
<ul>
<li>通过 IIS Manager 界面，选择网站的 MIME Types 设置，选择添加，然后关联 <code>.unityweb</code>到 <code>application/octet-stream</code>;</li>
<li>通过网站配置文件<code>.config</code>文件，该文件是影响网站所有子目录的，所以只需要修改根目录即可，修改内容如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面设置完成之后，需要设置压缩格式支持，同样在 <code>Build</code>目录创建 <code>web.config</code>文件，内容如下：</p>
<p>gzip 压缩</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">"Append gzip Content-Encoding header"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">"RESPONSE_Content-Encoding"</span> <span class="attr">pattern</span>=<span class="string">".*"</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">add</span> <span class="attr">input</span>=<span class="string">"&#123;REQUEST_FILENAME&#125;"</span> <span class="attr">pattern</span>=<span class="string">"\.unityweb$"</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">"Rewrite"</span> <span class="attr">value</span>=<span class="string">"gzip"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>brotli 压缩</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">"Append br Content-Encoding header"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">"RESPONSE_Content-Encoding"</span> <span class="attr">pattern</span>=<span class="string">".*"</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">add</span> <span class="attr">input</span>=<span class="string">"&#123;REQUEST_FILENAME&#125;"</span> <span class="attr">pattern</span>=<span class="string">"\.unityweb$"</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">"Rewrite"</span> <span class="attr">value</span>=<span class="string">"br"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="流式-WebAssembly"><a href="#流式-WebAssembly" class="headerlink" title="流式 WebAssembly"></a>流式 WebAssembly</h3><p>从 <code>2019.2</code>开始，增加了 <code>WebAssembly streaming</code> 选项，它能够提高内容的启动速度，它是通过浏览器在下载 WebAssembly 的同时，进行 WebAssembly 的转换和编译。 </p>
<p>Web 服务器需要进行相关配置，和配置压缩格式类似。</p>
<h4 id="Apache-服务器配置"><a href="#Apache-服务器配置" class="headerlink" title="Apache 服务器配置"></a>Apache 服务器配置</h4><p>修改 <code>.htaccess</code> 文件</p>
<p>如果未压缩：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_mime.c</span>&gt;</span></span><br><span class="line">  AddType application/wasm .wasm</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>gzip 压缩</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_mime.c</span>&gt;</span></span><br><span class="line">  AddEncoding gzip .unityweb</span><br><span class="line">  AddEncoding gzip .wasm</span><br><span class="line">  AddType application/wasm .wasm</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>brotli 压缩</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_mime.c</span>&gt;</span></span><br><span class="line">  AddEncoding br .unityweb</span><br><span class="line">  AddEncoding br .wasm</span><br><span class="line">  AddType application/wasm .wasm</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="IIS-设置"><a href="#IIS-设置" class="headerlink" title="IIS 设置"></a>IIS 设置</h4><p>修改 Build 文件夹的 web.config 文件。</p>
<p>未压缩设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> <span class="attr">mimeType</span>=<span class="string">"application/wasm"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>gzip 设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> <span class="attr">mimeType</span>=<span class="string">"application/wasm"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">"Append gzip Content-Encoding header"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">"RESPONSE_Content-Encoding"</span> <span class="attr">pattern</span>=<span class="string">".*"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">add</span> <span class="attr">input</span>=<span class="string">"&#123;REQUEST_FILENAME&#125;"</span> <span class="attr">pattern</span>=<span class="string">"\.(unityweb|wasm)$"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">"Rewrite"</span> <span class="attr">value</span>=<span class="string">"gzip"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>brotli 设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".unityweb"</span> <span class="attr">mimeType</span>=<span class="string">"application/octet-stream"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".wasm"</span> <span class="attr">mimeType</span>=<span class="string">"application/wasm"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">"Append br Content-Encoding header"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">"RESPONSE_Content-Encoding"</span> <span class="attr">pattern</span>=<span class="string">".*"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">add</span> <span class="attr">input</span>=<span class="string">"&#123;REQUEST_FILENAME&#125;"</span> <span class="attr">pattern</span>=<span class="string">"\.(unityweb|wasm)$"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">"Rewrite"</span> <span class="attr">value</span>=<span class="string">"br"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中配置Android环境</title>
    <url>/2020/03/07/AndroidEnvSetupInUnity/</url>
    <content><![CDATA[<p>电脑升级之后，发现某些软件不能用了，需要进行重新安装，环境需要重新配置，这里简单记录一下 Unity Android 开发环境配置。</p>
<a id="more"></a>
<p>软件版本：</p>
<ul>
<li>操作系统：macOS 10.15.1</li>
<li>Unity 版本：2018.2.5 f1</li>
<li>Android Studio 版本：3.6.1</li>
<li>JDK 版本：1.8.0_241 (8u241)</li>
<li>NDK 版本：r13b (IL2CPP需要)</li>
</ul>
<p>下载地址：</p>
<ul>
<li>Android Studio: <a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">3.6.1</a></li>
<li>JDK,NDK：建议直接从 Unity 中进行下载，具体步骤是: <code>Unity -&gt; Preference -&gt; External Tools</code> 点击 <code>download</code> 进行下载，其他版本打包时可能报错。</li>
</ul>
<h2 id="JDK-安装"><a href="#JDK-安装" class="headerlink" title="JDK 安装"></a>JDK 安装</h2><p>如果需要查看本机已经安装的 JDK，可以通过如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>
<h2 id="Android-SDK-安装"><a href="#Android-SDK-安装" class="headerlink" title="Android SDK 安装"></a>Android SDK 安装</h2><p>在 AS 下载完成之后，打开 <code>SDK Manager</code> 下载 SDK，安装 Build Tools，在安装 Build Tools 的时候需要注意，一定要安装正式版，不要安装 <code>RC版</code>等其他版本。</p>
<p>SDK Manager 会将 SDK 默认安装到 <code>/Users/xxx/Library/Android/sdk</code></p>
<h2 id="NDK-安装"><a href="#NDK-安装" class="headerlink" title="NDK 安装"></a>NDK 安装</h2><p>ndk 是编译 IL2CPP 时需要用的，但是采用 mono 打包时也会用到 ndk 的 tool-chains，所以 ndk 是必须要安装的，只不过 IL2CPP 需要在 Unity 设置 ndk 路径。</p>
<p>ndk 不能通过 SDK Manager 进行安装，因为 Unity 需要特定版本的 ndk（2018对应 ndk r13b） 其它版本 Unity 无法识别，通过 Unity 内提供的方式进行下载，将下载的 NDK 解压到 <code>sdk/ndk</code> 目录，如果没有可以手动创建一个。</p>
<p>但是现在 NDK 还是不能用，直接运行其中的程序，会报<code>未知开发者</code>警告，这里有两种办法：</p>
<ol>
<li>命令行执行<code>sudo spctl --master-disable</code>，然后在<code>系统偏好设置 -&gt; 安全 -&gt; 任何来源</code>；</li>
<li>第二种是在打包的过程中，每次都需要在偏好设置中进行允许，整个过程可能需要很多次才能完成。</li>
</ol>
<h2 id="Unity-配置"><a href="#Unity-配置" class="headerlink" title="Unity 配置"></a>Unity 配置</h2><p>至此环境基本安装完成，下面需要再 Unity 中进行配置，打开 <code>Unity -&gt; Preference -&gt; External Tools</code>，选择 SDK、JDK、NDK 的安装目录，点击 <code>Browser</code> 会自动查找，需要注意找到的版本是不是对的，如果不对手动进行选择。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>将项目切换 Android 平台，在 <code>Player Setting</code> 中设置好 <code>Package Name</code>，<code>Version</code>，<code>Company Name</code>等信息，<code>Build System</code>采用默认 <code>Gradle</code>，不勾选 <code>Export Project</code>，点击 <code>Build</code> 进行打包，如果配置正确，将成功生成 apk。</p>
<h2 id="遇上的问题"><a href="#遇上的问题" class="headerlink" title="遇上的问题"></a>遇上的问题</h2><p>编译失败后，可以在 Console 看到相关的错误信息，总结以下几个：</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</span><br></pre></td></tr></table></figure>
<p>造成该问题是原因是，Unity 会用 sdk 目录下的 ndk，而非 Unity 配置中指定的路径，我这里是存在一个 ndk-bundle 目录，直接将 ndk-bundle 删除即可。</p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to find Build Tools revision 30.0.0</span><br></pre></td></tr></table></figure>
<p>原因是我之前在 SDM Manager 中安装 Build Tools 时，安装了 30.0.0-RC 版，其安装目录是 <code>sdk/build-tools/30.0.0-rc</code>，可能是 Unity 会查找<code>sdk/build-tools/30.0.0</code>，结果肯定是找不到。</p>
<p>解决办法是卸载了 rc 版本，安装正式发布版。</p>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ApkSignerTool has been compiled by a more recent version of the Java Runtime</span><br></pre></td></tr></table></figure>
<p>这是 JDK 版本低的问题，最好安装 Unity 指定的版本。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode+CMake搭建OpenGL开发环境</title>
    <url>/2019/12/12/OpenGLDevWithVSCode-CMake/</url>
    <content><![CDATA[<p>OpenGL跨平台开发环境很多种，自动化构建的话首选 <code>CMake</code>，编辑器方面可选的比较多，个人非常喜欢 <code>Jetbrains</code> 的 <code>CLion</code>，代码提示和自动补全功能非常强大，目前没有提供社区版本，需要购买激活，另一个比较推荐的就是微软的 <code>VSCode</code>，它的插件非常丰富，非常轻量，并且免费开源，下面介绍一下基于 <code>VSCode</code>和<code>CMake</code> 搭建 <code>OpenGL</code>的开发环境，我这里的的操作系统为 <code>OSX</code>。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建环境需要的软件包括：</p>
<ul>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a>，安装 <code>C/C++</code>、<code>CMakeTools</code>插件</li>
<li><a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake</a></li>
</ul>
<p><code>OpenGL</code>项目需要的第三方库：</p>
<ul>
<li><a href="https://www.glfw.org/" target="_blank" rel="noopener">GLFW</a> 用于定义窗口、上下文以及处理用户输入等等；</li>
<li><a href="https://glad.dav1d.de/" target="_blank" rel="noopener">GLAD</a> 提供了跨平台的访问 OpenGL 接口，因为 OpenGL 只是提供了标准，具体的实现是由各个显卡的驱动去做，由于驱动版本众多，很多函数在编译期没有办法确定，只能通过<code>LoadLibrary</code>的方式在运行时查找，每个函数都这么干非常麻烦，<code>glad</code> 就是用来完成这部分工作的。</li>
</ul>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>下面假设已经把<code>VSCode</code>和<code>CMake</code>安装好了，直接介绍如果设置项目，以及如何编译、配置类库。</p>
<h3 id="编译-glfw"><a href="#编译-glfw" class="headerlink" title="编译 glfw"></a>编译 glfw</h3><p>编译需要工具：</p>
<ul>
<li>CMake；</li>
<li>Unix 系统使用 Make，Windows 使用 Visual Studio 或者 MinGW。</li>
</ul>
<p>从 <a href="https://www.glfw.org/" target="_blank" rel="noopener">glfw 官网</a> 直接下载源码并解压，然后开始编译：</p>
<p>打开命令行，切换到解压后的 <code>glfw</code> 根目录，然后依次执行如下命令：</p>
<p>编译动态库，编译完的动态库在<code>build/src</code>目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DBUILD_SHARED_LIBS=ON ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>编译静态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake .</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>然后将库安装到本机，执行如下命令，动态库将会被安装到<code>usr/local/lib</code>目录，头文件安装到<code>usr/local/include</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="准备-glad"><a href="#准备-glad" class="headerlink" title="准备 glad"></a>准备 glad</h3><p>进入<a href="https://glad.dav1d.de/" target="_blank" rel="noopener">下载页面</a>下载 <code>glad</code>，它提供了一个生成器，选择如下：</p>
<ul>
<li><code>Language</code>选择<code>C/C++</code>；</li>
<li><code>Specification</code> 选择 <code>OpenGL</code>;</li>
<li><code>gl</code> 我这里选择的是 <code>Version 3.3</code>;</li>
<li><code>Profile</code> 选择 <code>Core</code>.</li>
</ul>
<p>然后点击下面的 <code>Generate</code> 进行下载，下载完成后进行解压即可，不需要进行编译，直接在项目中引用源文件即可。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>VSCode 创建项目很简单，打开一个空的文件夹即可，然后创建 <code>CMakeList.txt</code>，如果安装了 ‘CMake Tools’插件，可以直接按下 <code>F1</code>，然后执行 <code>CMake:Quick Start</code>命令帮助快速创建。</p>
<h4 id="安装-glad"><a href="#安装-glad" class="headerlink" title="安装 glad"></a>安装 glad</h4><p>这一步很简单，将 <code>include</code> 文件夹下的 <code>glad</code>、<code>KHR</code> 拷贝到项目中的 <code>include</code> 文件夹（没有的话进行创建），然后将 <code>src/glad.c</code> 拷贝到项目中。</p>
<h4 id="配置库和框架"><a href="#配置库和框架" class="headerlink" title="配置库和框架"></a>配置库和框架</h4><p>修改 <code>CMakeList.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloGL VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 C++ 11 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件</span></span><br><span class="line"><span class="keyword">set</span>(GLAD_H <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(GLFW_H /usr/local/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;GLAD_H&#125;</span> <span class="variable">$&#123;GLFW_H&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加目标链接</span></span><br><span class="line"><span class="keyword">set</span>(GLFW_LINK /usr/local/lib/libglfw.<span class="number">3</span>.dylib)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;GLFW_LINK&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译命令</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES glad.c main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(HelloGL <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接系统的 OpenGL 框架</span></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(HelloGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_NAME <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure>
<h4 id="验证测试代码"><a href="#验证测试代码" class="headerlink" title="验证测试代码"></a>验证测试代码</h4><p>修改 <code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// uncomment this statement to fix compilation on OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    GLFWwindow *window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fail to create window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        processInput(window);</span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成与调试"><a href="#生成与调试" class="headerlink" title="生成与调试"></a>生成与调试</h4><p>可以通过 <code>CMake Tools</code>提供的图形界面进行生成，也可以通过一下命令，打开 <code>F1</code>，执行命令<code>CMake:Build</code>。如果显示生成成功，说明环境配置成功，显示结果如下：</p>
<img src="/2019/12/12/OpenGLDevWithVSCode-CMake/display.jpg">
<p>如果需要调试程序，在 Debug 面板中点击齿轮按钮，然后选择<code>C++(GDB/LLDB)</code>调试器，再选择默认配置，最后修改 <code>launch.json</code> 中的 <code>program</code> 属性，指向生成的程序：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"(lldb) 启动"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build/HelloGL"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"lldb"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>graphics</category>
      </categories>
  </entry>
  <entry>
    <title>关于Object.Destry和空检查</title>
    <url>/2019/11/20/UnityObjectDestrayInDetail/</url>
    <content><![CDATA[<p>在 Unity3D 中总是要进行对象的销毁和Null 检查，虽然经常用，但是其中的一些细节，如果不太注意，很有可能就会踩坑，下面就总结一下 <code>UnityEngine.Object</code> 类型的销毁，以及空值检测相关问题。</p>
<a id="more"></a>
<h2 id="Object-Destroy-Vs-Object-DestroyImmediate"><a href="#Object-Destroy-Vs-Object-DestroyImmediate" class="headerlink" title="Object.Destroy Vs Object.DestroyImmediate"></a>Object.Destroy Vs Object.DestroyImmediate</h2><p>Unity3D 提供了两种方式来销毁对象（GameObject/Component)，分别是 <code>Object.Destroy</code>和<code>Object.DestroyImmediate</code>，两者区别主要有两点：</p>
<ol>
<li>Destroy 提供了延迟销毁参数，可以延迟<code>x</code>秒后进行销毁，<strong>即使不指定延迟参数，Destroy也将推迟到当前更新结束，渲染开始之前执行</strong>；</li>
<li>DestroyImmediate 调用立即销毁对象；</li>
</ol>
<blockquote>
<p>User Manual 中关于 Object.Destroy 的相关说明 : Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.</p>
</blockquote>
<p>关于Unity3D的事件更新流程，可以参考<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank" rel="noopener">用户手册</a>.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject g1, g2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        g1 = <span class="keyword">new</span> GameObject();</span><br><span class="line">        g2 = <span class="keyword">new</span> GameObject();</span><br><span class="line"></span><br><span class="line">        Destroy(g1);</span><br><span class="line">        DestroyImmediate(g2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy 调用之后，不会立即销毁，需要等到更新结束</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"G1 destroy? ::&#123;0&#125;"</span>, g1 == <span class="literal">null</span>);   <span class="comment">// false</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"G2 destroy? ::&#123;0&#125;"</span>, g2 == <span class="literal">null</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        StartCoroutine(EndOfFrame());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">EndOfFrame</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前帧结束，物体被销毁了</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"G1 destroy at frame end ? ::&#123;0&#125;"</span>, g1 == <span class="literal">null</span>);   <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G1 destroy? ::False</span><br><span class="line">G2 destroy? ::True</span><br><span class="line">G1 destroy at frame end ? ::True</span><br></pre></td></tr></table></figure>
<h2 id="Object-对象的-Null-检测"><a href="#Object-对象的-Null-检测" class="headerlink" title="Object 对象的 Null 检测"></a>Object 对象的 Null 检测</h2><p>从 <code>UnityEngine.Object</code> 继承的对象，包括<strong>托管</strong>和<strong>非托管</strong>两部分，当调用 <code>Destroy</code> 时，销毁的只是非托管部分，托管部分只能通过 C# 的垃圾回收器进行回收，先看下面一个例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample02</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject g1 = <span class="keyword">new</span> GameObject();</span><br><span class="line"></span><br><span class="line">        Object.DestroyImmediate(g1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测 g1 是否被销毁 ：true</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"Is g1 destroy? &#123;0&#125;"</span>, g1 == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测 g1 是否指向 null ：false</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"Is g1 reference null? &#123;0&#125;"</span>, Object.ReferenceEquals(g1, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Is g1 destroy? True</span><br><span class="line">Is g1 reference null? False</span><br></pre></td></tr></table></figure>
<p>可以看出来，通过 <code>g1 == null</code> 来判断<code>Object</code>是否被销毁，而通过<code>ReferenceEquals</code>则没有办法判断，这是因为 <code>g1</code> 一直指向堆对象，除非我们显示的执行<code>g1 = null</code>，<code>ReferenceEquals(g1,null)</code>才能返回 <code>ture</code>；</p>
<p>C# 引用类型默认也会调用<code>ReferenceEquals</code>来比较相等性，那么为什么 <code>g1 == null</code> 却返回 <code>true</code> 呢，这是因为 基类<code>UnityEngine.Object</code> 重写了 <code>operator==</code> 操作符，具体的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Object x,Object y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> xnull = (<span class="keyword">object</span>)x == <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">bool</span> ynull = (<span class="keyword">object</span>)y == <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xnull &amp;&amp; ynull)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!xnull)</span><br><span class="line">        <span class="keyword">return</span> !IsNativeObjectAlive(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ynull)</span><br><span class="line">        <span class="keyword">return</span> !IsNativeObjectAlive(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x.m_InstanceID == y.m_InstanceID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里顺便说一句，<code>Object</code> 类还重写了 <code>operator bool</code> 操作符，所以 <code>if(g1){}</code> 的含义是，当<code>g1</code><strong>非空</strong>时，执行相应的代码块。</p>
<h2 id="接口类型的-Null-检测"><a href="#接口类型的-Null-检测" class="headerlink" title="接口类型的 Null 检测"></a>接口类型的 Null 检测</h2><p>在 C# 中，比较接口类型的相等性时，总是会采用<code>RenferenceEquals</code> 来判断，（对于值类型，需要先进行装箱，再进行比较），一般情况下，这点不会引起上面问题，但是当自定义的 <code>MonoBehaviour</code> 类实现某个接口时，如果对该接口类型进行相等性比较，其结果就可能不正确，还是看下面一个例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample02</span> : <span class="title">MonoBehaviour</span>, <span class="title">IGreet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Sample02 sample02 = gameObject.AddComponent&lt;Sample02&gt;();</span><br><span class="line"></span><br><span class="line">        IGreet ig = sample02;</span><br><span class="line"></span><br><span class="line">        DestroyImmediate(sample02);</span><br><span class="line"></span><br><span class="line">        Debug.LogFormat(<span class="string">"Is obj destroy? &#123;0&#125;"</span>, sample02 == <span class="literal">null</span>);</span><br><span class="line">        Debug.LogFormat(<span class="string">"Is interface equals null ? &#123;0&#125;"</span>, ig == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IGreet</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Is obj destroy? True</span><br><span class="line">Is interface equals null ? False</span><br></pre></td></tr></table></figure>
<p>是不是对结果感到很奇怪，其根本原因是因为，对于接口类型调用<code>operator==</code>，总是会调用 <code>ReferenceEqual</code>进行比较，这一点可以通过反编译 <code>IL</code> 代码进行验证，而 <code>sample02 == null</code> 则会调用基类方法。</p>
<p>那么对于接口类型，应该如何判断接口对象是否被销毁了呢，很简单，只需要给接口添加个判断方法，还是上面的例子，修改后的接口如下:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample02</span> : <span class="title">MonoBehaviour</span>, <span class="title">IGreet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Sample02 sample02 = gameObject.AddComponent&lt;Sample02&gt;();</span><br><span class="line"></span><br><span class="line">        IGreet ig = sample02;</span><br><span class="line"></span><br><span class="line">        DestroyImmediate(sample02);</span><br><span class="line"></span><br><span class="line">        Debug.LogFormat(<span class="string">"Is obj destroy? &#123;0&#125;"</span>, sample02 == <span class="literal">null</span>);       <span class="comment">// true</span></span><br><span class="line">        Debug.LogFormat(<span class="string">"Is interface equals null ? &#123;0&#125;"</span>, ig == <span class="literal">null</span>);  <span class="comment">// false</span></span><br><span class="line">		Debug.LogFormat(<span class="string">"Is interface destroy? &#123;0&#125;"</span>,ig.IsDestroy());    <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IGreet</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 UGUI 源码中，ICanvasElement 接口就是采用这种方法来实现，UIBehavior 类继承自 MonoBehavior，并实现了 ICanvasElement 接口</p>
</blockquote>
<h2 id="对于-Object-类型，避免使用-和-操作符"><a href="#对于-Object-类型，避免使用-和-操作符" class="headerlink" title="对于 Object 类型，避免使用 ?? 和 ?. 操作符"></a>对于 Object 类型，避免使用 ?? 和 ?. 操作符</h2><p>在用户手册中，明确说明了 Object 类型不支持 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#null-conditional-operator" target="_blank" rel="noopener">null-conditional operator (?.)</a> 和 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#the-null-coalescing-operator" target="_blank" rel="noopener">the null-coalescing operator (??)</a>，这是因为 Object 类型，并没有提供这两个操作符的重载，可能造成某些不正确的行为，看下面例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample02</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject g1 = <span class="keyword">new</span> GameObject();</span><br><span class="line"></span><br><span class="line">        Object.DestroyImmediate(g1);</span><br><span class="line"></span><br><span class="line">        GameObject newGo = g1 ?? <span class="keyword">new</span> GameObject(<span class="string">"NewGo"</span>);</span><br><span class="line"></span><br><span class="line">        Debug.LogFormat(<span class="string">"newGo == null : &#123;0&#125;"</span>, newGo == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">newGo == null : True</span><br></pre></td></tr></table></figure>
<p>产生这一结果的原因还是因为，<code>operator ??</code>默认采用 <code>ReferenceEquals</code> 来做空判断，造成最后<code>newGo</code>指向了已经销毁的 <code>g1</code>。</p>
<p>虽然大多数情况下，使用<code>operator ??</code>和<code>operator ?.</code> 也能得到正确的结果，但是最好避免使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面啰里啰嗦说了一大堆，其实主要想说的就四点：</p>
<ol>
<li>Destroy 是延迟销毁，销毁时机是当前帧更新结束，渲染开始之前；</li>
<li>除非变量显示设置为<code>null</code>，否则 <code>ReferenceEquals(obj,null)</code> 总是返回<code>false</code>;</li>
<li>C# 中的 <code>interface</code> 采用<code>ReferenceEquals</code> 进行比较，无论值类型还是引用类型；</li>
<li><code>MonoBehavior</code> 实现接口时，对于接口类型变量，避免使用 <code>interfaceTypeObj == null</code> 来判断是否销毁；</li>
</ol>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
  </entry>
  <entry>
    <title>C#与非托管DLL进行交互</title>
    <url>/2019/11/18/PInvokeInCsharp/</url>
    <content><![CDATA[<p>在做Unity开发时，经常会需要调用 C/C++ 编译的非托管库，包括目前常见的 Lua 库，比如 ToLua、XLua 都是通过 C 封装完接口，然后编译成各个平台的动态库，才能在Unity中进行使用，P/Invoke 是.Net 平台提供的非托管与托管通信的一种服务，通过它能够非常方便的完成非托管库的接入，当然这个过程中有很多需要注意的地方，希望通过阅读本文，能够少走一些弯路。</p>
<a id="more"></a>
<h2 id="PInvoke介绍"><a href="#PInvoke介绍" class="headerlink" title="PInvoke介绍"></a>PInvoke介绍</h2><p>PInvoke是.Net Framework提供的一项服务，它使得托管代码与非托管之间的交互变得非常简单，一般来说，只需要声名一个方法并指定<code>System.Runtime.InteropServicesDllImportAttribute</code>属性，就可以调用非托管方法。先看一个最简单的例子：  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入user32.dll中的一个函数</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">MessageBox</span>(<span class="params">IntPtr hWnd, String text, String caption, <span class="keyword">int</span> options</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 调用导入的非托管函数</span></span><br><span class="line">        MessageBox(IntPtr.Zero, <span class="string">"Command-line message box"</span>, <span class="string">"Attention!"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们分析以下上面的例子：</p>
<ul>
<li>首先引入<code>System.Runtime.InteropServices</code>，涉及本机交互的API多数都在此命名空间。</li>
<li>为方法指定<code>DllImport</code> 特性。 此特性至关重要，因为它告诉CLR要加载非托管 DLL，以及如何加载DLL。</li>
<li>定义了一个托管方法 MessageBox ，该方法的签名与非托管方法相匹配。 可以看到，声明中包含一个新关键字 <code>extern</code>，告诉运行时这是一个外部方法。调用该方法时，CLR在 DllImport 指定的 DLL 内查找该方法。  </li>
</ul>
<p>CLR通过PInvoke服务调用非托管函数：  </p>
<img src="/2019/11/18/PInvokeInCsharp/pinvoke.jpg">
<p>PInvoke调用非托管函数流程：</p>
<ol>
<li>定位包含非托管函数的DLL，并将DLL加载到内存当中。</li>
<li>定位非托管方法的地址。</li>
<li>参数传递以及函数返回值。</li>
</ol>
<blockquote>
<p>只有第一次调用非托管方法时，会定位和加载DLL</p>
</blockquote>
<h2 id="定位DLL存放地址"><a href="#定位DLL存放地址" class="headerlink" title="定位DLL存放地址"></a>定位DLL存放地址</h2><p>在指定库名称的时候，我们比较关心CLI内部如何去查找该库，这个过程是通过<code>LoadLibrary</code>来实现，不同的平台有不同的加载策略，对于Windows平台来说按照以下顺序进行查找：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, CharSet = CharSet.Auto, BestFitMapping = false, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">LoadLibrary</span>(<span class="params">String fileName</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)</span>]</span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, SetLastError = true)</span>]</span><br><span class="line">[<span class="meta">return: MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">FreeLibrary</span>(<span class="params">IntPtr hModule</span>)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>当前进程Exe文件所在目录。</li>
<li>当前目录，即<code>Environment.CurrentDirectory</code>。</li>
<li>Windows系统目录，一般是<code>C/Windows/System32</code>，可以通过<code>GetSystemDirectory(kernel32.dll)</code>或者<code>Environment.GetFolderPath(Environment.SpecialFolder.System)</code>函数获取此目录。</li>
<li>Windows 16位系统目录，一般是<code>C/Windows/System</code>。</li>
<li>Windows目录，可以通过<code>GetWindowsDirectory(kernel32.dll)</code>或者<code>Environment.GetEnvironmentVariable(&quot;windir&quot;)</code>函数获取此目录。</li>
<li><strong>PATH</strong>系统变量列出的目录中。</li>
</ol>
<p>知道要查找的目录之后，还需要知道动态库的名称，不同的平台对名称的处理策略不同。  </p>
<ul>
<li>Windows平台会对库名称附加<code>.dll</code>后缀。  </li>
<li>Linux会使用<code>lib</code>前缀和<code>.so</code>后缀。  </li>
<li>Mac OSX使用<code>lib</code>前缀和<code>dylib</code>后缀。</li>
</ul>
<p>根据这些规则，在使用DllImport时，我们不应该指定前缀或者后缀，而是只是用Dll名称，例如:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"MyLib"</span>, EntryPoint = <span class="meta-string">"CreateEvent"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateEvent</span>(<span class="params">IntPtr p, <span class="keyword">bool</span> mreset, <span class="keyword">bool</span> initstate, <span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们只需要为Windows平台提供MyLib.dll，Linux平台提供libMyLib.so，Mac OSX提供libMyLib.dylib文件，然后在不同的平台，CLI就能找到对应平台的库。  </p>
<p><strong>需要注意的是：如果提供的库名称中包含点号”.”，就不会附加后缀，例如”mylib-2.0.dll”如果指定”mylib-2.0”就不会附加后缀，从而引发DllNotFoundException。</strong></p>
<h2 id="定位非托管函数地址"><a href="#定位非托管函数地址" class="headerlink" title="定位非托管函数地址"></a>定位非托管函数地址</h2><p>在找到DLL之后，还需要找到函数在DLL的地址，该过程通过<code>GetProcAddress</code>来实现，该方法需要传递函数的名称，DllImport有两种方式可以获取函数名称，第一种通过EntryPoint指定；第二种是如果没有指定EntryPoint参数，则采用声名的托管函数名称。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GetProcAddress包含在Kernel32.dll中，导入方式如下：  </span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetProcAddress</span>(<span class="params">IntPtr hModule, String procName</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="DllImportAttribute其他参数介绍"><a href="#DllImportAttribute其他参数介绍" class="headerlink" title="DllImportAttribute其他参数介绍"></a>DllImportAttribute其他参数介绍</h2><p>在使用DllImport导入非托管函数时，除了上面说介绍过的Dll名称，<code>EntryPoint</code>之外，还有一些比较重要的参数，其中包括<code>CallingConvention</code>和<code>CharSet</code>。</p>
<ul>
<li>CallingConvention ：指定了传递方法参数时的约定，必须和非托管保持一致，在Windows平台下该值默认是WinAPI，对应非托管是<code>__stdcall</code>。</li>
<li>CharSet ：改参数指定了向非托管封送方法名(入口名称)和字符串参数的编码格式，默认值是Ansi，即按照ASCII进行编码，CharSet.Unicode按照UTF-16进行编码。</li>
<li>BestFitMapping ： 如果CharSet设置为CharSet.Ansi，封送处理器会采用近似匹配，将传递Unicode字符串映射到ASII编码，例如对于版权符号©会转换成字符’C’，对于没有映射的Unicode字符则转换成问号(?)，默认为True。</li>
<li>ThrowOnUnmappableChar ： 如果为True，当Unicode字符没有成功映射为ANSI字符时，会抛出异常，而非转换成问号“？”。</li>
</ul>
<h2 id="数据封送"><a href="#数据封送" class="headerlink" title="数据封送"></a>数据封送</h2><p>托管内存和非托管内存是完全分开的，所以两者如果需要进行数据传输，就需要一个“信使”-互操作封送拆装器（Interop Mashaler）来传递，它负责将托管参数传递给非托管，并将函数返回值传递给托管，在调用一个含参的非托管方法时，封送的过程大致如下：  </p>
<ol>
<li>CLR分配一块非托管内存。</li>
<li>将托管数据拷贝到刚分配的内存。</li>
<li>执行非托管方法，并将刚分配的非托管内存传递给函数。</li>
<li>将非托管内存拷贝回托管内存。</li>
</ol>
<p>数据封送按照数据的流动方向可以分为两类：</p>
<ul>
<li>参数传递时：托管内存—&gt;非托管内存</li>
<li>函数返回值：非托管内存—&gt;托管内存  </li>
</ul>
<p>无论数据如何传输，发送方的发送类型和接收方的接受类型，都必须具备相同的表示，即内存表示应该相同，例如：非托管函数形参为int类型，那么托管向该函数传递参数必须是32bit System.Int类型。</p>
<p>按照封送方式划分：</p>
<ul>
<li>按值封送  </li>
<li>按引用封送  </li>
</ul>
<h3 id="Blittable类型"><a href="#Blittable类型" class="headerlink" title="Blittable类型"></a>Blittable类型</h3><p>上面提到，封送的数据必须在发送方和接受方具备相同的表示，CLR大多数数据类型在托管和非托管内存中都有一个通用的表示，封送时不需要的特殊处理，这些类型被称为<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable</a>类型，因为它们在托管和非托管代码之间传递时不需要转换。而与Blittable类型相对的是Non-Blittable类型，封送拆装器必须做一些特殊处理才能封送Non-Blittable类型。</p>
<p>P/Invoke的返回值必须是Blittable类型，不支持Non-Blittable类型的返回值。</p>
<p>Blittable类型包括以下几种：</p>
<ul>
<li>byte</li>
<li>sbyte</li>
<li>short</li>
<li>ushort</li>
<li>int</li>
<li>uint</li>
<li>long</li>
<li>ulong</li>
<li>IntPtr</li>
<li>UIntPtr</li>
<li>float</li>
<li>double</li>
<li>上述类型的一维数组</li>
<li>只包含上述类型的结构体</li>
</ul>
<h3 id="内存复制与内存固定"><a href="#内存复制与内存固定" class="headerlink" title="内存复制与内存固定"></a>内存复制与内存固定</h3><p>封送数据时，互操作封送拆收器(interop    marshaler)可以复制或固定正在封送的数据。复制将数据副本从非托管/托管移动到托管/非托管；锁定是保持对象内存在垃圾回收时不会重定位，封送拆收器通过固定减小复制的开销来提高性能。要封送数据的类型决定了是采用复制还是固定<br>下图显示从托管内存向非托管内存复制值类型和复制按引用传递的类型之间的差异。  </p>
<img src="/2019/11/18/PInvokeInCsharp/stackvsheap.jpg">
<hr>
<p>如果函数参数时按值传递的，直接将数据内存拷贝到非托管栈上；如果函数参数是按引用传递的，则将引用对象的地址指针拷贝到非托管栈上。引用传递参数（ref标记）根据ref的类型选择按传值还是按引用传递。  </p>
<img src="/2019/11/18/PInvokeInCsharp/refheap.jpg">
<h3 id="封送字符串"><a href="#封送字符串" class="headerlink" title="封送字符串"></a>封送字符串</h3><p>什么时候回封送字符串：  </p>
<ul>
<li>调用GetProcAddress时，封送方法名。</li>
<li>调用非托管参数时，传递字符串类型参数。</li>
<li>封送的结构体/类中包含字符串成员。</li>
</ul>
<p>如何封送字符串? 有两种方式可以想非托管封送字符串：  </p>
<ul>
<li>System.String</li>
<li>System.Text.StringBuilder  </li>
</ul>
<p>两者的封送行为基本相同，封送拆装器会复制字符串，并将字符串转换为指定的编码格式，然后传输给非托管函数。两者非常重要区别在于string类型是不可变的，所以当调用结束时，不能将更改后的值复制回托管内存。<br>在封送时，可以使用MarshalAS()属性指定封送方式，见下表，其中StringBuilder只能允许<code>LPStr</code>、<code>LPWStr</code>、<code>LPTStr</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>封送方式</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>UnmanagedType.BStr</td>
<td>固定长度Unicode字符</td>
</tr>
<tr>
<td>UnmanagedType.AnsiBStr</td>
<td>固定长度的Ansi字符串</td>
</tr>
<tr>
<td>UnmanagedType.LPStr</td>
<td>指向以 null 终止的Ansi字符数组指针</td>
</tr>
<tr>
<td>UnmanagedType.LPWStr</td>
<td>指向以 null 终止的Unicode字符数组指针</td>
</tr>
<tr>
<td>UnmanagedType.LPTStr</td>
<td>指向以 null 终止的平台相关字符数组的指针</td>
</tr>
<tr>
<td>UnmanagedType.LPUTF8Str</td>
<td>指向UTF8编码的字符串的指针</td>
</tr>
<tr>
<td>UnmanagedType.ByValTStr</td>
<td>用于结构体内定长字符数组；数组的类型（Ansi、Unicode）由结构体的CharSet确定</td>
</tr>
</tbody>
</table>
</div>
<p>非托管定义：  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> StringInfoA</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">char</span> *    f1;  </span><br><span class="line">   <span class="keyword">char</span>      f2[<span class="number">256</span>];  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> StringInfoW</span><br><span class="line">&#123;  </span><br><span class="line">   WCHAR *   f1;  </span><br><span class="line">   WCHAR     f2[<span class="number">256</span>];  </span><br><span class="line">   BSTR      f3;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> StringInfoT</span><br><span class="line">&#123;  </span><br><span class="line">   TCHAR *   f1;  </span><br><span class="line">   TCHAR     f2[<span class="number">256</span>];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>托管Wrapper定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)</span>]  </span><br><span class="line"><span class="keyword">struct</span> StringInfoA</span><br><span class="line">&#123;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.LPStr)</span>] <span class="keyword">public</span> String f1;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.ByValTStr, SizeConst=256)</span>] <span class="keyword">public</span> String f2;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)</span>]  </span><br><span class="line"><span class="keyword">struct</span> StringInfoW</span><br><span class="line">&#123;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.LPWStr)</span>] <span class="keyword">public</span> String f1;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.ByValTStr, SizeConst=256)</span>] <span class="keyword">public</span> String f2;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.BStr)</span>] <span class="keyword">public</span> String f3;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)</span>]  </span><br><span class="line"><span class="keyword">struct</span> StringInfoT</span><br><span class="line">&#123;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.LPTStr)</span>] <span class="keyword">public</span> String f1;  </span><br><span class="line">   [<span class="meta">MarshalAs(UnmanagedType.ByValTStr, SizeConst=256)</span>] <span class="keyword">public</span> String f2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某些情况下，必须将定长字符缓冲区传递到要操作的非托管代码中。在这种情况下，只传递字符串将不起作用，因为被调用方不能修改所传递缓冲区的内容。 即使通过引用传递字符串，仍无法将缓冲区初始化为给定大小。  </p>
<p>解决方法是将 StringBuilder 作为参数而非字符串进行传递。被调用方可以修改 StringBuilder，前提是不超过 StringBuilder 的容量。还可以初始化为固定长度。例如，如果将 StringBuilder 缓冲区初始化为 N 容量，则封送处理程序提供大小为 (N+ 1) 个字符的缓冲区。 +1 是因为非托管字符串以 null 结尾，而 StringBuilder 却不不是，所以需要 +1 字节存放null终结符。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c函数声名：</span></span><br><span class="line"><span class="keyword">char</span>* strncpy (<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, size_t n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//托管函数声名：</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"libc.so"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">strncpy</span>(<span class="params">StringBuilder dest,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">string</span> src, <span class="keyword">uint</span> n</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseStrncpy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">    strncpy(sb, <span class="string">"this is the source string"</span>, sb.Capacity);</span><br><span class="line">    Console.WriteLine(sb.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="red">如果需要多次调用StringBuilder，在调用之前，需要调用EnsureCapacity，因为由于内存优化会造成Capacity可能缩小，从而造成不可预期的结果。</font>

<h3 id="封送System-Boolean"><a href="#封送System-Boolean" class="headerlink" title="封送System.Boolean"></a>封送System.Boolean</h3><p>System.Boolean是比较特殊的一个类型，当它作为类或者结构体的成员时，默认按UnmanagedType.Bool（int，0-false，非0-true）封送；当它作为函数的参数时，默认按UnmanagedType.VariantBool（short，0-false，1-true）封送。可以通过MarshaalAs显示指定封送行为，来替换默认的封送行为，可选参数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>封送行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>UnmanagedType.Bool</td>
<td>int,0-false,非0-true</td>
</tr>
<tr>
<td>UnmanagedType.VariantBool</td>
<td>short,0-false,1-true</td>
</tr>
<tr>
<td>UnmanagedType.U1</td>
<td>byte,0-false,1-true</td>
</tr>
</tbody>
</table>
</div>
<h3 id="封送类和结构体"><a href="#封送类和结构体" class="headerlink" title="封送类和结构体"></a>封送类和结构体</h3><p>类对象的内存是在托管堆上分配并由垃圾回收器进行管理，因此不能将类对象进行按值封送，只能按引用进行封送。此外在使用类封送时，还有以下几点需要注意：</p>
<ol>
<li>类默认的字段排序是按照 LayoutKind.Auto，这是一种不确定的排序方式，需要指定LayoutKind.Sequential 或者 LayoutKind.Exlict.</li>
<li>对于类类型，默认只能从托管内存拷贝到非托管内存，如果需要从非托管内存拷贝到托管内存，需要对参数指定 [Out] 特性，如果是需要双向进行拷贝，需要同时指定 [In] [Out] 特性</li>
</ol>
<p>与类不同，结构内存是分配在线程栈上，并且默认字段排序是LayoutKind.Sequential，因此结构体不用添加任何特性，就可以封送给非托管。另外如果结构体分配在线程栈上，并且结构成员只包含blittable类型，那么在封送时是固定的，可以直接封送给非托管，而不需要进行内存副本拷贝。一旦包含了Non-Blittable类型，该优化将不起作用。</p>
<h4 id="P-Invoke函数参数声明准则"><a href="#P-Invoke函数参数声明准则" class="headerlink" title="P/Invoke函数参数声明准则"></a>P/Invoke函数参数声明准则</h4><div class="table-container">
<table>
<thead>
<tr>
<th>非托管的签名</th>
<th>托管声明：非间接-struct MyType</th>
<th>托管声明：一级间接-class MyType</th>
</tr>
</thead>
<tbody>
<tr>
<td>DoWork(MyType x) 要求零级间接</td>
<td>DoWork(MyType x)</td>
<td>不可能实现，因为clas已经包含一级间接</td>
</tr>
<tr>
<td>DoWork(MyType* x) 要求一级间接</td>
<td>DoWork(ref MyType x)</td>
<td>DoWork(MyType x)</td>
</tr>
<tr>
<td>DoWork(MyType** x) 要求二级间接</td>
<td>不可能，因为不能出现ref ref</td>
<td>DoWork(ref MyType x)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="类和结构体作为返回值"><a href="#类和结构体作为返回值" class="headerlink" title="类和结构体作为返回值"></a>类和结构体作为返回值</h4><p>前面说过，P/Invoke的返回值只能是Blittable类型，所以类不能作为传值返回值，如果想要类作为返回值，非托管的返回值必须是指向结构体的指针。</p>
<p>结构体可以作为非托管的传值返回值，不能以传引用的方式返回结构体，如果需要返回结构体的引用，需要返回结构的指针（IntPtr），然后调用Marshal.PtrToStructure将IntPtr转换到结构体。</p>
<h3 id="封送数组"><a href="#封送数组" class="headerlink" title="封送数组"></a>封送数组</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#include &lt;windows.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef PINVOKELIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINVOKELIB_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINVOKELIB_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> COL_DIM = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> _MYPOINT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; MYPOINT;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> _MYPERSON</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* first;</span><br><span class="line">    <span class="keyword">char</span>* last;</span><br><span class="line">&#125; MYPERSON;</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestArrayOfInts</span>(<span class="params"><span class="keyword">int</span>* pArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestRefArrayOfInts</span>(<span class="params"><span class="keyword">int</span>** ppArray, <span class="keyword">int</span>* pSize</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestMatrixOfInts</span>(<span class="params"><span class="keyword">int</span> pMatrix[][COL_DIM], <span class="keyword">int</span> row</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestArrayOfStrings</span>(<span class="params"><span class="keyword">char</span>* ppStrArray[], <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestArrayOfStructs</span>(<span class="params">MYPOINT* pPointArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PINVOKELIB_API <span class="keyword">int</span> <span class="title">TestArrayOfStructs2</span>(<span class="params">MYPERSON* pPersonArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>托管导出方法：  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyPoint</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPoint</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyPerson</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String first;</span><br><span class="line">    <span class="keyword">public</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPerson</span>(<span class="params">String first, String last</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LibWrap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 按值封送int[]，不能改变数组的大小，通过添加Out属性，非托管内存会复制到托管内存</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestArrayOfInts</span>(<span class="params">[In, Out] <span class="keyword">int</span>[] array, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用封送int[]，非托管端可以改变数组的大小，但是改变后的内存不能返回给托管堆</span></span><br><span class="line">    <span class="comment">// 因为拆装器不知道改变后的数组大小，托管端可以返回的size大小和数组指针，手动进行获取改变后的值</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestRefArrayOfInts</span>(<span class="params"><span class="keyword">ref</span> IntPtr array, <span class="keyword">ref</span> <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值封送二维数组</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestMatrixOfInts</span>(<span class="params">[In, Out] <span class="keyword">int</span>[,] pMatrix, <span class="keyword">int</span> row</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值封送字符串数组</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestArrayOfStrings</span>(<span class="params">[In, Out] String[] stringArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封送结构体数组</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestArrayOfStructs</span>(<span class="params">[In, Out] MyPoint[] pointArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封送包含字符串的结构体数组</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">TestArrayOfStructs2</span>(<span class="params">[In, Out]MyPerson[] personArray, <span class="keyword">int</span> size</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 测试按值封送int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Console.WriteLine(<span class="string">"Integer array passed ByVal before call:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array1[i] = i;</span><br><span class="line">            Console.Write(<span class="string">" "</span> + array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum1 = LibWrap.TestArrayOfInts(array1, array1.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of elements:"</span> + sum1);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nInteger array passed ByVal after call:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> i <span class="keyword">in</span> array1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试按引用封送int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> size = array2.Length;</span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nInteger array passed ByRef before call:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            array2[i] = i;</span><br><span class="line">            Console.Write(<span class="string">" "</span> + array2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        IntPtr buffer = Marshal.AllocCoTaskMem(Marshal.SizeOf(size)</span><br><span class="line">           * array2.Length);</span><br><span class="line">        Marshal.Copy(array2, <span class="number">0</span>, buffer, array2.Length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum2 = LibWrap.TestRefArrayOfInts(<span class="keyword">ref</span> buffer, <span class="keyword">ref</span> size);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of elements:"</span> + sum2);</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arrayRes = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            Marshal.Copy(buffer, arrayRes, <span class="number">0</span>, size);</span><br><span class="line">            Marshal.FreeCoTaskMem(buffer);</span><br><span class="line">            Console.WriteLine(<span class="string">"\nInteger array passed ByRef after call:"</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">int</span> i <span class="keyword">in</span> arrayRes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">"\nArray after call is empty"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多维数组封送</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> DIM = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span>[,] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[DIM, DIM];</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nMatrix before call:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i, j] = j;</span><br><span class="line">                Console.Write(<span class="string">" "</span> + matrix[i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum3 = LibWrap.TestMatrixOfInts(matrix, DIM);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of elements:"</span> + sum3);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nMatrix after call:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">" "</span> + matrix[i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按值封送</span></span><br><span class="line">        String[] strArray = &#123; <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nString array before call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (String s <span class="keyword">in</span> strArray)</span><br><span class="line">            Console.Write(<span class="string">" "</span> + s);</span><br><span class="line">        <span class="keyword">int</span> lenSum = LibWrap.TestArrayOfStrings(strArray, strArray.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of string lengths:"</span> + lenSum);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nString array after call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (String s <span class="keyword">in</span> strArray)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">" "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按值封送结构体数组</span></span><br><span class="line">        MyPoint[] points = &#123; <span class="keyword">new</span> MyPoint(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> MyPoint(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> MyPoint(<span class="number">3</span>, <span class="number">3</span>) &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nPoints array before call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MyPoint p <span class="keyword">in</span> points)</span><br><span class="line">            Console.WriteLine(<span class="string">"x = &#123;0&#125;, y = &#123;1&#125;"</span>, p.x, p.y);</span><br><span class="line">        <span class="keyword">int</span> allSum = LibWrap.TestArrayOfStructs(points, points.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of points:"</span> + allSum);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nPoints array after call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MyPoint p <span class="keyword">in</span> points)</span><br><span class="line">            Console.WriteLine(<span class="string">"x = &#123;0&#125;, y = &#123;1&#125;"</span>, p.x, p.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按值封送结构体数组</span></span><br><span class="line">        MyPerson[] persons = &#123; <span class="keyword">new</span> MyPerson( <span class="string">"Kim"</span>, <span class="string">"Akers"</span> ),</span><br><span class="line">      <span class="keyword">new</span> MyPerson( <span class="string">"Adam"</span>, <span class="string">"Barr"</span> ), <span class="keyword">new</span> MyPerson( <span class="string">"Jo"</span>, <span class="string">"Brown"</span> )&#125;;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nPersons array before call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MyPerson pe <span class="keyword">in</span> persons)</span><br><span class="line">            Console.WriteLine(<span class="string">"first = &#123;0&#125;, last = &#123;1&#125;"</span>, pe.first, pe.last);</span><br><span class="line">        <span class="keyword">int</span> namesSum = LibWrap.TestArrayOfStructs2(persons, persons.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nSum of name lengths:"</span> + namesSum);</span><br><span class="line">        Console.WriteLine(<span class="string">"\n\nPersons array after call:"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MyPerson pe <span class="keyword">in</span> persons)</span><br><span class="line">            Console.WriteLine(<span class="string">"first = &#123;0&#125;, last = &#123;1&#125;"</span>, pe.first, pe.last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Integer array passed ByVal before call:</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">Sum of elements:<span class="number">45</span></span><br><span class="line"></span><br><span class="line">Integer array passed ByVal after call:</span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span> <span class="number">105</span> <span class="number">106</span> <span class="number">107</span> <span class="number">108</span> <span class="number">109</span>    <span class="comment">//可以看出，数组的值已经改变了，并且返回到了托管内存</span></span><br><span class="line"></span><br><span class="line">Integer array passed ByRef before call:</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">Sum of elements:<span class="number">45</span></span><br><span class="line"></span><br><span class="line">Integer array passed ByRef after call:</span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span>                        <span class="comment">//数组的值和大小都改变了</span></span><br><span class="line"></span><br><span class="line">Matrix before call:</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Sum of elements:<span class="number">50</span></span><br><span class="line"></span><br><span class="line">Matrix after call:</span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span></span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span></span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span></span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span></span><br><span class="line"> <span class="number">100</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span> <span class="number">104</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String array before call:</span><br><span class="line"> one two three four five</span><br><span class="line">Sum of <span class="keyword">string</span> lengths:<span class="number">19</span></span><br><span class="line"></span><br><span class="line">String array after call:</span><br><span class="line"> <span class="number">123456789</span> <span class="number">123456789</span> <span class="number">123456789</span> <span class="number">123456789</span> <span class="number">123456789</span></span><br><span class="line"></span><br><span class="line">Points array before call:</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">1</span></span><br><span class="line">x = <span class="number">2</span>, y = <span class="number">2</span></span><br><span class="line">x = <span class="number">3</span>, y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Sum of points:<span class="number">12</span></span><br><span class="line"></span><br><span class="line">Points array after call:</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span></span><br><span class="line">x = <span class="number">2</span>, y = <span class="number">0</span></span><br><span class="line">x = <span class="number">3</span>, y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Persons array before call:</span><br><span class="line">first = Kim, last = Akers</span><br><span class="line">first = Adam, last = Barr</span><br><span class="line">first = Jo, last = Brown</span><br><span class="line"></span><br><span class="line">Sum of name lengths:<span class="number">35</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Persons array after call:</span><br><span class="line">first = Kim, last = McAkers</span><br><span class="line">first = Adam, last = McBarr</span><br><span class="line">first = Jo, last = McBrown</span><br></pre></td></tr></table></figure>
<h3 id="封送委托"><a href="#封送委托" class="headerlink" title="封送委托"></a>封送委托</h3><p>当非托管参数时函数指针或者回调指针时，托管端需要向非托管封送委托数据。如果传递过去的回调函数，是在非托管调用内完成调用，CLR会避免对委托进行回收。<br>但是如果非托管函数将委托保存起来，等调用结束之后才调用，那么就需要手动防止对委托的垃圾回收，直到调用结束之后才能够回收。</p>
<hr>
<p>非托管定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">typedef <span class="title">bool</span> (<span class="params">CALLBACK *FPTR</span>)(<span class="params"><span class="keyword">int</span> i</span>)</span>;</span><br><span class="line"><span class="function">typedef <span class="title">bool</span> (<span class="params">CALLBACK *FPTR2</span>)(<span class="params"><span class="keyword">char</span>* str</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestCallBack</span>(<span class="params">FPTR pf, <span class="keyword">int</span> <span class="keyword">value</span></span>)；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestCallBack2</span>(<span class="params">FPTR2 pf2, <span class="keyword">char</span>* <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>托管声名：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">FPtr</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">FPtr2</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LibWrap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Declares managed prototypes for unmanaged functions.</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">TestCallBack</span>(<span class="params">FPtr cb, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"..\\LIB\\PinvokeLib.dll"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">TestCallBack2</span>(<span class="params">FPtr2 cb2, String <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>输出结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Received <span class="keyword">value</span>: <span class="number">99</span></span><br><span class="line">Passing to callback...</span><br><span class="line">Callback called with param: <span class="number">99</span></span><br><span class="line">Callback returned <span class="literal">true</span>.</span><br><span class="line"></span><br><span class="line">Received <span class="keyword">value</span>: abc</span><br><span class="line">Passing to callback...</span><br><span class="line">Callback called with param: abc</span><br><span class="line">Callback2 returned <span class="literal">true</span>.</span><br></pre></td></tr></table></figure>
<h2 id="非托管与GC"><a href="#非托管与GC" class="headerlink" title="非托管与GC"></a>非托管与GC</h2><p>CLR的垃圾回收器只是负责托管堆上的垃圾回收，对于非托管内存垃圾回收并不能进行正确回收，这就可能引起意想不到的问题，考虑下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 指向非托管物体的句柄</span></span><br><span class="line">   IntPtr _handle;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对h执行一些操作</span></span><br><span class="line">   [<span class="meta">DllImport (<span class="meta-string">"..."</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">OperateOnHandle</span> (<span class="params">IntPtr h</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放h资源</span></span><br><span class="line">   [<span class="meta">DllImport (<span class="meta-string">"..."</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DeleteHandle</span> (<span class="params">IntPtr h</span>)</span>;</span><br><span class="line"></span><br><span class="line">   ~C()</span><br><span class="line">   &#123;</span><br><span class="line">      DeleteHandle(_handle);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      OperateOnHandle(_handle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      C c = <span class="keyword">new</span> C();</span><br><span class="line">      c.m();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在Main中调用c.m()方法，方法调用完成之后，c不再存在引用，此时垃圾回收器可以对其进行回收，但是m（）中执行了非托管方法，非托管仍然引用着c的成员对象，这是GC不可能知道的。如果正在执行OperateOnHandle非托管函数的时候，c对象被垃圾回收器回收（虽然不太可能），同时DeleteHandle被垃圾回收线程调用，这样就会引发进程错误，可能导致程序崩溃。<br>如何解决这个问题，可以采用<a href="https://msdn.microsoft.com/zh-cn/library/system.runtime.interopservices.handleref(v=vs.100" target="_blank" rel="noopener">HandleRef</a>.aspx)类来替换IntPtr，来避免非托管函数完成前对托管对象进行垃圾回收。修改后的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 指向非托管物体的句柄</span></span><br><span class="line">   HandleRef _handle;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对h执行一些操作</span></span><br><span class="line">   [<span class="meta">DllImport (<span class="meta-string">"..."</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">OperateOnHandle</span> (<span class="params">HandleRef h</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放h资源</span></span><br><span class="line">   [<span class="meta">DllImport (<span class="meta-string">"..."</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DeleteHandle</span> (<span class="params">HandleRef h</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport (<span class="meta-string">"..."</span>)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateHandle</span> (<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">C</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       IntPtr h = CreateHandle();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//可以看到，HandleRef同时引用实例对象和一个指针对象</span></span><br><span class="line">       _handle = <span class="keyword">new</span> HandleRef(<span class="keyword">this</span>,h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~C()</span><br><span class="line">   &#123;</span><br><span class="line">      DeleteHandle(_handle);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      OperateOnHandle(_handle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="释放非托管资源"><a href="#释放非托管资源" class="headerlink" title="释放非托管资源"></a>释放非托管资源</h2><p>GC只能回收托管堆的资源，不能对非托管资源进行回收，因此对于非托管资源，需要进行手动回收，我们可以通过释放模式（即IDisposable接口）进行非托管内存的回收，下面是一种利用<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.safehandle?view=netframework-4.7.1" target="_blank" rel="noopener">SafeHandle</a>实现的释放模式，也是比较推荐的一种模式。  </p>
<p>CLR对SafeHandle做了一些特殊的处理，在进行封送的时候会自动处理SafeHandle，处理方式跟它出现的位置有关系：  </p>
<ul>
<li>作为传出参数时，SafeHandle.handle会被封送。</li>
<li>作为返回值时，会自动生成SafeHandle实例，并将返回的IntPtr赋值给SafeHandle.handle。</li>
<li>使用ref SafeHandle时，传出的值会被忽略（必须设置为IntPtr.Zero），返回值会被赋值过来。</li>
<li>作为结构体的成员函数，SafeHandle.handle会被封送。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WinAPI</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, CharSet = CharSet.Unicode, EntryPoint = <span class="meta-string">"CreateEvent"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateEvent</span>(<span class="params">IntPtr p, <span class="keyword">bool</span> mreset, <span class="keyword">bool</span> initstate, <span class="keyword">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, CharSet = CharSet.Unicode, EntryPoint = <span class="meta-string">"CreateEvent"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> SafeHandle <span class="title">CreateEventSafe</span>(<span class="params">IntPtr p, <span class="keyword">bool</span> mreset, <span class="keyword">bool</span> initstate, <span class="keyword">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, SetLastError = true)</span>]</span><br><span class="line">    [<span class="meta">return: MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">CloseHandle</span>(<span class="params">IntPtr hObject</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisposeBase</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用SafeHandle句柄控制非托管资源</span></span><br><span class="line">    <span class="keyword">private</span> SafeHandle nativeRes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisposeBase</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//示例：创建非托管资源</span></span><br><span class="line">        nativeRes = WinAPI.CreateEventSafe(IntPtr.Zero, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 释放方法，需要使用者手动调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻止GC调用终结器</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果使用IntPtr句柄引用非托管资源，则必须要实现终结期，避免用户没有显式调用Dispose方法，造成内存泄漏</span></span><br><span class="line">    <span class="comment">//由于本实例采用SafeHandle，SafeHandle内部实现了终结器，它会帮我们进行资源释放，所以这里就不需要终结器</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ~DisposeBase()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Dispose(true);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 资源释放逻辑</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="disposing"&gt;</span>true表示用户手动调用，false表示由GC调用<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//清理托管资源，或者其他实现了Dispose模式的非托管资源</span></span><br><span class="line">            nativeRes.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放非托管资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非托管数据类型与托管类型对应表"><a href="#非托管数据类型与托管类型对应表" class="headerlink" title="非托管数据类型与托管类型对应表"></a>非托管数据类型与托管类型对应表</h2><p>非托管类型与托管类型对应关系：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Wtypes.h 中的非托管类型</th>
<th>非托管 C 语言类型</th>
<th>托管类名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HANDLE</td>
<td>*void</td>
<td>System.IntPtr    在 32 位 Windows 操作系统上为 32 位、在 64 位 Windows 操作系统上为 64 位。</td>
</tr>
<tr>
<td>BYTE</td>
<td>unsigned char</td>
<td>System.Byte</td>
<td>8 位</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
<td>System.Int16</td>
<td>16 位</td>
</tr>
<tr>
<td>WORD</td>
<td>unsigned short</td>
<td>System.UInt16</td>
<td>16 位</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>System.Int32</td>
<td>32 位</td>
</tr>
<tr>
<td>UINT</td>
<td>unsigned int</td>
<td>System.UInt32</td>
<td>32 位</td>
</tr>
<tr>
<td>LONG</td>
<td>long</td>
<td>System.Int32</td>
<td>32 位</td>
</tr>
<tr>
<td>BOOL</td>
<td>long</td>
<td>Byte</td>
<td>32 位</td>
</tr>
<tr>
<td>DWORD</td>
<td>unsigned long</td>
<td>System.UInt32</td>
<td>32 位</td>
</tr>
<tr>
<td>ULONG</td>
<td>unsigned long</td>
<td>System.UInt32</td>
<td>32 位</td>
</tr>
<tr>
<td>CHAR</td>
<td>char</td>
<td>System.Char</td>
<td>使用 ANSI 修饰。</td>
</tr>
<tr>
<td>WCHAR</td>
<td>wchar_t</td>
<td>System.Char</td>
<td>使用 Unicode 修饰。</td>
</tr>
<tr>
<td>LPSTR</td>
<td>char\</td>
<td>System.String 或 System.Text.StringBuilder</td>
<td>使用 ANSI 修饰。</td>
</tr>
<tr>
<td>LPCSTR</td>
<td>Const char\</td>
<td>System.String 或 System.Text.StringBuilder</td>
<td>使用 ANSI 修饰。</td>
</tr>
<tr>
<td>LPWSTR</td>
<td>wchar_t*</td>
<td>System.String 或 System.Text.StringBuilder</td>
<td>使用 Unicode 修饰。</td>
</tr>
<tr>
<td>LPCWSTR</td>
<td>Const wchar_t*</td>
<td>System.String 或 System.Text.StringBuilder</td>
<td>使用 Unicode 修饰。</td>
</tr>
<tr>
<td>FLOAT</td>
<td>Float</td>
<td>System.Single</td>
<td>32 位</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度</td>
<td>System.Double</td>
<td>64 位</td>
</tr>
</tbody>
</table>
</div>
<font color="red" size="4">Tips: Win32Api的导入，可以在[pinvoke.net](https://www.pinvoke.net) 找到相应的实现，以及相应的使用示例。</font>

<blockquote>
<p>参考文章：<br><a href="http://www.mono-project.com/docs/advanced/pinvoke/" target="_blank" rel="noopener">Mono Doc</a><br><a href="https://msdn.microsoft.com/zh-cn/library/sd10k43k(v=vs.100" target="_blank" rel="noopener">MSDN</a>.aspx)</p>
</blockquote>
]]></content>
      <categories>
        <category>c#</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <url>/2019/11/14/TcpSynFin/</url>
    <content><![CDATA[<p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p>
<p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p>
<a id="more"></a>
<h2 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a>什么是“3次握手，4次挥手”</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p>
<h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p>
<p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p>
<p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有 N 之前的所有字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p>
<p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p>
<p>序列号<code>Seq</code>的作用是使得一个TCP接收端可丢弃重复的报文段，记录乱序到达的报文段的次序。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>
<h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><img src="/2019/11/14/TcpSynFin/tcphead.jpg">
<p>源端口(<code>Source Port</code>)和目的端口(<code>Destination Port</code>)在TCP层确定双方进程，序列号(<code>Sequence Number</code>)表示的是报文段数据中的第一个字节序号，ACK表示确认号(<code>Acknowledgement Number</code>)，该确认号的<strong>发送方</strong>期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p>
<p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，<font color="red">这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是</font>。</p>
<p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p>
<p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p>
<p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>三次握手和四次挥手的状态转换如下图。</p>
<img src="/2019/11/14/TcpSynFin/tcplife.jpg">
<h2 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>换个易于理解的视角来看为什么要3次握手。</p>
<p>客户端和服务端通信前要进行连接，<strong>“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的</strong>。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p>
<p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<h2 id="“三次握手，四次挥手”怎么完成"><a href="#“三次握手，四次挥手”怎么完成" class="headerlink" title="“三次握手，四次挥手”怎么完成"></a>“三次握手，四次挥手”怎么完成</h2><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p>
<p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p>
<h3 id="三次握手步骤"><a href="#三次握手步骤" class="headerlink" title="三次握手步骤"></a>三次握手步骤</h3><img src="/2019/11/14/TcpSynFin/tcpsyn.jpg">
<ol>
<li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li>
<li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li>
<li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li>
</ol>
<h3 id="四次挥手步骤"><a href="#四次挥手步骤" class="headerlink" title="四次挥手步骤"></a>四次挥手步骤</h3><img src="/2019/11/14/TcpSynFin/tcpfin.jpg">
<ol>
<li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据;</li>
<li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作;</li>
<li>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1。</li>
</ol>
<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
<h2 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h2><h3 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span><br></pre></td></tr></table></figure>
<p>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p>
<h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The next routines deal with comparing 32 bit unsigned ints</span></span><br><span class="line"><span class="comment">* and worry about wraparound (automatic with unsigned arithmetic).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure>
<p>上述代码是内核中的解决回绕问题代码。s32是有符号整型的意思，而u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p>
<h3 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h3><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p>
<p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p>
<p>常见的防攻击方法有：</p>
<h4 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h4><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
<h4 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h4><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p>
<h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p>
<h4 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h4><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p>
<h3 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h3><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p>
<img src="/2019/11/14/TcpSynFin/connqueue.jpg">
<p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看是否有连接溢出</span><br><span class="line">netstat -s | grep LISTEN</span><br></pre></td></tr></table></figure>
<h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<blockquote>
<p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p>
</blockquote>
<img src="/2019/11/14/TcpSynFin/halfconnfull.jpg">
<h4 id="全连接队列满"><a href="#全连接队列满" class="headerlink" title="全连接队列满"></a>全连接队列满</h4><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p>
<p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p>
<p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p>
<img src="/2019/11/14/TcpSynFin/connfull.jpg">
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -s命令</span><br><span class="line"></span><br><span class="line">[root@server ~]# netstat -s | egrep "listen|LISTEN" 667399 times the listen queue of a socket overflowed 667399 SYNs to LISTEN sockets ignored</span><br></pre></td></tr></table></figure>
<p>比如上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@server ~]# netstat -s | grep TCPBacklogDrop 查看 Accept queue 是否有溢出</span><br></pre></td></tr></table></figure>
<p>ss命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@server ~]# ss -lnt State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 :6379 : LISTEN 0 128 :22 :</span><br></pre></td></tr></table></figure>
<p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p>
<p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p>
<p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>
<h2 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a>“三次握手，四次挥手”redis实例分析</h2><ol>
<li>我在dev机器上部署redis服务，端口号为6379,</li>
<li>通过<code>tcpdump</code>工具获取数据包，使用如下命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -w /tmp/a.cap port 6379 -s0</span><br><span class="line">-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包</span><br></pre></td></tr></table></figure>
<ol>
<li>在dev2机器上用<code>redis-cli</code>访问dev:6379, 发送一个ping, 得到回复pong</li>
<li>停止抓包，用<code>tcpdump</code>读取捕获到的数据包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</span><br><span class="line">（-x 以16进制形式展示，便于后面分析）</span><br></pre></td></tr></table></figure>
<p>共收到了7个包。</p>
<p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p>
<p>IP的数据格式为：</p>
<img src="/2019/11/14/TcpSynFin/iphead.jpg">
<p>它由固定长度20字节+可变长度构成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10:55:45.662077 IP dev2.39070 &gt; dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000</span><br><span class="line">        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a</span><br><span class="line">        0x0030:  b062 e330 0000 0000 0103 0307</span><br></pre></td></tr></table></figure>
<p>对着IP头部格式，来拆解数据包的具体含义。</p>
<img src="/2019/11/14/TcpSynFin/ipheadcontent.jpg">
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<img src="/2019/11/14/TcpSynFin/tcpcontent.jpg">
<p>可变长度部分，协议如下：</p>
<img src="/2019/11/14/TcpSynFin/scalablecontent.jpg">
<p>这样第一个包分析完了。dev2向dev发送SYN请求。也就是三次握手中的第一次了。 SYN seq(c)=4133153791</p>
<p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1. SYN ack=seq(c)+1 seq(s)=4264776963</p>
<p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964. ack=seq(s)+1, seq=seq(c)+1 至此，三次握手完成。接下来就是发送ping和pong的数据了。</p>
<p>接着第四个包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10:55:48.090073 IP dev2.39070 &gt; dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14</span><br><span class="line">        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561</span><br><span class="line">        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504</span><br><span class="line">        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac</span><br><span class="line">        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67</span><br><span class="line">        0x0040:  0d0a</span><br></pre></td></tr></table></figure>
<p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792 ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x2a31         -&gt; *1</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x2434         -&gt; $4</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br><span class="line">0x7069 0x6e67  -&gt; ping</span><br><span class="line">0x0d0a         -&gt; \r\n</span><br></pre></td></tr></table></figure>
<p>dev2向dev发送了ping数据，第四个包完毕。</p>
<p>第五个包，dev2向dev发送ack响应。 序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p>
<p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B. 数据部分2b50 4f4e 470d 0a, 翻译过来就是+PONG\r\n.</p>
<p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p>
<p><strong>最后附上原文地址</strong>:<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">知乎</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo添加 Graphviz 插件</title>
    <url>/2019/11/10/AddGraphvicToHexo/</url>
    <content><![CDATA[<p>Graphviz 是 AT&amp;T 实验是开发一款开源的绘图工具，它通过绘图语言来进行绘图，这点和 Markdown 比较相似，通过和 Markdown 结合，使用起来非常流畅，Hexo 也提供了相关的插件来支持 Graphviz，本文主要介绍插件的安装，使用教程可以参考网上其他文章。</p>
<a id="more"></a>
<p>具体安装步骤如下：</p>
<h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>首先通过 <code>yarn</code> 安装插件：<code>yarn add hexo-graphviz</code>；</p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>我这里使用的 <code>next</code> 主题，所以配置文件是<code>themes/next/_config.yml</code>，然后添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-graphviz</span></span><br><span class="line"><span class="attr">graphviz:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="添加-swig-文件"><a href="#添加-swig-文件" class="headerlink" title="添加 swig 文件"></a>添加 swig 文件</h2><p>在主题中添加 <code>themes/next/layout/graphviz.swig</code> 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.graphviz.enable %&#125;</span><br><span class="line">  &lt;script src=&apos;https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.7.1/viz.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    String.prototype.replaceAll = function(search, replacement) &#123;</span><br><span class="line">      var target = this;</span><br><span class="line">      return target.split(search).join(replacement);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let vizObjects = document.querySelectorAll(&apos;.graphviz&apos;)</span><br><span class="line"></span><br><span class="line">    for (let item of vizObjects) &#123;</span><br><span class="line">      let svg = undefined</span><br><span class="line">      try &#123;</span><br><span class="line">        svg = Viz(item.textContent.replaceAll(&apos;–&apos;, &apos;--&apos;), &apos;svg&apos;)</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        svg = `&lt;pre class=&quot;error&quot;&gt;$&#123;e&#125;&lt;/pre&gt;`</span><br><span class="line">      &#125;</span><br><span class="line">      item.outerHTML = svg</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改主题-layout-文件"><a href="#修改主题-layout-文件" class="headerlink" title="修改主题 layout 文件"></a>修改主题 layout 文件</h2><p>找到主题的布局文件 <code>themes/next/layout/_layout.swig</code>，在 include 列表中，添加<code>graphviz.swig</code> 引用，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;_third-party/graphviz.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在-Markdown-中使用-Graphviz"><a href="#在-Markdown-中使用-Graphviz" class="headerlink" title="在 Markdown 中使用 Graphviz"></a>在 Markdown 中使用 Graphviz</h2><p>在文章中，可以通过 <code>```graphviz</code> 代码段来进行 Graphviz 绘图。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>在Unity中实现多屏输出</title>
    <url>/2019/11/04/EffectiveMultiDisplay/</url>
    <content><![CDATA[<p>最近同事在项目中遇到一个需求，要求将在两个显示器上显示同一个摄像机的内容，其实最简单的办法，就是在显示器设置中，将复制主屏的画面，对于更多的屏幕的输出，可以采用分屏器等硬件设备来实现，但是如果想对一个屏幕输出结果做一些处理，这种方法就么有办法解决了，实现的办法有很多种，本文主要介绍一种基于 RenderTexture 的方法。</p>
<a id="more"></a>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在了解需求的最开始，本来想通过两个 Camera 来分别对应两个显示器的输出，这种方法虽然能够解决问题，但是最大的缺点是，将会渲染两遍场景内物体，为了优化这一点，需要利用 RenderTexture 来实现，具体的实现思路如下：</p>
<ol>
<li>创建两个Camera，Camera_01 输出到 Display 1,Camera_02 输出到 Display_02;</li>
<li>为了避免 Display_02 重复渲染两遍，将其 CullMask 设置为 Nothing；</li>
<li>在 Camera_01 上，通过 OnRenderImage 回调，将渲染结果存储到 RenderTexture;</li>
<li>在 Camera_02 上，读取上面存储的 RenderTexture，拷贝到后缓冲中；</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>实现只有两部分，Camera_01 输出缓存，Camera_02 读取缓存并输出显示，先看Camera_01 实现缓存输出，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主屏缓存输出，将Camera 的渲染结果，拷贝到</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> RenderTexture 中，提供外部进行使用</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisplayOutput</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> RenderTexture _renderTexture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RenderTexture RenderTexture</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _renderTexture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_renderTexture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _renderTexture = <span class="keyword">new</span> RenderTexture(source.width,source.height,source.depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UnityEngine.Profiling.Profiler.BeginSample(<span class="string">"Copy Render Texture"</span>);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, _renderTexture);</span><br><span class="line">        Graphics.Blit(source, destination);</span><br><span class="line"></span><br><span class="line">        UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的主要功能就是将 Camera 的渲染结果拷贝到一个 RenderTexture 进行缓存，并将结果输出到当先屏幕，这里有一点需要注意，<code>Graphic.Blit(source,destination)</code> 必须在 <code>Graphic.Blit(source,_renderTexture)</code> 之后进行调用，否则编辑器会报警告： <code>OnRenderImage() possibly didn&#39;t write anything to the destination texture</code> ，这并不是 Unity 的 Bug，而就这样的设计的，用户手册中给出的解释如下：</p>
<blockquote>
<p>When OnRenderImage finishes, Unity expects that the destination render texture is the active render target. Generally, a Graphics.Blit or manual rendering into the destination texture should be the last rendering operation.</p>
</blockquote>
<p>好了，接着说上面的实现，在 RenderTexture 创建完成之后，就需要在 Camera_02 上输出显示，具体的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderTextureReceiver</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DisplayOutput input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span> || input.RenderTexture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(source, destination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!init)</span><br><span class="line">            &#123;</span><br><span class="line">                Camera srcCamera = input.GetComponent&lt;Camera&gt;();</span><br><span class="line">                Camera tarCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> display = tarCamera.targetDisplay;</span><br><span class="line"></span><br><span class="line">                tarCamera.CopyFrom(srcCamera);</span><br><span class="line">                tarCamera.cullingMask = <span class="number">0</span>;</span><br><span class="line">                tarCamera.clearFlags = CameraClearFlags.SolidColor;</span><br><span class="line">                tarCamera.targetDisplay = display;</span><br><span class="line"></span><br><span class="line">                init = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UnityEngine.Profiling.Profiler.BeginSample(<span class="string">"Set Render Texture"</span>);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(input.RenderTexture, destination);</span><br><span class="line"></span><br><span class="line">            UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过简单测试，这种方法的 CPU 实现占用低于 1ms（测试结果根硬件有很大差别，我的测试环境是 3.2GHZ i5 处理器，显卡是 AMD Radeon R9 M380），但是在其他硬件上相差应该不会太大。</p>
<p>这种方式的优点如下：</p>
<ul>
<li>实现简单高效；</li>
<li>其额外性能开销，与场景的复杂度无关；</li>
</ul>
<p>缺点是只能显示与主屏相同的结果，或者进行一些图像后处理，比如夜视、颜色调整等等，没有办法针对场景内单独的物体进行渲染调整。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
  </entry>
  <entry>
    <title>如何利用栈和循环替代递归</title>
    <url>/2019/11/01/ConvertRecursiveToInterator/</url>
    <content><![CDATA[<p>递归更加利于理解，因此某些情况下我们更喜欢使用递归（比如归并排序、或者树的操作），但是随着递归深度不断加深，就可能出现栈溢出，很多大神可能都已经知道如何通过堆栈和循环来避免栈溢出，但是，我觉得提供一种简单、通用的方法来替换递归，对于新手来说是非常棒的想法。</p>
<a id="more"></a>
<h2 id="递归和循环的优缺点"><a href="#递归和循环的优缺点" class="headerlink" title="递归和循环的优缺点"></a>递归和循环的优缺点</h2><p>递归：</p>
<ul>
<li>优点：便于阅读和理解算法；</li>
<li>缺点：可能引起栈溢出；</li>
</ul>
<p>循环：</p>
<ul>
<li>优点：能够避免栈溢出；效率通常要比递归更好一些；</li>
<li>缺点：不利于理解代码，不易维护；</li>
</ul>
<h2 id="替换递归的-10-个规则"><a href="#替换递归的-10-个规则" class="headerlink" title="替换递归的 10 个规则"></a>替换递归的 10 个规则</h2><p>下面介绍的几种规则，是针对通用的递归转换方法，而在实际的使用中，对于简单的递归来说，可能只需要其中一部分就可以解决问题，所以在阅读过程中，需要着重理解每个原则解决哪些问题。</p>
<h3 id="规则-01"><a href="#规则-01" class="headerlink" title="规则 01"></a>规则 01</h3><p> 递归和循环根本的差异在于，递归调用借助线程调用栈，来存储参数、局部变量等信息，因此转换时需要我们完成这部分工作，通过定义一个结构体<code>SnapShot</code>，来存储递归过程中的所有数据，以及阶段信息，总结结构体包括内容如下：</p>
<ul>
<li>当递归调用时值发生变化的参数，引用类型参数时不需要添加到结构体中，比如下面例子中，参数 <code>n</code> 需要添加，而引用类型 <code>retVal</code> 则不需要；</li>
<li>阶段标记（主要用来解决递归中的分支问题，后面会详细介绍）；</li>
<li>一些局部变量（递归调用返回后需要使用的局部变量）；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFunc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> test = SomeFunc(n<span class="number">-1</span>,retIdx);</span><br><span class="line">        test--;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"some content %d"</span>,retIdx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnapShot</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;          <span class="comment">// 输入参数</span></span><br><span class="line">    <span class="keyword">int</span> test;       <span class="comment">// 局部变量，在递归调用之后需要使用</span></span><br><span class="line">    <span class="keyword">int</span> stage;      <span class="comment">// 因为递归之后还有需要执行的代码，就需要对代码不同过程进行标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="comment">// （根据后续规则，不断进行完善）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-02"><a href="#规则-02" class="headerlink" title="规则 02"></a>规则 02</h3><p>在循环模拟方法最开始，创建一个局部变量，该变量用于存储递归调用的返回值。</p>
<ul>
<li>该值等同于递归中的返回值，如果需要用到返回值，直接使用该变量替代；</li>
<li>如果递归函数返回值是 void 类型，则不需要使用局部变量；</li>
<li>使用递归函数默认返回值，来初始化该局部变量；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-03"><a href="#规则-03" class="headerlink" title="规则 03"></a>规则 03</h3><p>创建一个<code>SnapShot</code>类型的堆栈，通过这个堆栈来模拟线程调用栈，继续上面的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;SnapShot&gt;  snapshotStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-04"><a href="#规则-04" class="headerlink" title="规则 04"></a>规则 04</h3><ol>
<li>创建一个<code>SnapShot</code>实例对象，并且根据循环的输入参数以及状态其实值，初始化该实例；</li>
<li>然后将该实例添加到创建的堆栈中。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;SnapShot&gt;  snapshotStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 4</span></span><br><span class="line">    SnapShot currentSnapStack;</span><br><span class="line">    currentSnapStack.n = n;</span><br><span class="line">    currentSnapStack.test = <span class="number">0</span>;</span><br><span class="line">    currentSnapStack.stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    snapshotStack.push(currentSnapStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-05"><a href="#规则-05" class="headerlink" title="规则 05"></a>规则 05</h3><ol>
<li>创建一个 <code>while</code> 循环，循环条件为 <code>snapshotStack</code> 不为空；</li>
<li>每次循环时，从 <code>snapshotStack</code> 取出栈顶元素。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;SnapShot&gt;  snapshotStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 4</span></span><br><span class="line">    SnapShot currentSnapStack;</span><br><span class="line">    currentSnapStack.n = n;</span><br><span class="line">    currentSnapStack.test = <span class="number">0</span>;</span><br><span class="line">    currentSnapStack.stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    snapshotStack.push(currentSnapStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 5</span></span><br><span class="line">    <span class="keyword">while</span>(!snapshotStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        currentSnapStack = snapshotStack.top();</span><br><span class="line">        snapshotStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-06"><a href="#规则-06" class="headerlink" title="规则 06"></a>规则 06</h3><p>前面提到过 <code>SnapShot</code> 结构中有一个 <code>stage</code> 变量，用来存储递归的各个阶段，那么如何划分阶段，每个阶段内容是什么，后续将会一一解释，下面这一规则说明了，如何对递归进行阶段划分。</p>
<ol>
<li>以递归调用为分界点，将整个过程分为两部分（针对只有一个递归调用的情况），第一部分为调用前，第二部分表示递归调用后的代码；</li>
<li>如果一个函数中有两个递归调用，则必须有三个阶段：<ol>
<li>第一阶段 -&gt; 递归调用 -&gt; (上次递归调用返回)第二阶段（第二次递归调用） -&gt; （第二次递归调用返回) -&gt; 第三阶段</li>
</ol>
</li>
<li>如果一个函数中有三个递归调用，则至少有四个阶段；</li>
<li>依次类推。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;SnapShot&gt;  snapshotStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 4</span></span><br><span class="line">    SnapShot currentSnapStack;</span><br><span class="line">    currentSnapStack.n = n;</span><br><span class="line">    currentSnapStack.test = <span class="number">0</span>;</span><br><span class="line">    currentSnapStack.stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    snapshotStack.push(currentSnapStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 5</span></span><br><span class="line">    <span class="keyword">while</span>(!snapshotStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        currentSnapStack = snapshotStack.top();</span><br><span class="line">        snapshotStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 规则 6</span></span><br><span class="line">        <span class="keyword">switch</span> (currentSnapStack.stage)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">            <span class="comment">// 阶段 1，SomeFunc(n-1,retIdx) 之前的内容 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 阶段 2，SomeFunc(n-1,retIdx) 之后的内容</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-07"><a href="#规则-07" class="headerlink" title="规则 07"></a>规则 07</h3><ol>
<li>在规则 6 中确定阶段划分之后，需要根据 <code>SnapShot.stage</code> 变量来决定进入哪个 <code>case</code>；</li>
<li>执行相关的阶段代码；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将递归转换为循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SomeFuncLoop</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;retIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;     <span class="comment">// 采用默认返回值来初始化变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 3</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;SnapShot&gt;  snapshotStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 4</span></span><br><span class="line">    SnapShot currentSnapStack;</span><br><span class="line">    currentSnapStack.n = n;</span><br><span class="line">    currentSnapStack.test = <span class="number">0</span>;</span><br><span class="line">    currentSnapStack.stage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    snapshotStack.push(currentSnapStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 5</span></span><br><span class="line">    <span class="keyword">while</span>(!snapshotStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        currentSnapStack = snapshotStack.top();</span><br><span class="line">        snapshotStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 规则 6</span></span><br><span class="line">        <span class="keyword">switch</span> (currentSnapStack.stage)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">            <span class="comment">// 阶段 1，SomeFunc(n-1,retIdx) 之前的内容 </span></span><br><span class="line">            <span class="comment">// 规则 7</span></span><br><span class="line">            <span class="keyword">if</span>(currentSnapStack.n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 阶段 2，SomeFunc(n-1,retIdx) 之后的内容</span></span><br><span class="line">            <span class="comment">// 规则 7</span></span><br><span class="line">            currentSnapStack.test = retVal;</span><br><span class="line">            currentSnapStack.test -- ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 2</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阶段 2 中我们给 test 进行了赋值，规则 1 中提到，凡是在递归调用之后，需要用到的局部变量，都需要记录到 <code>SnapShot</code> 中，因此这里需要记录到相应结构。<br>规则 2 中提到，凡是用到返回值的地方，都用声明的局部变量来替代，因此将 <code>retVal</code> 赋值给 test。</p>
</blockquote>
<h3 id="规则-08"><a href="#规则-08" class="headerlink" title="规则 08"></a>规则 08</h3><ol>
<li>如果递归调用存在返回值，将每次循环的结果，记录到之前声明的局部变量中，比如这里的<code>retVal</code>；</li>
<li>当<code>while</code>循环结束时，该局部变量存储着递归函数的最终结果；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (currentSnapStack.stage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">// 阶段 1，SomeFunc(n-1,retIdx) 之前的内容</span></span><br><span class="line">    <span class="comment">// 规则 7</span></span><br><span class="line">    <span class="keyword">if</span>(currentSnapStack.n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 8</span></span><br><span class="line">    retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 阶段 2，SomeFunc(n-1,retIdx) 之后的内容</span></span><br><span class="line">    <span class="comment">// 规则 7</span></span><br><span class="line">    currentSnapStack.test = retVal;</span><br><span class="line">    currentSnapStack.test -- ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 8</span></span><br><span class="line">    retVal = currentSnapStack.test;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-09"><a href="#规则-09" class="headerlink" title="规则 09"></a>规则 09</h3><p>如果递归函数中，包含关键字<code>return</code>，在循环中，需要将之转换为 <code>continue</code>：</p>
<ul>
<li>当递归中返回一个值时，首先根据规则 8,将返回值存储到临时变量（retVal)，然后调用 <code>continue</code>；</li>
<li>大多数情况下，规则 9 是可选的，但是为了避免逻辑错误，最好加上；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (currentSnapStack.stage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">    <span class="comment">// 阶段 1，SomeFunc(n-1,retIdx) 之前的内容 </span></span><br><span class="line">    <span class="comment">// 规则 7</span></span><br><span class="line">    <span class="keyword">if</span>(currentSnapStack.n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 8</span></span><br><span class="line">    retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 规则 9</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 阶段 2，SomeFunc(n-1,retIdx) 之后的内容</span></span><br><span class="line">    <span class="comment">// 规则 7</span></span><br><span class="line">    currentSnapStack.test = retVal;</span><br><span class="line">    currentSnapStack.test -- ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 8</span></span><br><span class="line">    retVal = currentSnapStack.test;</span><br><span class="line">    <span class="comment">// 规则 9</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-10"><a href="#规则-10" class="headerlink" title="规则 10"></a>规则 10</h3><ol>
<li>对于递归调用，需要再循环中，创建一个新的<code>Snapshot</code> 实例对象，初始化该对象的 <code>stage</code> 变量，以及输入参数、局部变量，然后将该实例添加到堆栈中，并且调用<code>continue</code>；</li>
<li>如果递归调用之后，还有代码需要执行，则需要将 <code>currentSnapStack.stage</code> 设置为相应阶段，并在新的<code>Snapshot</code> 实例添加到堆栈<strong>之前</strong>，添加到堆栈中；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶段 1，SomeFunc(n-1,retIdx) 之前的内容 </span></span><br><span class="line"><span class="comment">// 规则 7</span></span><br><span class="line"><span class="keyword">if</span>(currentSnapStack.n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 规则 10</span></span><br><span class="line">    currentSnapStack.stage = <span class="number">1</span>;             <span class="comment">// 因为有后续代码，因此需要将 currentSnapStack </span></span><br><span class="line">                                            <span class="comment">// 设置后添加到堆栈中</span></span><br><span class="line">    snapshotStack.push(currentSnapStack);   <span class="comment">// 必须在新的 Snapshot 对象添加之前</span></span><br><span class="line"></span><br><span class="line">    SnapShot newSnapshot;</span><br><span class="line">    newSnapshot.n = currentSnapStack.n - <span class="number">1</span>; <span class="comment">// 输入参数设置，就像调用递归时一样 SomeFunc(n-1,retIdx)</span></span><br><span class="line">    newSnapshot.test = <span class="number">0</span>;                   <span class="comment">// 根据函数默认值返回值，进行初始化</span></span><br><span class="line">    newSnapshot.stage = <span class="number">0</span>;                  <span class="comment">// 递归调用需要重新开始执行函数，因此 stage 设置为 0</span></span><br><span class="line"></span><br><span class="line">    snapshotStack.push(newSnapshot);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="各类递归示例"><a href="#各类递归示例" class="headerlink" title="各类递归示例"></a>各类递归示例</h2><p>示例代码<a href="https://www.codeproject.com/KB/cpp/418776/RecursiveToLoopSamples.zip" target="_blank" rel="noopener">地址</a></p>
<p>如果你看过这些源码，你会发现，里面包含递归和循环两个版本，其原因简单来说，循环版本是为了避免栈溢出，而递归版本则是为了阅读源码的人理解算法的意思。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我的观点是，当使用 C/C++ 或者 Java 时，必须非常小心的使用递归，避免栈的溢出异常，但是，在许多情况下，递归代码更容易理解，并且更加容易写出来，但缺点是容易造成栈溢出。所以，通过上述方法，将递归转换为循环，并不是为了提高代码可读性，也不是为了提高代码执行效率，而是通过一种简单的方式避免栈溢出。</p>
<p>如前面所说，我更倾向于保存递归和循环两个版本代码，递归版本给人阅读，循环版本给计算机阅读，当你了解了这两种方式的利弊之后，可以选择使用哪种方式编写代码。</p>
<p>最后附上英文原文地址:<a href="https://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and" target="_blank" rel="noopener">英文版</a></p>
<p>以及原作者的个人 GitHub 库，其中包含部分示例：<a href="https://github.com/juhgiyo/EpLibrary/tree/gh-pages/EpLibrary2.0/EpLibrary/Headers" target="_blank" rel="noopener">地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>UGUI 中实现多边形网格 Image</title>
    <url>/2019/10/28/UguiPolyImage/</url>
    <content><![CDATA[<p>这是<a href="https://blog.csdn.net/salvare/article/details/82724338" target="_blank" rel="noopener">之前</a>写的一篇关于 UGUI 优化的文章，换了博客平台之后，重新再发一遍，之前的文章也翻译过官方关于 Ugui 优化的一系列文章，总结其内容，可以将 ugui 的优化归结为以下三类：</p>
<ul>
<li>资源的优化</li>
<li>Drawcall 的优化</li>
<li>Overdraw 的优化</li>
<li>Rebuild 的优化</li>
</ul>
<a id="more"></a>
<p>资源的优化主要是图片的导入设置，以及图片的压缩格式选择，导入设置中重点注意两个选项：Read/Write Enable 和 Generate MipMaps，当开启 Read/Write 时，将占用<em>两倍</em>内存资源，关闭时将不能使用 Texture.GetPixel() 等函数来读取像素信息，如不需要请将该选项关闭，开启 Generate MipMaps 是增加 1.33被内存占用，对于 UI 资源来说，不需要开启此选项。</p>
<p>对于图片压缩格式，可以采用平台硬件支持的类型，Android 平台的 ETC 和 ETC2，需要注意的是前者不支持透明通道，需要分离 Alpha 通道；ETC2 是 OpenGL ES 3.0的一部分，则在某些低端机型上不支持，此时将会采用 RGBA32 格式（新版本可以通过 ETC2 Fallback 设置），另外 Android 平台默认采用 RGB(A) Compressed ETC2 格式。IOS 平台可选的有 ASTC 和 PVRTC，ASTC 的效果比较差，但是性能最好，如果美术可以接受的话，可以考虑使用，平台默认采用 RGB(A) Compressed PVRTC 2/4 Bits 格式。</p>
<p>Drawcall 的优化其实主要是图集打包策略的选择，以及合批处理，关于哪些情况会中断合批，前面的文章也详细地做了介绍，同时，Unity 的 Profiler 当前提供了 UI 模块，能够很清楚的知道哪个对象引起合批中断，中断原因，帮助我们很好的进行界面调优。</p>
<p>Rebuild 通常可能是 UGUI 优化的重灾区，每一次 Rebuild 都需要重新的生成合批的网格，造成 Rebuild 的原因有很多，之前的文章也介绍过，Rebuild 优化宗旨是，尽可能减少 Rebuild 次数，尽可能减少 Rebuild 影响范围，主要实施方案是：</p>
<ul>
<li>采用动静分离，对于动态 ui 元素，使用单独的 Canvas 进行渲染，</li>
<li>最好采用 TMP 文字来替代 UGUI 的文字渲染，</li>
</ul>
<p>造成 Overdraw 的原因前文也介绍过，因为 UGUI 生成的网格都是矩形，而 UI 的渲染是在半透明队列，所以多层 ui 的叠加是造成 overdraw 的主要原因，针对 Overdraw 的优化，主要总结三点：</p>
<ul>
<li>避免全透明 Image，有些时候为了接收 UI 某个事件而使用全透明 Image，虽然其不可见，但是仍然会进行一遍渲染；</li>
<li>对于 Sliced 类型，如果只需要渲染边框，避免勾选 FillCenter 选项（将不会生成中间部分网格）；</li>
<li>对于不规则图片，可以采用本文介绍的多边形组件；</li>
</ul>
<p>下面详细介绍多边形组件的实现方式，以下是之前原文：</p>
<p>在使用UGUI Image组件显示不规则图片、镂空图片时，Image总是会创建一个四边形网格来显示图形，渲染过程中，GPU需要对完全透明的区域进行计算，这不利于性能的优化，一个解决办法是采用多边形网格显示图形，来减少这种不必要的消耗。</p>
<p>下面是Image组件和多边形显示组件的网格对比</p>
<img src="/2019/10/28/UguiPolyImage/20180916143821616.jpeg">
<hr>
<p>下面是Image和多边形的Overdraw对比</p>
<img src="/2019/10/28/UguiPolyImage/20180916143941856.jpeg">
<p>整个方案的实现过程包括以下几个步骤：</p>
<ol>
<li>生成图集，这里推荐使用 <a href="https://www.codeandweb.com/texturepacker" target="_blank" rel="noopener">Texture Packer</a>,这里要求导出 <em>tpsheet</em> 格式。</li>
<li>导入图集、生成多边形，这里需要从AssetStore下载TexturePackerImporter（已经包含的项目中）。到导入插件之后，将 tpsheet 文件和图集一起导入项目中，导入之后TexturePackerImporter会自动将图集转换成带多边形的Sprite。</li>
<li>使用UIPolyImage组件替换 Image 组件。（该组件目前只支持 Simple 模式）</li>
</ol>
<p>如果需要根据图形做射线检测，在 UIPolyImage/Image 组件上添加PolyRaycastFilter 组件。因为该组件需要读取贴图的像素，所以需要将贴图的 readAndWrite 属性勾选。</p>
<p><strong>示例项目:<a href="https://github.com/huosk/UIPolyImage" target="_blank" rel="noopener">这里</a></strong></p>
<h2 id="多边形Image组件"><a href="#多边形Image组件" class="headerlink" title="多边形Image组件"></a>多边形Image组件</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPolyImage</span> : <span class="title">Image</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper vh</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (overrideSprite == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">base</span>.OnPopulateMesh(vh);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Type.Simple:</span><br><span class="line">                <span class="keyword">case</span> Type.Filled:</span><br><span class="line">                <span class="keyword">case</span> Type.Sliced:</span><br><span class="line">                <span class="keyword">case</span> Type.Tiled:</span><br><span class="line">                    GenerateSimpleSprite(vh, preserveAspect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GenerateSimpleSprite</span>(<span class="params">VertexHelper vh, <span class="keyword">bool</span> lPreserveAspect</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Vector4 v = GetDrawingDimensions(lPreserveAspect);</span><br><span class="line">            <span class="keyword">var</span> color32 = color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> width = v.z - v.x;</span><br><span class="line">            <span class="keyword">float</span> height = v.w - v.y;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将sprite.pivot进行归一化</span></span><br><span class="line">            Vector2 spritePivot = <span class="keyword">new</span> Vector2(sprite.pivot.x / sprite.rect.width, sprite.pivot.y / sprite.rect.height);</span><br><span class="line">            Vector2 pivotOffset = Vector2.Scale(spritePivot - rectTransform.pivot, <span class="keyword">new</span> Vector2(width, height));</span><br><span class="line"></span><br><span class="line">            Vector3 scale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            scale.x = width / sprite.bounds.size.x;</span><br><span class="line">            scale.y = height / sprite.bounds.size.y;</span><br><span class="line">            Matrix4x4 trsMT = Matrix4x4.TRS(pivotOffset, Quaternion.identity, scale);</span><br><span class="line"></span><br><span class="line">            vh.Clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sprite.vertices.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vh.AddVert(trsMT.MultiplyPoint3x4(sprite.vertices[i]), color32, sprite.uv[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sprite.triangles.Length; i += <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vh.AddTriangle(sprite.triangles[i], sprite.triangles[i + <span class="number">1</span>], sprite.triangles[i + <span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Rect <span class="title">GetDrawingRect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Vector4 v = GetDrawingDimensions(preserveAspect);</span><br><span class="line">            <span class="keyword">return</span> Rect.MinMaxRect(v.x, v.y, v.z, v.w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Image's dimensions used for drawing. X = left, Y = bottom, Z = right, W = top.</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Vector4 <span class="title">GetDrawingDimensions</span>(<span class="params"><span class="keyword">bool</span> shouldPreserveAspect</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> padding = overrideSprite == <span class="literal">null</span> ? Vector4.zero : UnityEngine.Sprites.DataUtility.GetPadding(overrideSprite);</span><br><span class="line">            <span class="keyword">var</span> size = overrideSprite == <span class="literal">null</span> ? Vector2.zero : <span class="keyword">new</span> Vector2(overrideSprite.rect.width, overrideSprite.rect.height);</span><br><span class="line"></span><br><span class="line">            Rect r = GetPixelAdjustedRect();</span><br><span class="line">            <span class="comment">// Debug.Log(string.Format("r:&#123;2&#125;, size:&#123;0&#125;, padding:&#123;1&#125;", size, padding, r));</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> spriteW = Mathf.RoundToInt(size.x);</span><br><span class="line">            <span class="keyword">int</span> spriteH = Mathf.RoundToInt(size.y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> v = <span class="keyword">new</span> Vector4(</span><br><span class="line">                    padding.x / spriteW,</span><br><span class="line">                    padding.y / spriteH,</span><br><span class="line">                    (spriteW - padding.z) / spriteW,</span><br><span class="line">                    (spriteH - padding.w) / spriteH);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> spriteRatio = size.x / size.y;</span><br><span class="line">                <span class="keyword">var</span> rectRatio = r.width / r.height;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (spriteRatio &gt; rectRatio)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> oldHeight = r.height;</span><br><span class="line">                    r.height = r.width * (<span class="number">1.0f</span> / spriteRatio);</span><br><span class="line">                    r.y += (oldHeight - r.height) * rectTransform.pivot.y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> oldWidth = r.width;</span><br><span class="line">                    r.width = r.height * spriteRatio;</span><br><span class="line">                    r.x += (oldWidth - r.width) * rectTransform.pivot.x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v = <span class="keyword">new</span> Vector4(</span><br><span class="line">                    r.x + r.width * v.x,</span><br><span class="line">                    r.y + r.height * v.y,</span><br><span class="line">                    r.x + r.width * v.z,</span><br><span class="line">                    r.y + r.height * v.w</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="射线检测过滤组件"><a href="#射线检测过滤组件" class="headerlink" title="射线检测过滤组件"></a>射线检测过滤组件</h3><p>这里实现方式是通过获取像素的 Alpha 值来进行判断的，所以一个明显的缺点就是需要将贴图的 Read/Write 设置为true，造成图片资源内存占用翻倍。当然还有一些其他的方法也可以实现功能，比如设置多边形碰撞、多边形检测等等，后续如果有机会的话，会补充其他的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于检测不规则图形的射线检测方法，由于需要进行多边形的射线检测，</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 效率相对较低，所以，确认自己必须进行不规则射线检测时，才使用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该组件。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">RequireComponent(typeof(UIPolyImage))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolyRaycastFilter</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanvasRaycastFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> UIPolyImage image</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_Image == <span class="literal">null</span>)</span><br><span class="line">                    m_Image = GetComponent&lt;UIPolyImage&gt;();</span><br><span class="line">                <span class="keyword">return</span> m_Image;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RectTransform rectTransform</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_RectTransform == <span class="literal">null</span>)</span><br><span class="line">                    m_RectTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">                <span class="keyword">return</span> m_RectTransform;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> UIPolyImage m_Image;</span><br><span class="line">        <span class="keyword">private</span> RectTransform m_RectTransform;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (image.sprite == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//首先转换到本地坐标系中，方便下面的计算</span></span><br><span class="line">            Vector2 localP = rectTransform.InverseTransformPoint(sp);</span><br><span class="line"></span><br><span class="line">            Rect pixelRect = image.GetDrawingRect();</span><br><span class="line">            <span class="keyword">if</span> (!pixelRect.Contains(localP, <span class="literal">false</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            Vector2 delta = localP - pixelRect.min;</span><br><span class="line">            Vector2 normalizedDelta = <span class="keyword">new</span> Vector2(delta.x / pixelRect.width, delta.y / pixelRect.height);</span><br><span class="line">            <span class="keyword">int</span> x = Mathf.CeilToInt(normalizedDelta.x * image.sprite.rect.width+image.sprite.rect.xMin);</span><br><span class="line">            <span class="keyword">int</span> y = Mathf.CeilToInt(normalizedDelta.y * image.sprite.rect.height+image.sprite.rect.yMin);</span><br><span class="line"></span><br><span class="line">            Color pixel = image.sprite.texture.GetPixel(x, y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> !Mathf.Approximately(pixel.a, <span class="number">0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于多边形检测"><a href="#基于多边形检测" class="headerlink" title="基于多边形检测"></a>基于多边形检测</h4><p>判断某点是否在多边形内，通常采用的方法有交点法、回转数法，本文采用的是交点法来计算，具体原理网上有更详细的文章来介绍，这里直接上代码，工程源码里对应<code>PolyMeshRaycastFilter.cs</code> 文件。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(UIPolyImage))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolyMeshRaycastFilter</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanvasRaycastFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIPolyImage image</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_Image == <span class="literal">null</span>)</span><br><span class="line">                m_Image = GetComponent&lt;UIPolyImage&gt;();</span><br><span class="line">            <span class="keyword">return</span> m_Image;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RectTransform rectTransform</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_RectTransform == <span class="literal">null</span>)</span><br><span class="line">                m_RectTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">            <span class="keyword">return</span> m_RectTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UIPolyImage m_Image;</span><br><span class="line">    <span class="keyword">private</span> RectTransform m_RectTransform;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detail: http://alienryderflex.com/polygon/</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPointInPoly</span>(<span class="params">List&lt;Vector2&gt; verts, Vector2 point</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j = verts.Count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> oddNodes = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">float</span> x = point.x;</span><br><span class="line">        <span class="keyword">float</span> y = point.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; verts.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((verts[i].y &lt; y &amp;&amp; verts[j].y &gt;= y || verts[j].y &lt; y &amp;&amp; verts[i].y &gt;= y) &amp;&amp;</span><br><span class="line">                (verts[i].x &lt;= x || verts[j].x &lt;= x))</span><br><span class="line">            &#123;</span><br><span class="line">                oddNodes ^= (verts[i].x + (y - verts[i].y) / (verts[j].y - verts[i].y) * (verts[j].x - verts[i].x) &lt; x);</span><br><span class="line">            &#125;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oddNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (image == <span class="literal">null</span> || image.poly == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Vector2 localP = rectTransform.InverseTransformPoint(sp);</span><br><span class="line">        <span class="keyword">if</span> (!image.meshBounds.Contains(localP))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IsPointInPoly(image.poly, localP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于-PolygonCollider2D-检测"><a href="#基于-PolygonCollider2D-检测" class="headerlink" title="基于 PolygonCollider2D 检测"></a>基于 PolygonCollider2D 检测</h4><p>这种方法是采用 Unity 的 2D 多边形碰撞体 PolygonCollider2D，其提供了相应的检测方法，对应工程的 <code>PolyColliderRaycastFilter.cs</code> 文件，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 基于 PolygonCollider2D 组件的射线检测，系统提供的 Physics2DRaycaster 虽然也能</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 实现类似功能，但是会需要多个 Raycaster 来实现。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(PolygonCollider2D))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolyColliderRaycastFilter</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanvasRaycastFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    PolygonCollider2D polyCollider</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_PolyCollider == <span class="literal">null</span>)</span><br><span class="line">                m_PolyCollider = GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">            <span class="keyword">return</span> m_PolyCollider;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RectTransform rectTransform</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_RectTransform == <span class="literal">null</span>)</span><br><span class="line">                m_RectTransform = transform <span class="keyword">as</span> RectTransform;</span><br><span class="line">            <span class="keyword">return</span> m_RectTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PolygonCollider2D m_PolyCollider;</span><br><span class="line">    <span class="keyword">private</span> RectTransform m_RectTransform;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (polyCollider == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventCamera != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sp不包含 z坐标值，所以需要单独计算z值</span></span><br><span class="line">            <span class="keyword">float</span> zDistance2Cam = rectTransform.position.z - eventCamera.transform.position.z;</span><br><span class="line">            Vector3 sp3 = <span class="keyword">new</span> Vector3(sp.x, sp.y, zDistance2Cam);</span><br><span class="line">            <span class="keyword">return</span> polyCollider.OverlapPoint(eventCamera.ScreenToWorldPoint(sp3));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Overlay 模式下，屏幕坐标xy = 世界坐标xy，z = 0</span></span><br><span class="line">            <span class="keyword">return</span> polyCollider.OverlapPoint(sp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了优化 Overdraw 的一种方法，如果在项目中遇上 Overdraw 严重的情况，可以考虑采用这种方法，后续有时间再介绍 ugui 的其他优化内容。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - AC 自动机</title>
    <url>/2019/05/18/Algorithm18-AhoCorasick/</url>
    <content><![CDATA[<p>前面已经介绍了暴力匹配算法、BM 算法、KMP 算法等几种单模式字符串匹配算法，在实际项目开发中，也经常会遇到多模式匹配需求，比如敏感词过滤功能，虽然使用单模式匹配算法也能够实现，但是下面介绍一种更加高效多模式匹配算法 - AC 自动机。</p>
<a id="more"></a>
<h2 id="多模式匹配-暴力匹配"><a href="#多模式匹配-暴力匹配" class="headerlink" title="多模式匹配 - 暴力匹配"></a>多模式匹配 - 暴力匹配</h2><p>在介绍 AC 自动机算法实现之前，先看看使用暴力匹配算法如何实现多模式匹配，可以遍历所有模式串，逐一进行暴力匹配，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; Match(<span class="keyword">string</span>[] word, <span class="keyword">string</span> text)</span><br><span class="line">&#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; matched = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> M = text.Length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> pattern = word[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!matched.ContainsKey(pattern))</span><br><span class="line">            matched.Add(pattern, <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = pattern.Length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M - N + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pattern[k] != text[j+k])</span><br><span class="line">                &#123;</span><br><span class="line">                    isMatch = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isMatch)</span><br><span class="line">            &#123;</span><br><span class="line">                matched[pattern].Add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面算法的时间复杂度为 <code>O(KMN)</code> 其中，K 为模式串的个数，M 为主串长度，N 为模式串平均长度。</p>
<p>用暴力匹配法解决多模式匹配很容易理解和实现，其时间复杂度为 <code>O(MNK)，其中 M 为主串长度、N 为模式串平均长度、K 为模式串数量，</code>下面看下如何进行改进呢，和 KMP 算法、BM 算法一样，目的都是希望减少字符比较次数，能够尽可能多的向后滑动，可能产生影响的，主要包括以下两点：</p>
<ul>
<li>已匹配字符串内容；</li>
<li>各个模式串之间的内容有关系。</li>
</ul>
<p>第一种情况之前算法中都已经介绍过了，第二种情况只针对多模式匹配，比如两个模式串 <code>abc</code> 和 <code>bc</code>，当 <code>bc</code> 不匹配时，<code>abc</code> 肯定也不匹配，因此就不需要再次进行比较了。</p>
<p>在清楚了问题所在之后，再来看如何解决这两个问题，第一问题可以采用 KMP 和 BM 算法来解决，重点关注如何解决第二个问题，上面算法实现中，我们采用字符串数组来存储所有的模式串，模式串之间都是独立存储，不能直接获取各个模式串之间的关系，所以首先需要解决模式串的存储问题，这里采用 <a href="https://huosk.github.io/2019/04/22/Algorithm16-Trie/">Trie 单词树</a>，不同的是，每个结点增加了一个失效指针。</p>
<h2 id="构建单词树"><a href="#构建单词树" class="headerlink" title="构建单词树"></a>构建单词树</h2><p>在之前<a href="https://huosk.github.io/2019/04/22/Algorithm16-Trie/">文章</a>中已经详细的介绍了单词树的构造过程，所以这里就不再介绍，只关注失效指针的计算，下面直接给出 AC 自动机的代码框架和单词树的构建过程，后面再详细介绍各部分的实现原理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ACNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">char</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">public</span> Dictionary&lt;<span class="keyword">char</span>, ACNode&gt; children = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, ACNode&gt;();;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失效指针</span></span><br><span class="line">        <span class="keyword">public</span> ACNode next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以该节点结尾的单词</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ACNode tree = <span class="keyword">new</span> ACNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AC</span>(<span class="params"><span class="keyword">string</span>[] patterns</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (patterns != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; patterns.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Put(patterns[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            BuildFailurePointer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向字典树中插入模式串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Put</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ACNode node = tree;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx != pattern.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 查找是否存在对应的子结点</span></span><br><span class="line">            <span class="keyword">if</span>(!node.children.ContainsKey(pattern[idx]))</span><br><span class="line">            &#123;</span><br><span class="line">                node.children.Add(pattern[idx], <span class="keyword">new</span> ACNode()</span><br><span class="line">                &#123;</span><br><span class="line">                    key = pattern[idx]</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 继续进行插入</span></span><br><span class="line">            node = node.children[pattern[idx++]];</span><br><span class="line">        &#125;</span><br><span class="line">        node.word = pattern;</span><br><span class="line">        node.<span class="keyword">value</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建失效指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildFailurePointer</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AC 自动机匹配</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>,List&lt;<span class="keyword">int</span>&gt;&gt; Match(<span class="keyword">string</span> text)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="失效指针"><a href="#失效指针" class="headerlink" title="失效指针"></a>失效指针</h2><p>在 <a href="https://huosk.github.io/2019/05/06/Algorithm17-KMP/">KMP 算法</a>中介绍过 KMP 失效指针的计算，其实 AC 自动机的失效指针和 KMP 是一样的，可以将 KMP 看做只有一个模式串的 AC 自动机。</p>
<p>在 AC 算法中，对于任一节点 <code>A</code>，从根节点到 <code>A</code> 的字符串为 <code>str</code>，<code>A</code> 的失效指针指向，与 <code>str</code> 所有后缀最长匹配的，所有模式串的前缀节点。</p>
<img src="/2019/05/18/Algorithm18-AhoCorasick/FailurePoint.png">
<p>首先需要说明的是，所有结点的失效指针默认都指向根节点。</p>
<p>看上图中的 ‘acd’ 这条线，其后缀包括’d’、‘cd’，而在所有模式串中，与之匹配的最长的后缀为 ‘cd’，因此其失效指针指向 ‘cd’ 的 ‘d’ 结点。</p>
<h3 id="计算失效指针"><a href="#计算失效指针" class="headerlink" title="计算失效指针"></a>计算失效指针</h3><p>上面说了，可以将 KMP 看做是只有一个模式串的 AC 自动机，失效指针的计算也是基本相同的，唯一不同的在于，KMP 只需在单个模式串中计算，而 AC 则需要计算所有模式串，所以这里就不再介绍失效指针的原理，直接给出失效指针计算过程，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建失效指针</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildFailurePointer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用队列，广度优先遍历单词树</span></span><br><span class="line">    Queue&lt;ACNode&gt; queue = <span class="keyword">new</span> Queue&lt;ACNode&gt;();</span><br><span class="line"></span><br><span class="line">    tree.next = <span class="literal">null</span>;</span><br><span class="line">    queue.Enqueue(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ACNode p = queue.Dequeue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子结点</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> p.children)</span><br><span class="line">        &#123;</span><br><span class="line">            ACNode child = kvp.Value;</span><br><span class="line">            <span class="keyword">if</span> (p == tree)</span><br><span class="line">            &#123;</span><br><span class="line">                child.next = tree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ACNode pFail = p.next;</span><br><span class="line">                <span class="keyword">while</span>(pFail != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pFail.children.ContainsKey(child.key))</span><br><span class="line">                    &#123;</span><br><span class="line">                        child.next = pFail.children[child.key];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pFail = pFail.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(pFail == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    child.next = tree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.Enqueue(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配实现"><a href="#匹配实现" class="headerlink" title="匹配实现"></a>匹配实现</h2><p>在了解了失效指针的构建过程之后，下面再看如何利用失效指针进行匹配，过程如下：</p>
<p>令 P 指向当前检查的指针，S 为主串，i 为主串字符指针。</p>
<ol>
<li>从树的根节点开始检查，即 P = root，从主串第一个字符开始，即 i = 0；</li>
<li>从主串读取字符 s[i]；</li>
<li>遍历 P.children，是否存在于 s[i] 匹配的结点：<ul>
<li>若存在，将 P 指向该子结点，即 P = P.children[x]，继续：<ul>
<li>判断 P 是否表示单词结尾，若是，说明找到一个匹配的模式串，记录下来；</li>
<li>判断 P 的失效指针是否指向一个单词结尾，若是，说明同样是匹配的模式串，记录下来；</li>
<li>开始检查下一个字符，即 i++，执行步骤 2.</li>
</ul>
</li>
<li>若不存在，检查 P 是否为根结点：<ul>
<li>若是，i++，执行步骤 2；</li>
<li>若不是，令 P 指向该结点的失效指针，继续步骤 3.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>针对上面过程补充两点：</p>
<ul>
<li>找到匹配模式串，记录数据时，需要记录模式串在主串中的索引，该值等于 <code>i - word.length + 1</code>；</li>
<li>当 P 子结点与字符<code>s[i]</code>不匹配，并且 P 为根节点时，说明模式串中，没有以字符<code>s[i]</code>开头的模式串，因此直接跳过。</li>
</ul>
<p>将上述过程转换成代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AC 自动机匹配</span></span><br><span class="line"><span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; Match(<span class="keyword">string</span> text)</span><br><span class="line">&#123;</span><br><span class="line">   Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt; r = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">   ACNode p = tree;</span><br><span class="line">   <span class="keyword">int</span> M = text.Length;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; M)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">char</span> ch = text[i];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (p.children.ContainsKey(ch))</span><br><span class="line">       &#123;</span><br><span class="line">           p = p.children[ch];</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (p.word != <span class="literal">null</span>)</span><br><span class="line">           &#123;<span class="comment">// 说明 P 结点为单词结尾</span></span><br><span class="line">               <span class="keyword">if</span> (!r.ContainsKey(p.word))</span><br><span class="line">                   r.Add(p.word, <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">               r[p.word].Add(i - p.word.Length + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next.word != <span class="literal">null</span>)</span><br><span class="line">           &#123;<span class="comment">// 说明 p 的失效指针也是单词结尾</span></span><br><span class="line">               <span class="keyword">if</span> (!r.ContainsKey(p.next.word))</span><br><span class="line">                   r.Add(p.next.word, <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">               r[p.next.word].Add(i - p.next.word.Length + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 继续处理下一个字符</span></span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (p != tree)</span><br><span class="line">           &#123;</span><br><span class="line">               p = p.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，多模式串匹配已经介绍完毕，还是看一下 AC 自动机的时间复杂度，其包括三部分：构造单词树、构造失效指针、字符串匹配，前两部分只在构造时执行一次，因此并不影响匹配时的效率，下面看下各部分的时间复杂度：</p>
<ul>
<li>构造单词树，这里和 trie 树一样为：<code>O(KL)</code> 其中 K 为单词的平均长度，L 为单词个数；</li>
<li>构造失效指针，上限为：<code>O(KN)</code> 其中 K 为单词平均长度，N 为节点个数；</li>
<li>匹配算法，影响外层循环次数的不确定因素为失效指针的跳转次数，这里按单词平均长度来计算，因此复杂度为 <code>O(KM)</code>，其中 K 为单词平均长度，M 为主串长度。</li>
</ul>
<p>那么考虑一个问题，AC 是否一定比单模式匹配快？从时间复杂度来比较，这一点是肯定的，但是在特定的使用场景中，这个问题就不是那么容易回答了，从 AC 算法中可以发现，其优化核心是失效指针的跳转，而失效指针建立的前提是，模式串的后缀部分与前缀部分存在重合，因此，<strong>当给定的模式串中不存在这种重合的话，相当于这种优化是不起作用的</strong>，所以说，在实际使用中，还是要结合应用背景，选择合适的技术。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - KMP字符串匹配算法</title>
    <url>/2019/05/06/Algorithm17-KMP/</url>
    <content><![CDATA[<p>在前面的文章中介绍了暴力匹配算法和 BM 算法，下面再介绍另一种匹配算法 - KMP 字符串匹配算法，之所以单独将它拿出来介绍，主要是它解释和理解起来都非常困难，为了更好的理解下面的内容，建议先看理解一下暴力匹配算法和 BM，这两者相对容易理解一些，可以当做一个预热。</p>
<a id="more"></a>
<h2 id="KMP-匹配算法"><a href="#KMP-匹配算法" class="headerlink" title="KMP 匹配算法"></a>KMP 匹配算法</h2><p>KMP 算法和 BM 类似的是，两种算法那都是希望在出现不匹配字符时，能够尽可能多的向后进行滑动，这样就能有效的减少字符对比次数，从而降低时间复杂度，BM 的做法在前文已经介绍过了，下面来看下 KMP 是如何做的，先看下面一个例子：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP01.png">
<p>当遇到不匹配的字符时，就需要找到一种规律，能够向后滑动多个字符。或者有人可能想到直接将模式串，与不匹配字符的下一个位置对齐不就可以了，其实我在最初接触字符匹配算法时，也有这样的想法，但是这样可能会错过匹配项，比如下面的例子：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP02.png">
<p>思考一下为什么上面例子中，会错过匹配的子串呢？这是因为，<strong>在已匹配前缀字符串 H 中，其后缀 “ab”，同样属于模式串 P 的前缀，这就可能错过匹配值</strong>。</p>
<p>好了，理解上面解释之后，最大滑动长度也就很清楚了，即将<em>模式串 P</em>滑动到，与<em>已匹配前缀H</em>的<strong>最长匹配后缀</strong>对齐，在上面例子中，就是将模式串与 H 后缀 “ab” 对齐：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP03.png">
<p>可以发现，整个滑动计算过程与主串没什么关系，这是因为我们处理的部分，是模式串与主串已经匹配的部分。既然如此，那么在进行匹配之前，我们能不能把匹配串 P 的所有前缀，以及前缀对应的最长匹配后缀处理好呢？</p>
<p>在 KMP 算法中采用一个数组来存储前缀信息，这个数组称为<strong>失效数组</strong>，数组的下标表示前缀尾字符下标（模式串中的下标），数组的值表示，在该前缀字符串中，最长匹配前缀的尾字符下标（前缀中的下标）。文字描述费劲看着也累，还是上面的例子，直接看图下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式串前缀</th>
<th style="text-align:left">前缀结尾字符下标</th>
<th style="text-align:left">最长匹配前缀尾字符下标</th>
<th style="text-align:left">数组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">0</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">next[0] = -1</td>
</tr>
<tr>
<td style="text-align:left">ab</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">next[1] = -1</td>
</tr>
<tr>
<td style="text-align:left">aba</td>
<td style="text-align:left">2</td>
<td style="text-align:left">0</td>
<td style="text-align:left">next[2] = 0</td>
</tr>
<tr>
<td style="text-align:left">abab</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
<td style="text-align:left">next[3] = 1</td>
</tr>
<tr>
<td style="text-align:left">ababc</td>
<td style="text-align:left">4</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">next[4] = -1</td>
</tr>
<tr>
<td style="text-align:left">ababca</td>
<td style="text-align:left">5</td>
<td style="text-align:left">0</td>
<td style="text-align:left">next[5] = 0</td>
</tr>
<tr>
<td style="text-align:left">ababcab</td>
<td style="text-align:left">6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">next[6] = 1</td>
</tr>
</tbody>
</table>
</div>
<p>那么这个 next 数组应该如何使用呢？还是看上面的例子，在模式串 P 的第 4 个字符出现不匹配，H 尾字符下标为 3，从表中可知 next[3] = 1，即 H 的前缀‘ab’与后缀‘ab’相同，因此，将模式串 P 前缀’ab’ 与 H 后缀’ab’对齐，相当于将 j 设置为 ‘ab’ 的下一个字符的下标，而改下标值等于 $next[3] + 1$。</p>
<p>上面这个过程可能有一些绕，和 BM 算法直接滑动主串不同，这里是滑动模式串，先假设用 i 表示主串字符索引，j 表示匹配串索引，不管滑动主串还是模式串，都是要比较 M[i]、P[j]，因此滑动匹配串就是更新 j 的值。</p>
<p>如果还是与有点不清楚，可以结合下面的 KMP 算法框架代码理解一下整个过程：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IndexOf</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> pat</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = s.Length;</span><br><span class="line">    <span class="keyword">int</span> M = pat.Length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式串索引指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果出现不匹配字符，则滑动模式串，直到 s[i]、pat[j] 匹配</span></span><br><span class="line">        <span class="keyword">while</span> (pat[j] != s[i] &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">            j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符匹配，则继续检查主串和模式串下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == pat[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == M)</span><br><span class="line">        &#123;<span class="comment">// 匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么模式串滑动要在 while 循环中，这是因为根据 next 数组进行滑动之后，s[i] 和 pat[j] 可能仍然不匹配，因此需要不断滑动，直到 s[i] 和 pat[j] 匹配，或者重新从匹配串起始进行匹配，具体过程见下图：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP04.png">
<h2 id="失效数组计算"><a href="#失效数组计算" class="headerlink" title="失效数组计算"></a>失效数组计算</h2><p>上面已经理解了怎么用 next 数组，下面一个重要问题就是怎么计算 next 数组，还是以模式串‘ababcab’为例，比如要计算 next[3] 的值，最粗暴的方法时找到所有的前缀，然后逐一检查是否有对应后缀与之匹配，next[3] 对应的子串为 ‘abab’：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">前缀</th>
<th style="text-align:left">匹配后缀</th>
<th style="text-align:left">前缀尾字符索引</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">aba</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">ab</td>
<td style="text-align:left">ab</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
</tbody>
</table>
</div>
<p>可以看到最长的匹配后缀为‘ab’，因此 next[3] = 1。这样的计算方式比较低效，原因在于当我们计算 next[4] 时，对于 next[3] 中计算的需要重新计算一遍，所以算法优化的重点在于如何根据 next[k-1] 计算 next[k] 的值。</p>
<p>根据 next[k-1] 计算 next[k] 分为以下几种情况:</p>
<p>首先说第一种情况，next[k-1]最长匹配前缀尾字符索引为 i，如果 next[k] 与 next[i+1] 匹配，此时 next[k] 的最长匹配的前缀尾字符索引为 $i+1$，还是看下面例子：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP05.png">
<p>上面的情况还算比较简单，但是当 next[k] 和 next[i+1] 不相等时，情况就变得比较复杂了，还是以模式串‘abcababcab’为例，来看下应该如何处理这种情况：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP06.png">
<p>next 失效数组为:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">前缀</th>
<th style="text-align:left">匹配后缀</th>
<th style="text-align:left">前缀尾字符索引</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abcababca</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">abcababc</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">abcabab</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">abcaba</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">abcab</td>
<td style="text-align:left">abcab</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">abca</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">abc</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left">ab</td>
<td style="text-align:left">ab</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">/</td>
<td style="text-align:left">-1</td>
</tr>
</tbody>
</table>
</div>
<p>当下一个字符为 ‘c’ 时，如下图所示：</p>
<img src="/2019/05/06/Algorithm17-KMP/KMP07.png">
<p>因为’a’、‘c’ 不匹配，所以不能像上面情况那样进行处理，即最长匹配后缀不是‘abcab’+‘c’，因此就需要考虑次长匹配后缀，从上面表中可知，次长匹配后缀为 ‘ab’，而‘ab’的下一个字符也是‘c’，所以 next[11] 的最长匹配后缀为 ‘abc’。</p>
<p>我们不能根据查表来获取次长匹配后缀，因此，下面问题就是如何找到次长匹配后缀，这里需要理解两点：</p>
<ol>
<li>次长匹配后缀属于最长匹配后缀的一部分；</li>
<li>最长匹配前缀、最长匹配后缀两者是相同的。</li>
</ol>
<p>基于以上两点，查找次长匹配后缀，就等价于从最长匹配后缀中，找出其最长匹配后缀，这样问题就变成了递归查找最长匹配后缀。这句话理解起来可能有点绕，还是继续上面的例子，最长匹配后缀为’abcab’，该字符串的最长匹配后缀为‘ab’。</p>
<p>可以配合下面代码理解一下上面两种情况的处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span>[] <span class="title">GetNexts</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">int</span> m</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] nexts = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">   nexts[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (k != <span class="number">-1</span> &amp;&amp; s[k + <span class="number">1</span>] != s[i])</span><br><span class="line">       &#123;</span><br><span class="line">           k = nexts[k];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (s[k + <span class="number">1</span>] == s[i])</span><br><span class="line">           k++;</span><br><span class="line"></span><br><span class="line">       nexts[i] = k;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nexts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>KMP 算法解释和理解起来确实非常困难，在理解过程中，可以动手画画来辅助理解。KMP 算法的空间复杂度为 O(M)，其中 M 为模式串长度；而时间复杂度分为O(M+N)，其中 M 为模式串长度，N 为主串长度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 单词查找树</title>
    <url>/2019/04/22/Algorithm16-Trie/</url>
    <content><![CDATA[<p>平时在进行上网搜索时，都会有搜索提示功能，能够根据我们输入，自动的给出相应的提示内容，那么这个功能应该如何来实现呢，当搜索词库数据量很少时，采用什么办法效率上可能差别不大，但是随着词库的不断增长，查询效率就是我们需要考虑的问题了，单词查找树就是这么一种解决方案。</p>
<a id="more"></a>
<h2 id="单词树的表示"><a href="#单词树的表示" class="headerlink" title="单词树的表示"></a>单词树的表示</h2><p>比如现在我们希望实现一个查找单词的 App，下面看下如何使用单词查找树来实现，首先要解决的问题就是单词存储，单词查找树，顾名思义，就是用树来保存单词的信息，下图展示一个单词查找树：</p>
<img src="/2019/04/22/Algorithm16-Trie/Trie.png">
<p>上图中，使用单词树存储了如下的单词（这里我们称之为’键’）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">by</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">sea</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">sells</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">she</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shells</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">the</td>
<td style="text-align:left">5</td>
</tr>
</tbody>
</table>
</div>
<p>通过观察上面的单词树，可以发现一些特点：</p>
<ul>
<li>链接各个字符结点组成单词；</li>
<li>单词的最后一个字符结点记录着单词的值；</li>
<li>每个字符结点只有一个父节点，可以保护多个子节点。</li>
</ul>
<p>这些特点和之前见过的一些树差不多，明显不同的是一些结点会记录对应单词的值，这个值是什么含义，怎么计算的？带着疑问继续下面的学习。</p>
<h2 id="单词树的查找操作"><a href="#单词树的查找操作" class="headerlink" title="单词树的查找操作"></a>单词树的查找操作</h2><p>如何在单词树种进行查找，流程其实非常简单，比如在上面树种查找单词“shells”：</p>
<ol>
<li>从根节点出发，在其子节点中查找第一个字符’s’；</li>
<li>找到’s’对应的结点之后，在其子节点中继续查找第2个字符’h’，如此递归，直到找到最后一个字符对应结点，或者子节点中不存在对应的字符链接，这里可能会遇到3中情况：<ol>
<li>尾字符对应结点的值非空，比如查找’shells’、‘she’；</li>
<li>尾字符对应结点的值为空，比如查找’shell’；</li>
<li>在子节点中没有找到对应字符链接，比如查找’shore’、‘them’。</li>
</ol>
</li>
</ol>
<img src="/2019/04/22/Algorithm16-Trie/Search.png">
<h2 id="单词树的插入操作"><a href="#单词树的插入操作" class="headerlink" title="单词树的插入操作"></a>单词树的插入操作</h2><p>在向单词树中插入新单词时，为了确定各个字符的插入位置，需要进行先查找，查找时可能遇到2种情况：</p>
<ul>
<li>在子节点中没找到字符的链接，比如插入‘shore’、‘them’；</li>
<li>找到了尾字符对应的节点，比如插入‘shell’。</li>
</ul>
<img src="/2019/04/22/Algorithm16-Trie/TrieInsert.png">
<h2 id="单词树的删除操作"><a href="#单词树的删除操作" class="headerlink" title="单词树的删除操作"></a>单词树的删除操作</h2><p>从单词树中删除单词时，首先需要查找单词所对应的尾节点，这里有以下几种情况：</p>
<ol>
<li>未找到单词所对应的尾结点，直接返回；</li>
<li>找到单词所对应的尾结点，然后置空该结点的值，下面处理方法分2中情况：<ol>
<li>该尾结点没有子结点，删除该结点，继续尝试删除父节点；</li>
<li>该尾结点包含子结点，直接返回。</li>
</ol>
</li>
</ol>
<h2 id="单词树的前缀匹配查找操作"><a href="#单词树的前缀匹配查找操作" class="headerlink" title="单词树的前缀匹配查找操作"></a>单词树的前缀匹配查找操作</h2><p>在进行搜索提示时，需要查找指定前缀的词，这个过程和单词树的查找比较类似，这里直接上代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">public class TrieST&lt;Value&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">char</span> key;</span><br><span class="line">      <span class="keyword">public</span> Value <span class="keyword">value</span>;</span><br><span class="line">      <span class="keyword">public</span> Dictionary&lt;<span class="keyword">char</span>, Node&gt; children = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, Node&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根结点</span></span><br><span class="line">  <span class="keyword">private</span> Node tree = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找键对应的节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Node node = tree;</span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (id != key.Length)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              node = node.children[key[id]];</span><br><span class="line">              id++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向树中添加键值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Put</span>(<span class="params"><span class="keyword">string</span> key, Value val</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Node node = tree;</span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (id != key.Length)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!node.children.ContainsKey(key[id]))</span><br><span class="line">          &#123;</span><br><span class="line">              node.children.Add(key[id], <span class="keyword">new</span> Node()</span><br><span class="line">              &#123;</span><br><span class="line">                  key = key[id]</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          node = node.children[key[id]];</span><br><span class="line"></span><br><span class="line">          id++;</span><br><span class="line">      &#125;</span><br><span class="line">      node.<span class="keyword">value</span> = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从树中删除对应的键值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Node node = tree;</span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">      System.Collections.Generic.Stack&lt;Node&gt; link = <span class="keyword">new</span> System.Collections.Generic.Stack&lt;Node&gt;();</span><br><span class="line">      <span class="keyword">bool</span> findTail = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (id != key.Length)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (node.children.ContainsKey(key[id]))</span><br><span class="line">          &#123;</span><br><span class="line">              node = node.children[key[id]];</span><br><span class="line">              link.Push(node);</span><br><span class="line">              id++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              findTail = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (findTail)</span><br><span class="line">      &#123;</span><br><span class="line">          node.<span class="keyword">value</span> = <span class="keyword">default</span>(Value);</span><br><span class="line">          <span class="keyword">if</span> (node.children.Count &gt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              link.Pop();</span><br><span class="line">              Node parent = link.Peek();</span><br><span class="line">              parent.children.Remove(node.key);</span><br><span class="line">              <span class="keyword">while</span> (link.Count &gt; <span class="number">0</span> &amp;&amp; parent.children.Count == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    parent.<span class="keyword">value</span>.Equals(<span class="keyword">default</span>(Value)))</span><br><span class="line">              &#123;</span><br><span class="line">                  node = parent;</span><br><span class="line">                  parent = link.Pop();</span><br><span class="line">                  parent.children.Remove(node.key);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到指定前缀的键值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; <span class="title">GetKeyWithPrefix</span>(<span class="params"><span class="keyword">string</span> prefix</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      List&lt;<span class="keyword">string</span>&gt; l = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      Node node = Get(prefix);</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">      System.Collections.Generic.Stack&lt;<span class="keyword">object</span>&gt; stack = <span class="keyword">new</span> System.Collections.Generic.Stack&lt;<span class="keyword">object</span>&gt;();</span><br><span class="line">      stack.Push(node);</span><br><span class="line">      stack.Push(prefix);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">string</span> pref = stack.Pop() <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">          Node x = stack.Pop() <span class="keyword">as</span> Node;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> (!x.<span class="keyword">value</span>.Equals(<span class="keyword">default</span>(Value)))</span><br><span class="line">              l.Add(pref);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> x.children)</span><br><span class="line">          &#123;</span><br><span class="line">              stack.Push(kvp.Value);</span><br><span class="line">              stack.Push(<span class="keyword">string</span>.Concat(pref,kvp.Key));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>时间复杂度：在单词树中查找对应键的值，最坏情况下的时间复杂度为键长度加1；</li>
<li>空间复杂度：对于字母表大小为 R、包含 N 个随机键的单词树，键的平均长度为 W，结点的链接总数在 RN ~ RNW 之间，所以有如下规律：<ul>
<li>当所有键均较短时，链接总数接近于 RN；</li>
<li>当所有键均较长时，链接总数接近于 RNW；</li>
<li>空间复杂度与 R 大小紧密相关。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了单词树 Trie，该数据结构常用来解决从大量词库中查找指定前缀的单词，比如网站的搜索功能，它能够最多搜索次数等于前缀的长度，是一种非常高效的结构，其比较适合键长较短的情景，当键长比较大时，占用的空间将会比较大。</p>
<p>除了上面的介绍的单词树之外，还有三向单词树，与Trie 不同，它是的每个结点只有三个子结点，在键比较长或者字符集比较大时，空间复杂度要比 Trie 树低很多，更加适合 Unicode 字符集。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 字符串匹配</title>
    <url>/2019/04/10/Algorithm16-StringMatch/</url>
    <content><![CDATA[<p>在日常开发中，经常会和字符串打交道，字符串匹配功能的使用频率也很高，比如 C# 中的 IndexOf()、Python 的 find()，它们背后实现就是字符串匹配算法，字符串匹配算法多种多样，如暴力匹配算法（BF），BM 算法、RK 算法、KMP 算法，本节主要介绍暴力匹配算法、BM 算法。</p>
<a id="more"></a>
<h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><p>字符串匹配是要解决如下问题：有字符串 A、B，要在 A 中找到子串 B，其中 A 称为主串，B 称为模式串。暴力匹配算法是最简单粗暴的解决方法，它的思想是这样的：</p>
<ol>
<li>将 B 看做一个可以滑动的窗口，初始时将 B 与 A 的起始位置对齐；</li>
<li>然后检查重合部分是否匹配，不匹配则将 B 向后滑动一个位置；</li>
<li>直到完全匹配或 A、B 末尾重合。</li>
</ol>
<p>用图来表示是这样的：</p>
<img src="/2019/04/10/Algorithm16-StringMatch/BF.png">
<p>代码实现也比较简单：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- bf 暴力匹配算法</span></span><br><span class="line"><span class="comment">-- t 主串</span></span><br><span class="line"><span class="comment">-- n 模式串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BFMatch</span><span class="params">(t,n)</span></span></span><br><span class="line">  <span class="keyword">if</span> #t &lt; #n <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i=<span class="number">1</span>,#t-#n+<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> matched = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,#n <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> t:<span class="built_in">byte</span>(i+j<span class="number">-1</span>) ~= n:<span class="built_in">byte</span>(j) <span class="keyword">then</span></span><br><span class="line">        matched = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matched <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>暴力匹配算法在最坏情况下需要进行 n-m 滑动，每次要比较 m 个字符，因此时间复杂度为 $O(MN)$，虽然时间复杂度比较高，但是在实际开发中也是比较常用，主要原因在于一般情况下主串不会太长，BF 算法在匹配成功之后就会结束计算，平均时间复杂度要更低；另外一个原因是 BF 算法实现比较简单。</p>
<h2 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h2><p>Boyer-Moore 字符串匹配算法简称 BM 算法，它是一种启发式算法，在字符匹配的过程中，会根据不匹配字符在模式串中的位置，确定模式串如何进行滑动，先看下面一个例子，先看下匹配过程示意图，结合图在稍作解释。</p>
<img src="/2019/04/10/Algorithm16-StringMatch/bm.png">
<ol>
<li>与暴力匹配算法不同，bm 是从右向左检查模式串，首先对比模式串最后一个 E 和主串第6个字符 N，发现不匹配，向后滑动模式串，让模式串中最右侧的 N 与主串 N 对齐；</li>
<li>再次自右向左对比模式串和主串，发现 S 和 E 不匹配，再次滑动，因为 S 在模式串中不存在，所以将模式串滑动到 S 的下一个位置；</li>
<li>再次自右向左对比，主串中的 E 和模式串相匹配，比较下一个字符 N 和 L，发现不匹配，向后滑动模式串，使模式串 N 与主串对齐；</li>
<li>再次自右向左对比，发现主串与模式串匹配。</li>
</ol>
<p>通过上面的过程可以发现，模式串的滑动与不匹配字符在模式串中的位置有关，具体是什么样的关系？如果整清楚这个问题了，那么 bm 算法也就清楚了，下面详细介绍 bm 算法的实现。</p>
<p>BM 算法实现分为两个阶段：</p>
<ol>
<li>记录字符表中各个字符在模式串中最后出现的位置；</li>
<li>子串匹配。</li>
</ol>
<p>还是结合上面的例子来看下这两个步骤是如何实现的，首先，记录字符表中的字符在模式串中最后出现位置，因为每次不匹配都要用到这个位置，所以查询起来必须非常高效，可以采用记录方案有两种，第一种对于只存在 ASCII 字符的模式串，可以使用 256 大小的数组来存储；第二种对于存在 Unicode 字符的模式串，可以使用散列表。这里采用第一种方式，实现也很简单：先将数组所有值置为 -1，然后从左向右遍历模式串设置数组，直接上代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">RecordRights</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] rightIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rightIndex.Length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      rightIndex[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.Length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      rightIndex[pattern[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rightIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子串匹配，整个过程其实是向右滑动模式串的过程，我们用 $i$ 记录模式串与主串对齐的位置，用 j 表示从右向左遍历模式串的索引，比较主串的 $M[i+j]$ 和 模式串的 $N[j]$，匹配则继续向右比较，不匹配时会遇到三种情况：</p>
<ol>
<li>不匹配字符不在模式串中，此时将模式串与不匹配字符的下一个字符对齐，即 i 增加 $j+1$；</li>
<li>不匹配字符在模式串中，我们找到它在模式串中出现的最后位置 $k$，使模式串与之对齐，即 i 增加 $j-k$;</li>
<li>对于第2中情况，如果$j-k &lt; 0$，即最后的位置在 j 的右侧，如果还按照第2种情况处理，就会使模式串向左滑动，这并不是我们期望的，所以此时将模式串向右滑动1个位置，即 i 增加 1。</li>
</ol>
<p>前面两种情况在上面的例子中都有遇到，特别说明一下第三种情况，如下图所示：</p>
<img src="/2019/04/10/Algorithm16-StringMatch/bm_noskip.png">
<p>在整清楚上面三种情况之后，代码实现相对容易一些，完整代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoyerMoore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rights;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> pattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoyerMoore</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">this</span>.rights = RecordRights(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span>[] <span class="title">RecordRights</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] rightIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rightIndex.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rightIndex[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rightIndex[pattern[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Search</span>(<span class="params"><span class="keyword">string</span> text</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> N = text.Length;</span><br><span class="line">        <span class="keyword">int</span> M = pattern.Length;</span><br><span class="line">        <span class="keyword">int</span> skip = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N-M; i+= skip)</span><br><span class="line">        &#123;</span><br><span class="line">            skip = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = M<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text[i+j] != pattern[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    skip = j - rights[text[i + j]];</span><br><span class="line">                    <span class="keyword">if</span> (skip &lt; <span class="number">1</span>) skip = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了两种字符串匹配算法，BF 暴力匹配算法、BoyerMoore 匹配算法，两个算法的执行过程，可以看做模式串窗口在主串上进行滑动的过程，其中 BF 每次滑动的步长为 1，而 BM 滑动的步长需要由不匹配字符和模式串来确定。</p>
<p>BF 的优点在于非常简单粗暴，易于理解和实现，BM 算法在主串非常大时能够极大的提高查找效率，在最坏情况下，两者的时间复杂度都为 $O(MN)$，一般情况下 BF 的复杂度为$O(N)$，BM 为$O(N/M)$。</p>
<p>除了BF 和 BM 算法之外，其他匹配算法还有 Rabin-Karp算法、KMP 算法，两者都是非常高效的匹配算法，尤其是 KMP 算法，感兴趣的可以看<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>匹配算法不止用在字符串匹配，类似的匹配也都可以使用这种思想，比如在一个设备操作考核中，从用户的操作序列中，匹配一个特定序列，来判断用户是否操作正确。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>一步一步实现极简光线追踪</title>
    <url>/2019/04/07/A-Tiny-RayTracer/</url>
    <content><![CDATA[<h1 id="一步一步实现极简光线追踪"><a href="#一步一步实现极简光线追踪" class="headerlink" title="一步一步实现极简光线追踪"></a>一步一步实现极简光线追踪</h1><p>关于光线追踪实现的教程网上有很多，但是绝大部分教程都非常难理解，或者涉及很多第三方库，或者对其中的一些基础知识介绍很少，本文将采用纯软件来实现光线追踪算法，针对光线追踪的全过程进行详细的介绍，为了便于理解，抛弃窗口显示功能，将最终的结果输出到图片文件中。</p>
<a id="more"></a>
<p>程序的实现是基于 Unity3D 的，如果需要 C/C++ 版本，可以参考<a href="https://github.com/ssloy/tinyraytracer" target="_blank" rel="noopener">原教程</a>，对于实现过程中涉及的一些几何计算，如果实在不理解或者不感兴趣，只需要清楚它的作用即可，不是说它不重要，相反，它是必不可少的，但是本文的重点是理解光线追踪算法，因此会尽可能的避免阻碍理解的内容。</p>
<h2 id="0x01-输出图片"><a href="#0x01-输出图片" class="headerlink" title="0x01 输出图片"></a>0x01 输出图片</h2><p>第一步是实现图片的存储输出功能，在实时渲染中，会将渲染结果显示到窗口视图，那样会做很多无关的工作，这里只是将渲染结果保存到图片中，减轻我们的理解压力。</p>
<p>在 Unity 中实现该功能非常的简单，实现代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step01.cs" target="_blank" rel="noopener">这里</a>。</p>
<p>输出结果如下：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Sample_01.jpg">
<h2 id="显示图形"><a href="#显示图形" class="headerlink" title="显示图形"></a>显示图形</h2><p>只有渐变背景有点单调，下面在背景上画一个圆球，最终的效果如下：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Sample_02.jpg">
<h3 id="0x02-定义球体"><a href="#0x02-定义球体" class="headerlink" title="0x02 定义球体"></a>0x02 定义球体</h3><p>首先需要定义一个球体，代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Sphere.cs" target="_blank" rel="noopener">这里</a>：</p>
<p>关于上面射线检测证明过程，可以参考<a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/" target="_blank" rel="noopener">这里</a>，过程比较详细。</p>
<h3 id="0x03-定义摄像机"><a href="#0x03-定义摄像机" class="headerlink" title="0x03 定义摄像机"></a>0x03 定义摄像机</h3><p>定义好图形之后，如何将图形显示到我们的图片中呢？换句话说，如何确定图片的哪些像素显示球呢？为了实现这一功能，需要引入一个摄像机，想象在一个三维场景中，在一架摄像机前面放置这一个球，最终摄像机会记录下特定范围内的画面，如下图所示：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Raycast.png">
<p>我们知道摄像机有一个拍摄范围，在计算机图形学中称这个范围为视锥体，为了表示这个范围，通常采用平截四棱锥来表示，具体的样子如下：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/ViewFrustum.png">
<p>其中，靠近摄像机的截面叫做近裁剪面、远离摄像机的截面叫做远裁剪面。为了确定输出图片中每个像素值，我们可以把图片贴到近裁剪面，然后以相机为起点（这里放到原点位置）、向每个像素发射射线，检测与球是否相交，如果相交说明就需要显示，反之则不需要。</p>
<h4 id="计算近裁剪面"><a href="#计算近裁剪面" class="headerlink" title="计算近裁剪面"></a>计算近裁剪面</h4><p>那么下面问题是如何计算每个像素对应的三维坐标，因为要将图片贴到近裁剪面，所以首先需要计算一下近裁剪面的尺寸，这里又多了个概念叫视场角，它是指视锥体两边的夹角，根据这个角度可以计算出近裁剪面的高度，而宽度可以根据指定的宽高比$aspect$计算，如下图所示：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/NearClip.png">
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取近裁剪面的尺寸</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="near"&gt;</span>近裁剪面距离摄像机的距离<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="fov"&gt;</span>视场角<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="aspect"&gt;</span>宽高比<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Vector2 <span class="title">GetNearClipSize</span>(<span class="params"><span class="keyword">float</span> near, <span class="keyword">float</span> fov, <span class="keyword">float</span> aspect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> height = Mathf.Tan(fov * <span class="number">0.5f</span>) * <span class="number">2.0f</span> * near;</span><br><span class="line">    <span class="keyword">float</span> width = height * aspect;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector2(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="屏幕坐标转世界坐标"><a href="#屏幕坐标转世界坐标" class="headerlink" title="屏幕坐标转世界坐标"></a>屏幕坐标转世界坐标</h4><p>有了近裁剪面的尺寸之后，下一步就是怎么把宽度为width、高度为height的图片贴到近裁剪面（映射的一个过程），代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据像素的索引，计算世界坐标</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="i"&gt;</span>像素的水平索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="j"&gt;</span>像素的垂直索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ScreenToWorld</span>(<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> width, <span class="keyword">int</span> height</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ix = i + <span class="number">0.5f</span>;    <span class="comment">// 像素的水平中心</span></span><br><span class="line">    <span class="keyword">float</span> jy = j + <span class="number">0.5f</span>;    <span class="comment">// 像素的垂直中心</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> aspect = (<span class="keyword">float</span>)width / height;</span><br><span class="line">    Vector2 nearClipSize = GetNearClipSize(<span class="number">1</span>, <span class="number">60.0f</span> * Mathf.Deg2Rad, aspect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围[0,nearClipSize.x]</span></span><br><span class="line">    <span class="keyword">float</span> x = ix * nearClipSize.x / width;</span><br><span class="line">    <span class="keyword">float</span> y = jy * nearClipSize.y / height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围：[-nearClipSize.x / 2,nearClipSize.x / 2]</span></span><br><span class="line">    x -= nearClipSize.x * <span class="number">0.5f</span>;</span><br><span class="line">    y -= nearClipSize.y * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector3(x, y, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Camera.cs" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="0x04-渲染图形"><a href="#0x04-渲染图形" class="headerlink" title="0x04 渲染图形"></a>0x04 渲染图形</h3><p>经过一系列计算，终于能够根据像素获取到三位坐标了，修改步骤01中的 GetPixel 函数，实现在背景色(0.2,0.7,0.8)上显示一个球，实现步骤如下：</p>
<ol>
<li>定义一个相机，并根据输入的像素位置，计算追踪射线；</li>
<li>定义一个球体；</li>
<li>进行射线检测，如果射线穿过球体，则返回球体的颜色，反之则返回背景色。</li>
</ol>
<p>代码<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step04.cs" target="_blank" rel="noopener">地址</a>。</p>
<h3 id="0x05-多添几个球"><a href="#0x05-多添几个球" class="headerlink" title="0x05 多添几个球"></a>0x05 多添几个球</h3><p>再向场景中添加几个不同颜色的球，最终的显示效果如下：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Sample_03.jpg">
<p>为了表示球的颜色信息，这里用材质来表示，同时定义 RenderObject 类来保存小球的使用的材质，<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Material.cs" target="_blank" rel="noopener">查看代码</a>。</p>
<p>当场景存在多个球时，就需要所有物体进行射线检测，为了方便计算，这里定义 World 对象来存储所有的球，同时为了方便查看各种效果，在场景中增加一个棋盘格平面，<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/World.cs" target="_blank" rel="noopener">完整代码</a>。</p>
<p>然后修改渲染部分代码：</p>
<ol>
<li>创建几个材质；</li>
<li>创建 World 对象，并添加几个球体，为球体绑定材质；</li>
<li>修改 CastRay 方法，由单个球的射线检测，改为整个场景的检测。</li>
</ol>
<p>完成代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step05.cs" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="添加灯光"><a href="#添加灯光" class="headerlink" title="添加灯光"></a>添加灯光</h2><p>上面实现虽然我们绘制的是三维的球，但是结果看上去只是二维，这是因为没有光影的明暗变化，我们之所以能够看到各种颜色的物体，是因为光线照射到物体表面，经过反射后进入到人眼中，最终经过眼睛感光成像才看到物体。</p>
<p>在这里我们不用考虑人眼是如何感光成像的，只需要关心光线是经过怎样的过程进入到眼睛的，光线照射到物体的表面之后，会分为两部分，第一部分会在物体表面发生散射，第二部分会进入到物体内部，它们都会产生不同的视觉特性。</p>
<p>真实的光照是非常复杂的，因此在图形学中会采用经验模型来模拟光照的效果，这里采用标准光照模型来计算光照，它的基本方法是将进入人眼的光照分为四部分：</p>
<ul>
<li>自发光</li>
<li>漫反射</li>
<li>高光反射</li>
<li>环境光</li>
</ul>
<h3 id="0x06-漫反射"><a href="#0x06-漫反射" class="headerlink" title="0x06 漫反射"></a>0x06 漫反射</h3><p>当光照照射向物体表面时，因为物体的表面时凹凸不平的（这里的表面指的是微表面，可以认为是分子甚至更小的），所以会随机散射到各个方向，因为方向是随机，可以认为在任何方向上都是一样的，和人眼在什么位置是无关的，但是散射的强度与光线的入射角度相关。它们之间的关系符合兰伯特定律：反射光线的强度与表面法线和光源入射方向之间的夹角的余弦值成正比，计算公式如下：</p>
<script type="math/tex; mode=display">
C_{diffuse} = C_{light} * m_{diffuse} * max(0,\vec{n}· \vec{l})</script><p>最终效果如下：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Sample_04.jpg">
<p>先定义灯光，点光源的主要参数包括位置、光照强度，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointLight</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> intensity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointLight</span>(<span class="params">Vector3 pos, <span class="keyword">float</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.position = pos;</span><br><span class="line">        <span class="keyword">this</span>.intensity = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改渲染部分:</p>
<ol>
<li>创建 PointLight 对象；</li>
<li>修改 CastRay 方法，当射线击中对象时，添加漫反射光照。</li>
</ol>
<p>最终代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step06.cs" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="0x07-高光反射"><a href="#0x07-高光反射" class="headerlink" title="0x07 高光反射"></a>0x07 高光反射</h3><p>高光反射用于描述光线照射到物体表面时，在表面完全镜面反射方向的辐射量，这里采用 Phong 模型来计算高光，涉及的参数包括光照方向、表面法线、视线方向、镜面反射方向，如下图所示：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Phong.png">
<p>反射方向能够根据其他参数计算获得：</p>
<script type="math/tex; mode=display">
\vec{r} = 2(\vec{n} · \vec{l})\vec{n} - \vec{l}</script><p>根据 Phong 模型计算高光：</p>
<script type="math/tex; mode=display">
C_{specular} = (C_{light} * m_{specular}) \max(0,\vec{v}· \vec{r})^{m_{gloss}}</script><p>其中 $m<em>{specular}$表示高光的颜色，$m</em>{gloss}$表示反光度，该值越大则高光的亮点越小，修改 代码如下：</p>
<ol>
<li>Material 内增加高光属性；</li>
<li>修改 CastRay 函数，增加高光计算。</li>
</ol>
<p>具体代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step07.cs" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="0x08-添加阴影"><a href="#0x08-添加阴影" class="headerlink" title="0x08 添加阴影"></a>0x08 添加阴影</h3><p>为了生成阴影，就需要计算每个像素是否在阴影范围之内，因此就需要检测是否被其他物体遮住光线，检测射线的起始位置从检测点向法线反向偏移，方向指向光源位置，这样的射线检测到交叉物体之后，说明该检测位置被其他物体遮挡住了，此时只需跳过光照处理，起始位置计算方式如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">orign = Vector3.Dot(ligthDir,normal) &lt; <span class="number">0</span>? point - normal*<span class="number">0.001f</span> : point + normal*<span class="number">0.001f</span>;</span><br></pre></td></tr></table></figure>
<p>实现代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step08.cs" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="0x09-添加反射"><a href="#0x09-添加反射" class="headerlink" title="0x09 添加反射"></a>0x09 添加反射</h3><p>前面提到，光线照射到物体表面时，会分为两部分，第一部分是进入到物体的内部，第二部分是反射到环境中，而这部分反射光照，同样会再次照射到其他物体之上，但是反射并不会无限进行下去，随着反射会不断的衰减，所以这里会设置一个深度值来表示反射的次数，反射位置的计算方式和阴影起始点计算方式相同，修改 CastRay 代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Color <span class="title">CastRay</span>(<span class="params">Vector3 origin, Vector3 dir, RenderObject[] objs, Light[] lights,<span class="keyword">int</span> depth</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Material material = <span class="literal">null</span>;</span><br><span class="line">    Vector3 normal = Vector3.zero;</span><br><span class="line">    Vector3 hitPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">4</span> || !world.SceneIntersect(origin, dir, <span class="keyword">ref</span> hitPoint, <span class="keyword">ref</span> normal, <span class="keyword">ref</span> material))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color(<span class="number">0.2f</span>, <span class="number">0.7f</span>, <span class="number">0.8f</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 reflDir = -Reflect(dir, normal).normalized;</span><br><span class="line">        Vector3 refl_Origin = Vector3.Dot(reflDir, normal) &lt; <span class="number">0</span> ? hitPoint - normal * <span class="number">0.001f</span> : hitPoint + normal * <span class="number">0.001f</span>;</span><br><span class="line">        Color refl_Color = CastRay(refl_Origin, reflDir, depth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> diffuse_light_intensity = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> specular_light_intensity = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lights.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 lightDir = (lights[i].position - hitPoint).normalized;</span><br><span class="line"></span><br><span class="line">            Vector3 sdRayOrigin = Vector3.Dot(normal, lightDir) &lt; <span class="number">0</span> ? hitPoint - normal * <span class="number">0.001f</span> : hitPoint + normal * <span class="number">0.001f</span>;</span><br><span class="line">            Vector3 sdHitNormal = Vector3.zero;</span><br><span class="line">            Vector3 sdHitPoint = Vector3.zero;</span><br><span class="line">            Material sdHitMaterial = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (world.SceneIntersect(sdRayOrigin, lightDir, <span class="keyword">ref</span> sdHitPoint, <span class="keyword">ref</span> sdHitNormal, <span class="keyword">ref</span> sdHitMaterial) &amp;&amp;</span><br><span class="line">                Vector3.Distance(sdRayOrigin, sdHitPoint) &lt; Vector3.Distance(hitPoint, lights[i].position))</span><br><span class="line">            &#123;<span class="comment">// 检测在光源和物体之间，是否存在其他遮挡物</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            diffuse_light_intensity += lights[i].intensity * Mathf.Max(<span class="number">0.0f</span>, Vector3.Dot(lightDir, normal));</span><br><span class="line">            specular_light_intensity += Mathf.Pow(Mathf.Max(<span class="number">0</span>, Vector3.Dot(dir, Reflect(-lightDir, normal))), material.gloss) * lights[i].intensity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> material.diffuse * diffuse_light_intensity +</span><br><span class="line">                        material.specular * specular_light_intensity + </span><br><span class="line">                        refl_Color * material.reflectAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step09.cs" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="0x0A-添加折射"><a href="#0x0A-添加折射" class="headerlink" title="0x0A 添加折射"></a>0x0A 添加折射</h3><p>无论漫反射、高光反射、镜面反射都属于光的反射部分，而进入物体的部分光线，会产生折射效果，其入射角和折射角之间可以用<a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">斯涅耳定律</a>来表示。</p>
<img src="/2019/04/07/A-Tiny-RayTracer/SnellLaw.png">
<p>其中 $\theta<em>{1}$ 表示入射角，$\theta</em>{2}$ 表示折射角，$n_1$ 是上层介质的折射率，$n_2$ 表示下层介质的折射率，$\vec{QO}$表示入射向量，$\vec{OP}$表示折射后光线的方向，$\vec{ON}$ 表示法线向量，以上这些向量都为单位向量。</p>
<p>求解折射向量 $\vec{OP}$ 过程如下：</p>
<p>分解向量$\vec{OP}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \vec{OP} &= \vec{OK} + \vec{OB}      \\
             &= \vec{OM} * \sin{\theta_2} - \vec{ON} * \cos{\theta_2} \\
\end{aligned} \tag{1}</script><p>分解 $\vec{QO}$ 向量：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \vec{QO} &= \vec{OM} * \sin{\theta_1} + \vec{ON} * \cos{\theta_1} \\
\end{aligned} \tag{2}</script><p>根据点乘 $\vec{QO}$、$\vec{ON}$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \vec{QO} \cdot \vec{ON} &= |\vec{QO}|\cdot |\vec{ON}| \cos{\theta_1}  = \cos{\theta_1}  \\
    \sin{\theta_1} &= \sqrt{1 - {\cos^2{\theta_1}}} \\
\end{aligned} \tag{3}</script><p>将 (3) 带入 (2) 式可得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\vec{OM} &= \frac{\vec{QO} - \vec{ON} * \cos{\theta_1}}{\sin{\theta_1}}   \\
        &=  \frac{\vec{QO} - \vec{ON} * (\vec{QO} \cdot \vec{ON})}{\sin{\theta_1}}   \\
\end{aligned}   \tag{4}</script><p>根据斯涅耳方程:</p>
<script type="math/tex; mode=display">
\begin{aligned}
    n_1*\sin{\theta_1} &= n_2 * \sin{\theta_2}    \\
    \cos{\theta_2} &= \sqrt{1 - (\frac{n_1}{n_2})^2 * ({1-{\cos^2{\theta_1}}})} \\
                   &= \sqrt{1 - (\frac{n_1}{n_2})^2 * ({1-({\vec{QO}\cdot \vec{ON}})^2})} \\

    \sin{\theta_2} &= \sqrt{1 - \cos^2{\theta_2}}   \\
\end{aligned} \tag{5}</script><p>将 (4)、(5) 带入 (1) 式可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \vec{OP} &= \vec{OM} * \sin{\theta_2} - \vec{ON} * \cos{\theta_2} \\
             &= (\frac{\vec{QO} - \vec{ON} * (\vec{QO} \cdot \vec{ON})}{\sin{\theta_1}} ) * \sin{\theta_2} - \vec{ON} * (\sqrt{1 - (\frac{n_1}{n_2})^2 * ({1-({\vec{QO}\cdot \vec{ON}})^2})})   \\
             &= (\vec{QO} - \vec{ON} * (\vec{QO} \cdot \vec{ON})) * (\frac{n_1}{n_2}) - \vec{ON} * (\sqrt{1 - (\frac{n_1}{n_2})^2 * ({1-({\vec{QO}\cdot \vec{ON}})^2})})    \\
             &= \vec{QO}*\frac{n_1}{n_2} - \vec{ON} *((\vec{QO}\cdot \vec{ON}) * \frac{n_1}{n_2} + (\sqrt{1 - (\frac{n_1}{n_2})^2 * ({1-({\vec{QO}\cdot \vec{ON}})^2})}))  \\
\end{aligned}</script><p>上式中需要开平方根，所以需要其下的值不小于0才有解，当其下值小于0时，上式无解，即不存在折射向量。</p>
<p>有了上面的计算结果之后，代码实现就非常简单了，具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">Refract</span>(<span class="params">Vector3 Q, Vector3 N, <span class="keyword">float</span> eta_t, <span class="keyword">float</span> eta_i = <span class="number">1.0f</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> cos_theta1 = Vector3.Dot(-Q, N);</span><br><span class="line">  <span class="keyword">if</span> (cos_theta1 &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Refract(Q, -N, eta_i, eta_t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> eta = eta_i / eta_t;</span><br><span class="line">  <span class="keyword">float</span> k = <span class="number">1</span> - eta * eta * (<span class="number">1</span> - cos_theta1 * cos_theta1);</span><br><span class="line">  <span class="keyword">return</span> k &lt; <span class="number">0</span> ? <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) : (Q * eta - N * (eta * cos_theta1 + Mathf.Sqrt(k)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码在<a href="https://github.com/huosk/TinyRayTracer/blob/master/Assets/Scripts/Step09.cs" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再次把射线追踪的示意图放出来：</p>
<img src="/2019/04/07/A-Tiny-RayTracer/Raycast.png">
<p>整个过程是从眼睛（Camera）开始，向三维场景中发出射线，获取碰撞点的颜色，而这个颜色可能有一下几种情况：</p>
<ol>
<li>没有碰到任何物体，返回背景色；</li>
<li>碰到物体，如果存在灯光，则需要根据光照模型进行计算，结果由几部分组成：<ol>
<li>漫反射：与光线、法线有关；</li>
<li>高光反射：与光线、视线、法线有关；</li>
<li>阴影：从碰撞点向光源发出射线，检测是否存在遮挡；</li>
<li>反射：反射的哪个物体？需要计算射线的反射向量，再次进行射线检测；</li>
<li>折射：折射的哪个物体？需要计算射线的折射向量，再次进行射线检测。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>图形渲染</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 最小生成树</title>
    <url>/2019/04/06/Algorithm15-MST/</url>
    <content><![CDATA[<h1 id="数据结构与算法-最小生成树"><a href="#数据结构与算法-最小生成树" class="headerlink" title="数据结构与算法 - 最小生成树"></a>数据结构与算法 - 最小生成树</h1><p>在之前学习了无向图和有向图，本节再介绍一种常用的图结构-加权无向图，从名字上就可以看出来，它是无向图的一种，与无向图不同的是，加权无向图的边带有权重，这个权重可以表示任意内容，比如地图中的距离、电网中成本等等。在这些问题中，通常比较关心如何成本最小化，下面就看看如何通过最小生成树来解决此类问题。</p>
<a id="more"></a>
<p>什么是生成树？图的生成树是一颗包含其所有顶点的<strong>无环连通子图</strong>；<br>什么是最小生成树？它是生成树的一种，其特点是所有边权值的和最小。</p>
<h2 id="加权无向图数据结构"><a href="#加权无向图数据结构" class="headerlink" title="加权无向图数据结构"></a>加权无向图数据结构</h2><p>在介绍最小生成树实现算法之前，首先需要了解加权无向图如何表示，上一篇中介绍了无向图的表示方法，加权无向图与之类似，只不过多了一个权重值，因此需要定义边结构体，详细代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span></span><br><span class="line">&#123;</span><br><span class="line">    public class Edge : IComparable&lt;Edge&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Either &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span>(<span class="params"><span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">float</span> weight</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Either = v;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>.Weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params">Edge other</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Weight.CompareTo(other.Weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Other</span>(<span class="params"><span class="keyword">int</span> vertex</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex == <span class="keyword">this</span>.Either) <span class="keyword">return</span> <span class="keyword">this</span>.w;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vertex == <span class="keyword">this</span>.w) <span class="keyword">return</span> <span class="keyword">this</span>.Either;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">"Inconsistent edge"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> VertexCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> EdgeCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Edge&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span>(<span class="params"><span class="keyword">int</span> vCount</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.VertexCount = vCount;</span><br><span class="line">        <span class="keyword">this</span>.EdgeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> HashSet&lt;Edge&gt;[vCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> HashSet&lt;Edge&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params">Edge e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e.Either;</span><br><span class="line">        <span class="keyword">int</span> w = e.Other(v);</span><br><span class="line">        <span class="keyword">this</span>.adj[v].Add(e);</span><br><span class="line">        <span class="keyword">this</span>.adj[w].Add(e);</span><br><span class="line">        <span class="keyword">this</span>.EdgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顶点的所有相邻顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;Edge&gt; <span class="title">GetAdjs</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Edge&gt;(<span class="keyword">this</span>.adj[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顶点的度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetDegree</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.adj[v].Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有顶点最大的度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMaxDegree</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxDegree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.adj.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.adj[i].Count &gt; maxDegree)</span><br><span class="line">                maxDegree = <span class="keyword">this</span>.adj[i].Count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有顶点的平均度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">GetAvgDegree</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.0f</span> * <span class="keyword">this</span>.EdgeCount / <span class="keyword">this</span>.VertexCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与无向图的表示主要有两点不同：</p>
<ol>
<li>边表示方式不同：加权无向图单独定义了边结构体；</li>
<li>邻接表存储方式不同：使用 HashSet 顶点邻接边。</li>
</ol>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>介绍的第一种最小生成树计算方法叫做 Prim 算法，它的思想是这样：</p>
<ol>
<li>将树的顶点分为未访问、已访问两部分，初始时已访问部分只有一个顶点 A；</li>
<li>然后访问顶点 A 的相邻顶点，从相邻顶点中找出<strong>未访问</strong>且<strong>边权重最小</strong>的顶点 B，将 B 加入到已访问部分；</li>
<li>递归的对 B 执行 第 2 步操作，直到所有顶点访问完成。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazyPrimMST</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 标记顶点是否已经访问过</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小生成树的边</span></span><br><span class="line">  <span class="keyword">private</span> System.Collections.Generic.Queue&lt;EdgeWeightedGraph.Edge&gt; mst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小顶堆，维护顶点相邻的边，方便高效的从中找出</span></span><br><span class="line">  <span class="comment">// 权重最小的边</span></span><br><span class="line">  <span class="keyword">private</span> Heap&lt;EdgeWeightedGraph.Edge&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span>(<span class="params">EdgeWeightedGraph graph</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.VertexCount];</span><br><span class="line">      <span class="keyword">this</span>.mst = <span class="keyword">new</span> System.Collections.Generic.Queue&lt;EdgeWeightedGraph.Edge&gt;();</span><br><span class="line">      <span class="keyword">this</span>.pq = <span class="keyword">new</span> Heap&lt;EdgeWeightedGraph.Edge&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始时，将第一个顶点标记为已访</span></span><br><span class="line">      <span class="comment">// 然后遍历其邻边</span></span><br><span class="line">      Visit(graph, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 获取权重值最小的边</span></span><br><span class="line">          EdgeWeightedGraph.Edge e = pq.RemoveMin();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> v = e.Either;</span><br><span class="line">          <span class="keyword">int</span> w = e.Other(v);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果两个顶点都已经访问过，则不做任何处理</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.marked[v] &amp;&amp; <span class="keyword">this</span>.marked[w])</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将最小边添加到生成树种</span></span><br><span class="line">          mst.Enqueue(e);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 继续递归遍历</span></span><br><span class="line">          <span class="comment">// v、w 两者必有一个已经访问过</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[v]) <span class="keyword">this</span>.Visit(graph, v);</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[w]) <span class="keyword">this</span>.Visit(graph, w);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph graph, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> adjs = graph.GetAdjs(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 如果相邻的顶点还未访问，将之添加到小顶堆中</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[adjs[i].Other(v)])</span><br><span class="line">              pq.Insert(adjs[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> IEnumerable&lt;EdgeWeightedGraph.Edge&gt; Edges()</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> mst;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一副包含 V 个顶点、E 条边的连通加权无向图来说，LazmPrim 实现能够在 $E\log{E}$ 的时间复杂度内完成最小生成树算法，但是 LazyPrim 算法还存在一定的改进空间，先看下下图 LazyPrim 的执行过程：</p>
<img src="/2019/04/06/Algorithm15-MST/LazyPrim.png">
<p>那么问题出在哪里呢？先简单说一下上面的执行过程：</p>
<ol>
<li>初始时将第一个元素 0 添加的生成树中，并且将相邻边添加到优先级队列中；</li>
<li>然后从优先级队列中取出最小边 0-2，将 2 添加到生成树中，并且将 2 相邻的边添加到优先级队列（标绿部分）；</li>
<li>重复第 2 步骤，这次取出的是边 2-6，将 6 添加到生成中，此时问题出现了，因为之前将边 0-6 添加到了优先级队列，而此时0、6都是生成树的顶点，所以0-6就失效了（因为0-2-6已经保证了0-6之间的连通性，所以就不需要额外的边添加到最小生成树中了），下次从优先级队列中取出 0-6 时就做了无用功。</li>
</ol>
<p>通过上面过程 LazyPrim 算法的问题就很明显了，解决该问题的关键在于向优先级队列中插入边时，需要检测哪些边需要插入、哪些不需要，详细的过程这里就不赘述了，直接看代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrimMST</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> EdgeWeightedGraph.Edge[] EdgeTo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span>[] DistTo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] marked;</span><br><span class="line">  <span class="keyword">private</span> IndexMinPQ&lt;<span class="keyword">float</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span>(<span class="params">EdgeWeightedGraph graph</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.EdgeTo = <span class="keyword">new</span> EdgeWeightedGraph.Edge[graph.VertexCount];</span><br><span class="line">      <span class="keyword">this</span>.DistTo = <span class="keyword">new</span> <span class="keyword">float</span>[graph.VertexCount];</span><br><span class="line">      <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.VertexCount];</span><br><span class="line">      pq = <span class="keyword">new</span> IndexMinPQ&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.VertexCount; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          DistTo[i] = <span class="keyword">float</span>.MaxValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DistTo[<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">      pq.Insert(<span class="number">0</span>, <span class="number">0.0f</span>);</span><br><span class="line">      <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">          Visit(graph, pq.RemoveMin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph graph,<span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> adjs = graph.GetAdjs(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> w = adjs[i].Other(v);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.marked[w])</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.DistTo[w] &gt; adjs[i].Weight)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 更新最佳边</span></span><br><span class="line">              <span class="keyword">this</span>.EdgeTo[w] = adjs[i];</span><br><span class="line"></span><br><span class="line">              <span class="keyword">this</span>.DistTo[w] = adjs[i].Weight;</span><br><span class="line">              <span class="keyword">if</span> (pq.Contains(w)) pq.Change(w, DistTo[w]);</span><br><span class="line">              <span class="keyword">else</span> pq.Insert(w, DistTo[w]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> IEnumerable&lt;EdgeWeightedGraph.Edge&gt; Edges()</span><br><span class="line">  &#123;</span><br><span class="line">      List&lt;EdgeWeightedGraph.Edge&gt; mst = <span class="keyword">new</span> List&lt;EdgeWeightedGraph.Edge&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.EdgeTo.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          mst.Add(EdgeTo[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mst;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加权无向图是对无向图的一种扩展，它的边带有权重属性，最小生成树是包含所有节点，并且边权重之和最小的子树，它常被用来解决成本最小化的问题，介绍了 Prim 最小生成树算法，包括 Lazy 实现和优化实现，它的时间复杂度为$E\log{E}$，另外常用的最小生成树算法 Kruskal 算法。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 图</title>
    <url>/2019/03/20/Algorithm14-Graph/</url>
    <content><![CDATA[<p>本节介绍一种新的数据结构-图，图的应用非常广泛，例如社交网络中的好友关系、计算机网络连接关系、地图道路等等，图的种类多种多样，根据不同的业务需求，选择不同的图，这里介绍4中最重要的图模型：无向图（简单连接）、有向图（连接有方向）、加权图（连接带有权重）、加权有向图（连接既有方向又包含权重）。</p>
<a id="more"></a>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图的定义是这样的：</p>
<blockquote>
<p>图是由一组<strong>顶点</strong>和一组连接两个顶点的<strong>边</strong>组成的。</p>
</blockquote>
<p>一般来说，顶点叫什么我们并不关心（地图中的路口、社交网络中的人、电路中的元器件都是顶点），我们只需要有一种方法来指代这些顶点，一般用 0 到 V-1 来表示一张包含 V 个顶点的图。</p>
<img src="/2019/03/20/Algorithm14-Graph/Graph.png">
<p>有两种特殊的情况：</p>
<ul>
<li>自环：一个顶点，一条边头尾都连接到顶点；</li>
<li>平行边：头尾是同一对顶点的两条边称为<strong>平行边</strong>。</li>
</ul>
<img src="/2019/03/20/Algorithm14-Graph/Graph_Special.png">
<p>与图相关的几个术语：</p>
<ul>
<li>相邻顶点：如果两个顶点通过一条边相连时，那么这两个顶点是<strong>相邻的</strong>，并称这条边<strong>依附于</strong>这两个顶点；</li>
<li>顶点的度：与顶点相连的边的数量，叫做<strong>顶点的度</strong>；</li>
<li>路径：路径是由边顺序连接的一组顶点；</li>
<li>连通图：图中任意两个顶点都至少有一条路径连接，这种图叫做<strong>连通图</strong>；</li>
<li>环：至少包含一条边，并且起点和终点相同的路径。</li>
</ul>
<p>如果将图看做是物理存在的物体，比如绳结为顶点、绳子为边，那么拎起任意一个绳结，连通图将会是一个整体，而非连通图将会散落成好几部分。</p>
<h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>图是用来解决实际问题，所以表示图的数据结构应该能够解决绝大部分问题，其应该具备以下两点：</p>
<ul>
<li>能够容纳各种规模的数据，小到几十个顶点，大到百万个顶点；</li>
<li>操作起来效率要高。</li>
</ul>
<p>一般可供选择的表示方法由：邻接矩阵、边数组、邻接表数组，下面就具体看一下这三种方法各有什么优缺点。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是基于二维数组的，如果图$V$中的顶点$i$、$j$有边连接，对应矩阵的第i行、j列标记为1，所以对于包含 $n$ 个顶点的图，就需要 $n x n$ 的二维数组，这就会造成极大的空间浪费，不满足上面的第一点要求；另外，邻接矩阵无法表示平行边。</p>
<img src="/2019/03/20/Algorithm14-Graph/Matrix.png">
<h4 id="边数组"><a href="#边数组" class="headerlink" title="边数组"></a>边数组</h4><p>这种方法是定义边结构体，其中包含所依附的顶点，将图所有的边存储到数组中，这种方式对于某些操作（比如查找顶点相连的边）效率比较低，需要遍历所有的边才能够完成，不满足上面的第二点要求。</p>
<img src="/2019/03/20/Algorithm14-Graph/EdgeArray.png">
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表是顶点索引的数组，数组元素为指向链表的指针，链表中存储着该顶点相邻的顶点索引。采用这种方式能够满足上面的两点要求，对于一个包含 V 个顶点 E 条边的图，所需的空间大小为 V + E；查找相连顶点的时间复杂度为 $O(1)$；为顶点增加新连接的时间复杂度与该顶点的度成正比；并且能够表示平衡边。</p>
<p>如果顶点不是整数，没有办法作为索引，这种情况可以采用散列表替换数组和链表，比如 C# 中的 Dictionary、HashSet。</p>
<img src="/2019/03/20/Algorithm14-Graph/AdjList.png">
<h3 id="无向图基础操作"><a href="#无向图基础操作" class="headerlink" title="无向图基础操作"></a>无向图基础操作</h3><p>这里只实现图相关的基本操作，采用邻接表表示方式，包括：</p>
<ul>
<li>添加边；</li>
<li>获取顶点个数；</li>
<li>获取边数；</li>
<li>获取相邻顶点；</li>
<li>计算顶点的度；</li>
<li>计算所有顶点的最大度数；</li>
<li>计算所有顶点的平均度数。</li>
</ul>
<p>为了实现起来简便，这里没有实现<strong>添加顶点、删除顶点、删除边</strong>，顶点也表示为整数。</p>
<p>直接上代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 顶点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">int</span> VertexCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> EdgeCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.VertexCount = v;</span><br><span class="line">        <span class="keyword">this</span>.EdgeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params"><span class="keyword">int</span> v, <span class="keyword">int</span> w</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[v].Add(w);</span><br><span class="line">        <span class="keyword">this</span>.adj[w].Add(v);</span><br><span class="line">        <span class="keyword">this</span>.EdgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetVertexCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.VertexCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetEdgeCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.EdgeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顶点的所有相邻顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">GetAdjs</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(<span class="keyword">this</span>.adj[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顶点的度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetDegree</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.adj[v].Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有顶点最大的度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMaxDegree</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxDegree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.adj.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.adj[i].Count &gt; maxDegree)</span><br><span class="line">                maxDegree = <span class="keyword">this</span>.adj[i].Count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有顶点的平均度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">GetAvgDegree</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.0f</span> * <span class="keyword">this</span>.EdgeCount / <span class="keyword">this</span>.VertexCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>在介绍完了图的一些基础算法之后，继续介绍图的搜索算法，图的搜索算法用途非常广泛，最典型的是寻路，将地图抽象为图结构，给定起点、终点，搜索出一条可行的路径；再比如社交网络中有个著名的<a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%BA%A6%E5%88%86%E9%9A%94%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">六度分隔理论</a>，该理论认为世界上两个互不认识的人，最多只需要6个中间人就能够联系在一起。</p>
<p>图的搜索算法很多，比如下面要介绍的深度优先搜索、广度优先搜索，以及 A<em>、IDA</em> 等启发式算法，为了将算法和图的实现解耦，这里采用策略模式，将各个算法封装为单独的类。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索(Breadth-First-Search、BFS)是暴力搜索的一种，很多复杂的搜索算法都是基于广度优先搜索演变而来的，它的流程是这样的，从起始顶点开始：</p>
<ol>
<li>遍历顶点 $A$ 的相邻顶点$A_i \in [A_0,A_n]$；</li>
<li>如果$A_i$已经访问过，则跳过，否则记录下在搜索路径上离 $A_i$ 最近的顶点 $A$，并标记 $A_i$ 已经访问过；</li>
<li>当 $A$ 相邻的顶点遍历完成之后，开始遍历 $A_i \in [A_0,A_n]$ 的相邻的节点，重复 1 过程。</li>
<li>直到图中所有的顶点遍历完成之后，搜索结束。</li>
</ol>
<p>广度优先搜索是一种地毯式搜索，借助下面动画理解一下搜索过程。</p>
<img src="/2019/03/20/Algorithm14-Graph/BFS.gif">
<p>虽然看起来流程很简单，但是实现起来还是略微有些麻烦，还是直接上代码，通过代码理解一下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BFSSearch</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> Start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从起点到达该顶点的路径上的最后一个顶点</span></span><br><span class="line">  <span class="comment">// 通过递归的方式，就能找到到起点的路径</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] EdgeTo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否存在从起点到该顶点的路径</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] Marked;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BFSSearch</span>(<span class="params">Graph g,<span class="keyword">int</span> s</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.Start = s;</span><br><span class="line">      <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.EdgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVertexCount()];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.BFS(g, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span>(<span class="params">Graph g,<span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="comment">// 保存待遍历的节点</span></span><br><span class="line">      Queue&lt;<span class="keyword">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记起点 - 已访问</span></span><br><span class="line">      Marked[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      queue.Enqueue(s);</span><br><span class="line">      <span class="keyword">while</span>(queue.Size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> ver = queue.Dequeue();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获取相邻节点</span></span><br><span class="line">          IList&lt;<span class="keyword">int</span>&gt; adjs = g.GetAdjs(ver);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 相邻节点</span></span><br><span class="line">              <span class="keyword">int</span> adjVer = adjs[i];</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果已经访问过，则直接跳过</span></span><br><span class="line">              <span class="keyword">if</span> (Marked[adjVer]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 一路遍历到这里，说明存在到这里的路</span></span><br><span class="line">              <span class="comment">// 另一个意义就是标记该节点已经访问过，避免后续重复访问</span></span><br><span class="line">              <span class="keyword">this</span>.Marked[adjVer] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 记录一下这条路上离我最近的点</span></span><br><span class="line">              <span class="keyword">this</span>.EdgeTo[adjVer] = ver;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将相邻节点的相邻节点添加到队列</span></span><br><span class="line">              <span class="comment">// 本层级的相邻节点遍历完之后，进行下一级遍历</span></span><br><span class="line">              queue.Enqueue(adjVer);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否存在从 s 到 v 的路径</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.Marked[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到从 s 到 v 的路径</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="comment">// 不存在路径</span></span><br><span class="line">      <span class="keyword">if</span> (!HasPathTo(v))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt; stack = <span class="keyword">new</span> System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">      <span class="keyword">int</span> prev = v;</span><br><span class="line">      <span class="keyword">while</span>(prev != <span class="keyword">this</span>.Start)</span><br><span class="line">      &#123;</span><br><span class="line">          stack.Push(prev);</span><br><span class="line">          prev = <span class="keyword">this</span>.EdgeTo[prev];</span><br><span class="line">      &#125;</span><br><span class="line">      stack.Push(<span class="keyword">this</span>.Start);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>广度优先搜索是层层递进的地毯式搜索，深度优先搜索则截然相反，它的搜索方式就好像一个人在走迷宫，沿着一条路一直走，直到无路可走，才回头选择其他的路。</p>
<p>深度优先搜索的描述比 BFS 还要简单，只需要<strong>递归地遍历</strong>图所有顶点，在访问任一顶点时：</p>
<ol>
<li>如果已被标记为已搜索，则跳过，否则继续搜索；</li>
<li>将该顶点标记为已搜索；</li>
<li>递归的遍历该顶点的相邻顶点。</li>
</ol>
<p>可以通过下面动画来理解一下这一过程：</p>
<img src="/2019/03/20/Algorithm14-Graph/DFS.gif">
<p>实现代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DFSSearch</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> Start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] EdgeTo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] Marked;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DFSSearch</span>(<span class="params">Graph g, <span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Start = s;</span><br><span class="line">      <span class="keyword">this</span>.EdgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.DFS(g, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params">Graph g, <span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      IList&lt;<span class="keyword">int</span>&gt; adjs = g.GetAdjs(s);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 已经访问过，则直接跳过</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.Marked[adjs[i]])</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.EdgeTo[adjs[i]] = s;</span><br><span class="line">          <span class="keyword">this</span>.DFS(g, adjs[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.Marked[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.HasPathTo(v))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt; stack = <span class="keyword">new</span> System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">      <span class="keyword">while</span> (v != <span class="keyword">this</span>.Start)</span><br><span class="line">      &#123;</span><br><span class="line">          stack.Push(v);</span><br><span class="line">          v = <span class="keyword">this</span>.EdgeTo[v];</span><br><span class="line">      &#125;</span><br><span class="line">      stack.Push(<span class="keyword">this</span>.Start);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图和无向图非常类似，唯一的区别在于有向图的边是有方向的，有向图的应用也非常广泛，比如表示食物链（动物之间的捕食关系基本都是单向的）、论文中的引用关系等。</p>
<blockquote>
<p>有向图是由一组顶点和一组有方向的边组成。</p>
</blockquote>
<p>有向图的表示方法和无向图相同，都是采用邻接表。</p>
<img src="/2019/03/20/Algorithm14-Graph/Digraph_AdjList.png">
<h3 id="有向图基础操作"><a href="#有向图基础操作" class="headerlink" title="有向图基础操作"></a>有向图基础操作</h3><p>与无向图的基本操作大致相同，不同的是添加边、删除边操作，另外有向图还会经常用到取反操作，就是将所有边的方向反向，下面直接上代码，与无向图相同的部分，这里就不列出来了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加边v-&gt;w</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params"><span class="keyword">int</span> v, <span class="keyword">int</span> w</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.adj[v].Add(w);</span><br><span class="line">   <span class="keyword">this</span>.EdgeCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取反向图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Digraph <span class="title">Reverse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Digraph reverse = <span class="keyword">new</span> Digraph(<span class="keyword">this</span>.VertexCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.VertexCount; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.adj[i].Count; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           reverse.AddEdge(j, i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有向图搜索算法"><a href="#有向图搜索算法" class="headerlink" title="有向图搜索算法"></a>有向图搜索算法</h3><p>深度优先搜索和广度优先搜索也都适用于有向图，主要用于解决<strong>对象可达性</strong>判断，应用非常广泛，比如垃圾回收标记算法、有向图寻路等，可达性包含单点可达性、多点可达性：</p>
<p>单点可达性：在给定的一个起点、一个目标点之间，是否存在有向的路径；<br>多点可达性：在给定多个起点、一个目标点之间，是否存在有向的路径。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DirectedDFS</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] Marked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单点可达性</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span>(<span class="params">Digraph graph,<span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.DFS(graph, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多点可达性判断</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span>(<span class="params">Digraph graph,IEnumerable&lt;<span class="keyword">int</span>&gt; ss</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.GetVertexCount()];</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ss)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.Marked[item])</span><br><span class="line">              <span class="keyword">this</span>.DFS(graph, item);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度优先搜索</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params">Digraph graph,<span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked[s] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> adjs = graph.GetAdjs(s);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.Marked[adjs[i]])</span><br><span class="line">              <span class="keyword">this</span>.DFS(graph, s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsReachable</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.Marked[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h3><p>有向图的另一个重要应用是解决调度问题，比如有一系列任务需要完成，每个任务可能都有前置执行条件，如何确定任务执行顺序，这里就可以采用拓扑排序来解决。</p>
<blockquote>
<p>拓扑排序就是将有向图中的顶点进行排序，使得所有的边都从前面顶点指向后面的顶点。</p>
</blockquote>
<img src="/2019/03/20/Algorithm14-Graph/Topologic.png">
<p>从定义结合图可以看出来，如果有向图中存在环，即图必须是有向无环图（DAG），是无法进行拓扑排序的，所以在进行拓扑排序之前，需要判断有向图中是否存在有向环。</p>
<h4 id="有向环判断"><a href="#有向环判断" class="headerlink" title="有向环判断"></a>有向环判断</h4><p>有向环的判断需要使用深度优先搜索，过程就像一个人拿着绳子在走迷宫，走的过程中会不断放下绳子，如果遇到了死路则回退到最近的一个路口，退的过程中会将绳子收起来，然后继续选择其他路径前进，如果前进过程中发现地上有绳子，说明该迷宫中存在环，用代码实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DirectedCircle</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] Marked;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] EdgeTo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span>[] IsInStack;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">bool</span> HasCirCle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> CircleVertex;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DirectedCircle</span>(<span class="params">Digraph graph</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.EdgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.GetVertexCount()];</span><br><span class="line">      <span class="keyword">this</span>.IsInStack = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.GetVertexCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.GetVertexCount();v++)</span><br><span class="line">          <span class="keyword">if</span>(!<span class="keyword">this</span>.Marked[v])</span><br><span class="line">              DFS(graph, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params">Digraph graph,<span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">this</span>.Marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向前走，将绳子放下</span></span><br><span class="line">      <span class="keyword">this</span>.IsInStack[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> adjs = graph.GetAdjs(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 遇到环了</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.IsInStack[adjs[i]])</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 记录下环上的一个顶点</span></span><br><span class="line">              <span class="keyword">this</span>.CircleVertex = adjs[i];</span><br><span class="line">              <span class="keyword">this</span>.HasCirCle = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 还未访问过</span></span><br><span class="line">          <span class="keyword">if</span>(!<span class="keyword">this</span>.Marked[adjs[i]])</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">this</span>.Marked[adjs[i]] = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">this</span>.DFS(graph, adjs[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往回走，将绳子捡起来</span></span><br><span class="line">      <span class="keyword">this</span>.IsInStack[v] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasCircle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.HasCirCle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于-DFS-的顶点排序"><a href="#基于-DFS-的顶点排序" class="headerlink" title="基于 DFS 的顶点排序"></a>基于 DFS 的顶点排序</h4><p>因为图的顶点是无序的，所以排序的目的就是希望按照某种特定的顺序来访问图的顶点，这里常用的排序主要有三种：前序、后续、逆后续。排序实现的思想是在 DFS 过程中，将每个顶点保存到一个数据结构中，然后遍历该结构就能遍历图所有顶点，遍历的顺序取决于数据结构性质和顶点插入时机。</p>
<ul>
<li>前序：在递归调用之前，将顶点插入队列；</li>
<li>后续：在递归调用之后，将顶点插入队列；</li>
<li>逆后续：在递归调用之后，将顶点插入栈。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DepthFirstOrder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span>[] Marked;</span><br><span class="line">    <span class="keyword">private</span> System.Collections.Generic.Queue&lt;<span class="keyword">int</span>&gt; PreOrder;</span><br><span class="line">    <span class="keyword">private</span> System.Collections.Generic.Queue&lt;<span class="keyword">int</span>&gt; PostOrder;</span><br><span class="line">    <span class="keyword">private</span> System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt; ReversePostOrder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span>(<span class="params">Digraph graph</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Marked = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.GetVertexCount()];</span><br><span class="line">        <span class="keyword">this</span>.PreOrder = <span class="keyword">new</span> System.Collections.Generic.Queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">this</span>.PostOrder = <span class="keyword">new</span> System.Collections.Generic.Queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">this</span>.ReversePostOrder = <span class="keyword">new</span> System.Collections.Generic.Stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.GetVertexCount(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.Marked[i])</span><br><span class="line">                <span class="keyword">this</span>.DFS(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params">Digraph graph, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 前序：在递归调用之前，将顶点插入队列</span></span><br><span class="line">        PreOrder.Enqueue(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Marked[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> adjs = graph.GetAdjs(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adjs.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.Marked[adjs[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.DFS(graph, adjs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续：在递归调用之后，将顶点插入队列</span></span><br><span class="line">        PostOrder.Enqueue(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逆后续：在递归调用之后，将顶点插入栈</span></span><br><span class="line">        ReversePostOrder.Push(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">Pre</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.PreOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">Post</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.PostOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">ReversePost</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ReversePostOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>DAG 的拓扑排序为所有顶点的逆后序排列，，结合上面有向环判断和顶点排序算法，能够很容易的编写拓扑排序算法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Topological</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IEnumerable&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> hasCircle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Topological</span>(<span class="params">Digraph graph</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DirectedCircle circle = <span class="keyword">new</span> DirectedCircle(graph);</span><br><span class="line">        <span class="keyword">this</span>.hasCircle = circle.HasCircle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasCircle)</span><br><span class="line">        &#123;</span><br><span class="line">            DepthFirstOrder dfo = <span class="keyword">new</span> DepthFirstOrder(graph);</span><br><span class="line">            <span class="keyword">this</span>.order = dfo.ReversePost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">Order</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为有向无环图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsDAG</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> !hasCircle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 二叉堆</title>
    <url>/2019/03/11/Algorithm13-Heap/</url>
    <content><![CDATA[<p>在之前的<a href="https://huosk.github.io/2019/03/05/Algorithm12-RedBlackTree/">文章</a>中学习了二叉搜索树以及红黑树，它们有个共同的特点是，对于任意节点都大于它的左子节点，小于它的右子节点。</p>
<a id="more"></a>
<p>本文介绍另一种形式的二叉树 - 二叉堆，它满足以下性质：</p>
<ul>
<li>二叉堆是完全二叉树</li>
<li>对于任意节点，都大于等于（或小于等于）它的左右子节点</li>
</ul>
<p>二叉堆得根为最大值的称作大顶堆，为最小值的称作小顶堆。</p>
<p>在<a href="https://huosk.github.io/2019/01/26/algorithm06/">前文</a>介绍过树的表示方式，对于完全二叉树来说，比较适合采用数组来实现，本文中堆就是基于数组的实现，</p>
<img src="/2019/03/11/Algorithm13-Heap/Heap.png">
<p>二叉堆的根节点存储在数组第2个位置，下标为0的位置空置，那么为什么没有采用<a href="https://huosk.github.io/2019/01/26/algorithm06/">之前</a>介绍的从下标0开始呢，主要是方便父子节点下标换算，这样对于任意的节点 i：</p>
<ul>
<li>左子节点为 $2i$</li>
<li>右子节点为 $2i + 1$</li>
<li>父节点为 $i/2$</li>
</ul>
<p>如果从数组的0开始，那么对于任意的节点 i：</p>
<ul>
<li>左子节点为:$2*i+1$</li>
<li>右子节点为:$2*i+2$</li>
<li>父节点为:$\frac{i}{2}-1$</li>
</ul>
<h2 id="堆化操作"><a href="#堆化操作" class="headerlink" title="堆化操作"></a>堆化操作</h2><p>堆在进行插入、删除的过程中，为了保证堆的特性，需要进行<strong>堆化(Heapify)</strong>，堆化分为两种：</p>
<ul>
<li>自下而上的堆化(上浮)，从指定节点开始，不断向上与父节点进行比较，如果大于父节点则交换，直到小于等于父节点或到达堆顶。</li>
<li>自上而下的堆化(下沉)，从指定节点开始，不断向下与左右子节点中较大的值进行比较，如果比较大值小则交换，直到比较大值大或左右子节点不存在。</li>
</ul>
<p>上浮堆化：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自下而上进行上浮堆化</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="i"&gt;</span>其实索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Swim</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.comparer.Compare(<span class="keyword">this</span>.items[i], <span class="keyword">this</span>.items[i / <span class="number">2</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = <span class="keyword">this</span>.items[i / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">this</span>.items[i / <span class="number">2</span>] = <span class="keyword">this</span>.items[i];</span><br><span class="line">        <span class="keyword">this</span>.items[i] = temp;</span><br><span class="line"></span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下沉堆化：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自上而下进行下沉堆化</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="i"&gt;</span>起始索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sink</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i * <span class="number">2</span> &lt;= <span class="keyword">this</span>.count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到左右子节点中较大的一个</span></span><br><span class="line">        <span class="keyword">int</span> maxChild = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.comparer.Compare(<span class="keyword">this</span>.items[i * <span class="number">2</span>], <span class="keyword">this</span>.items[(i * <span class="number">2</span>) + <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxChild++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.comparer.Compare(<span class="keyword">this</span>.items[maxChild], <span class="keyword">this</span>.items[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T temp = <span class="keyword">this</span>.items[maxChild];</span><br><span class="line">        <span class="keyword">this</span>.items[maxChild] = <span class="keyword">this</span>.items[i];</span><br><span class="line">        <span class="keyword">this</span>.items[i] = temp;</span><br><span class="line"></span><br><span class="line">        i = maxChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h2><p>插入操作流程：</p>
<ol>
<li>向数组末尾插入新元素；</li>
<li>从插入位置进行上浮堆化。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">T item</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == items.Length<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 堆满了，需要动态扩容</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到数组</span></span><br><span class="line">    items[++count] = item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> check = count;</span><br><span class="line">    <span class="keyword">int</span> parent = check / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在父节点，并且比父节点大，则交换位置</span></span><br><span class="line">    <span class="keyword">while</span>(parent &gt; <span class="number">0</span> &amp;&amp; comparer.Compare(items[check],items[parent]) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = items[parent];</span><br><span class="line">        items[parent] = items[check];</span><br><span class="line">        items[check] = temp;</span><br><span class="line"></span><br><span class="line">        check = parent;</span><br><span class="line">        parent = parent / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h2><p>这里只介绍删除堆顶元素，删除的流程是这样的：</p>
<ol>
<li>将堆顶元素与最后一个元素进行交换；</li>
<li>删除最后一个元素；</li>
<li>自对顶开始进行下沉堆化。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMax</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将堆顶元素交换到最后一个位置</span></span><br><span class="line">   items[<span class="number">1</span>] = items[count];</span><br><span class="line">   items[count--] = <span class="keyword">default</span>(T);</span><br><span class="line"></span><br><span class="line">   Sink(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>之前文章介绍了冒泡、选择、插入、快排等排序算法，这里再介绍一种新的排序算法 - 堆排序，它的时间复杂度和快排、归并排序相同，都为$O(n{\log}n)$。</p>
<p>堆排序分为两个阶段：构造堆、下沉排序。</p>
<h3 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h3><p>构造堆有两种方式：上浮构造、下沉构造</p>
<p>上浮构造的实现思路是这样的，将数组划分两个分区：堆有序区、待插入区，遍历待插入区将所有元素插入到堆有序区中。</p>
<p>下沉构造的实现思路也是将数组划分为两个区：堆有序区、待插入区，与上浮不同的是，下沉是从下往上进行插入，这样做的好处是，下沉过程中，最下面一层的叶子节点没有子结点，所以不需要进行比较，因此比上浮的效率要高一点。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">BuildHeap</span>(<span class="params"><span class="keyword">int</span>[] n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = n.Length;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>; i &gt;= <span class="number">1</span>;--i)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 下沉</span></span><br><span class="line">       <span class="keyword">int</span> node = i;</span><br><span class="line">       <span class="keyword">while</span>(i * <span class="number">2</span> &lt; length)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> maxChild = i * <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (n[maxChild] &lt; n[maxChild + <span class="number">1</span>])</span><br><span class="line">               maxChild++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (n[node] &gt; n[maxChild])</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> temp = n[node];</span><br><span class="line">           n[node] = n[maxChild];</span><br><span class="line">           n[maxChild] = temp;</span><br><span class="line"></span><br><span class="line">           i = maxChild;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>在堆构造完成之后，形成一个大顶堆，即数组的第一个元素为最大的值，排序流程是这样：</p>
<ol>
<li>从数组末尾开始遍历；</li>
<li>将元素与堆顶元素交换；</li>
<li>从堆顶开始向下进行下沉堆化。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params"><span class="keyword">int</span>[] heap</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> N = heap.Length - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> node = i;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxValue = heap[<span class="number">1</span>];</span><br><span class="line">       heap[<span class="number">1</span>] = heap[node];</span><br><span class="line">       heap[node] = maxValue;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(node * <span class="number">2</span> &lt; i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> maxChild = node * <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (maxChild + <span class="number">1</span> &lt; i &amp;&amp; heap[maxChild] &lt; heap[maxChild + <span class="number">1</span>])</span><br><span class="line">               maxChild++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (heap[node] &gt; heap[maxChild])</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> temp = heap[node];</span><br><span class="line">           heap[node] = heap[maxChild];</span><br><span class="line">           heap[maxChild] = temp;</span><br><span class="line"></span><br><span class="line">           node = maxChild;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序性能"><a href="#堆排序性能" class="headerlink" title="堆排序性能"></a>堆排序性能</h2><p>堆排序的两个过程中，只需要常量的内存空间，空间复杂度为：$O(0)$。<br>时间复杂度为：$O(n\log{n})$<br>堆排序中存在头尾元素的交换，因此为不稳定排序。</p>
<h2 id="堆排序和快速排序对比"><a href="#堆排序和快速排序对比" class="headerlink" title="堆排序和快速排序对比"></a>堆排序和快速排序对比</h2><p>堆排序和快速排序的时间复杂度都为$O(n\log{n})$，空间复杂度为:$O(0)$，都为不稳定排序。那为什么多数语言排序都采用快速排序呢，主要有两方面原因：</p>
<ol>
<li>堆排序中的下沉操作要根据父节点访问子结点，这是一个非连续的内存访问，不利于内存缓存；</li>
<li>对于相同规模的数据，堆排序数据交换的次数要比快速排序多。</li>
</ol>
<h2 id="堆得应用"><a href="#堆得应用" class="headerlink" title="堆得应用"></a>堆得应用</h2><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列也是队列的一种，与普通队列不同的是，出队的顺序按照优先级进行，优先级最高的最先出队，有多种方法来实现优先级队列，但是用的最多的还是堆，因为最小/最大的元素总是在堆顶，并且堆得插入、删除都非常的高效。优先级队列的应用非常多，比如霍夫曼编码、图的最短路径、最小生成树等等。</p>
<h3 id="计算-TopK-问题"><a href="#计算-TopK-问题" class="headerlink" title="计算 TopK 问题"></a>计算 TopK 问题</h3><p>TopK 问题就是从一组数据里面选出最靠前的 K 个值，利用小顶堆可以非常容易的解决这个问题，解决流程是这样的：</p>
<ol>
<li>创建一个大小为 K 小顶堆；</li>
<li>遍历数据集合，将元素与堆顶元素进行比较；</li>
<li>如果比堆顶值大，则将堆顶元素删除，然后将新元素插入到堆中；如果比堆顶值小，则继续遍历；</li>
<li>遍历完成之后，堆中的元素就是 TopK 元素。</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetTopK</span><span class="params">(items)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Heap h = new Heap();</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> items</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; h.Top</span><br><span class="line">        &#123;</span><br><span class="line">            h.RemoveMin();</span><br><span class="line">            h.Insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面说的流程只针对静态集合，如果是支持插入删除的动态集合，那么就需要在插入时，将目标元素按照上述流程进行检测；如果时删除元素时，同样需要将之从小顶堆中删除。</p>
</blockquote>
<h3 id="计算中位数"><a href="#计算中位数" class="headerlink" title="计算中位数"></a>计算中位数</h3><p>中位数就是集合中间的那个数，对于规模为 n 的有序集合，如果 n 为奇数，则中位数为 $\frac{n}{2}+1$；如果 n 为偶数，中间位置有两个数，$\frac{n}{2}$、$\frac{n}{2}+1$，此时中位数可以是这两个中的任意一个。</p>
<p>首先分析一下中位数的特点：</p>
<ul>
<li>中位数将集合分为两个部分，在前半部分中最小，在后半部分中最大；</li>
<li>前后两部分元素数量上是确定的。</li>
</ul>
<p>如何用堆来解决中位数问题呢，使用两个堆来实现两个分区，小顶堆表示前半部分，大顶堆表示后半部分。集合个数为偶数时，小顶堆、大顶堆元素数量都为 $\frac{n}{2}$；集合个数为奇数时，小顶堆元素数量为 $\frac{n}{2}$，大顶堆元素数量为 $\frac{n}{2}+1$。</p>
<p>具体的处理流程如下：</p>
<ol>
<li>创建小顶堆(前半部分) $H<em>{min}$、大顶堆(后半部分) $H</em>{max}$；</li>
<li>遍历集合元素，如果大于等于$H<em>{min}$堆顶元素，则插入到$H</em>{min}$中，否则插入到$H_{max}$中；</li>
<li>比较两个堆，是否满足元素数量上的要求，如果不满足，通过移动堆顶元素，来达到要求；</li>
<li>最终两个堆顶即为所求中位数。</li>
</ol>
<blockquote>
<p>其实不只是中位数，只要是满足中位数两个特点的问题（分两个区、每个区元素数量确定，求分界点），都可以采用上述思路来解决，比如计算 1/3、1/4 位置处的元素。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2019/03/11/Algorithm13-Heap/Summary.png">]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 红黑树</title>
    <url>/2019/03/05/Algorithm12-RedBlackTree/</url>
    <content><![CDATA[<h1 id="数据结构与算法-红黑树"><a href="#数据结构与算法-红黑树" class="headerlink" title="数据结构与算法 - 红黑树"></a>数据结构与算法 - 红黑树</h1><p>前面已经学习了跳表、散列表，它们的插入、删除、查找等操作是非常高效的，本章再介绍最后一种数据结构 - 红黑树，红黑树是二叉搜索树的改进，所以在介绍红黑树之前，先简单简单介绍一下二叉搜索树。</p>
<a id="more"></a>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>在之前的文章介绍了<a href="https://huosk.github.io/2019/01/26/algorithm06/">有根树的表示</a>，其中介绍了有根树的两种表示方法，<strong>父子节点表示法</strong>和<strong>左孩子右兄弟表示法</strong>，对于二叉树的表示来说，这两种方式都可以，本节采用第一种表示方式，对其他方式感兴趣的可以参考<a href="https://huosk.github.io/2019/01/26/algorithm06/">前文</a>。</p>
<h3 id="二叉搜索树的特点"><a href="#二叉搜索树的特点" class="headerlink" title="二叉搜索树的特点"></a>二叉搜索树的特点</h3><p>在之前介绍过二分查找算法，它是一种基于数组的非常高效的查找算法，最坏情况时间复杂度为$O(\log{n})$，本质上二叉搜索树也是二分思想的一种应用，它通过树的形式，使得二分更加的具象化：以当前节点为中点，分出左右两个子分支。</p>
<p>在二叉搜索树中，对于任一节点，具备如下特点：</p>
<ul>
<li>它的值<em>大于</em>左子树所有节点</li>
<li>它的值<em>小于</em>右子树所有节点</li>
</ul>
<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><p>根据二叉搜索树的特点，当需要插入一个新节点时，从根节点开始遍历，和节点值进行比较，如果大于节点的值，则递归检查右子节点；如果小于节点的值，则递归检查左子节点；如果与节点的值相等，一般有几种处理方式：</p>
<ul>
<li>插入失败，停止插入数据。</li>
<li>当做大于节点处理，插入右子树中。</li>
<li>当做小于节点处理，插入左子树中。</li>
</ul>
<p>在使用时要根据自己的实际需求，选择适当的插入策略，并且其他操作（查找、删除）也都要遵守这种策略。在下面代码实现中，采取第二种策略，即插入到右子树中。</p>
<p>插入代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> BinaryTreeNode()</span><br><span class="line">        &#123;</span><br><span class="line">            data = t</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode node = tree;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparer.Compare(node.data, t) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.leftChild == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node.leftChild = <span class="keyword">new</span> BinaryTreeNode()</span><br><span class="line">                &#123;</span><br><span class="line">                    data = t</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.rightChild == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node.rightChild = <span class="keyword">new</span> BinaryTreeNode()</span><br><span class="line">                &#123;</span><br><span class="line">                    data = t</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面实现可以看出，<strong>新插入的节点，总是二叉树的叶节点。</strong></p>
<h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><p>和新插入的节点总是叶节点不同，删除的节点可能在二叉树的任何位置，在删除节点之后，还必须保持二叉搜索树的特性，因此删除操作稍微有点麻烦，根据要删除节点的孩子节点数量，分为下面三种情况：</p>
<ul>
<li>没有任何子节点，此时不需要额外操作</li>
<li>有一个子节点（左或者右），将要删除的节点的父节点指向子节点</li>
<li>有两个子节点，找到右子树的最小节点，将父节点指向该节点。</li>
</ul>
<p>前两种情况比较容易理解，稍微解释一下第三种情况，二叉搜索树特性换一种理解方式：任一节点都是左右子树的分界点，因此当删除该节点时，就需要从剩余的子节点中，重新选取新的分界点，而所有的右子树结点都大于左子树结点，所以只需要从右子树中选取最小节点作为新分界点即可。（或从左子树选择最大的节点）</p>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode node = tree;         <span class="comment">// 要删除的节点</span></span><br><span class="line">    BinaryTreeNode nodeParent = <span class="literal">null</span>;   <span class="comment">// 要删除结点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> comp = comparer.Compare(t, node.data);</span><br><span class="line">        <span class="keyword">if</span> (comp &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">// t &lt; node.data</span></span><br><span class="line">            nodeParent = node;</span><br><span class="line">            node = node.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">// t &gt; node.data</span></span><br><span class="line">            nodeParent = node;</span><br><span class="line">            node = node.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">// t == node.data</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;<span class="comment">// 没要找到要删除的节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.leftChild != <span class="literal">null</span> &amp;&amp; node.rightChild != <span class="literal">null</span>)</span><br><span class="line">    &#123;<span class="comment">// 左右子结点都存在</span></span><br><span class="line">        BinaryTreeNode minNode = node.rightChild;</span><br><span class="line">        BinaryTreeNode minNodeParent = node;</span><br><span class="line">        <span class="keyword">while</span> (minNode.leftChild != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              comparer.Compare(minNode.leftChild.data, minNode.data) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minNodeParent = minNode;</span><br><span class="line">            minNode = minNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        node.data = minNode.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为此时 minNode 的卫星数据已经替换了要删除的节点，相当于</span></span><br><span class="line">        <span class="comment">// 要删除的几点与 minNode 互换了位置，因此只需要删除 minNode 即可</span></span><br><span class="line">        <span class="keyword">if</span> (minNodeParent.leftChild == minNode) minNodeParent.leftChild = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> minNodeParent.rightChild = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 只有一个子结点，或者没有子结点</span></span><br><span class="line">        BinaryTreeNode child = node.leftChild ?? node.rightChild;</span><br><span class="line">        <span class="keyword">if</span> (nodeParent == <span class="literal">null</span>)</span><br><span class="line">        &#123;<span class="comment">// 要删除的为根节点</span></span><br><span class="line">            tree = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeParent.leftChild == node)</span><br><span class="line">            &#123;</span><br><span class="line">                nodeParent.leftChild = child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nodeParent.rightChild = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的查找"><a href="#二叉搜索树的查找" class="headerlink" title="二叉搜索树的查找"></a>二叉搜索树的查找</h3><p>在理解上面的插入和删除之后，查找就很容易实现了，不过需要注意的是，遍历的策略要和插入时一致，直接上代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">FindNode</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode node = tree;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> comp = comparer.Compare(t, node.data);</span><br><span class="line">        <span class="keyword">if</span> (comp &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与有序数组互转"><a href="#二叉搜索树与有序数组互转" class="headerlink" title="二叉搜索树与有序数组互转"></a>二叉搜索树与有序数组互转</h3><p>将有序数组转为高度平衡二叉搜索树，高度平衡二叉搜索树左右子节点的高度相差不大于1，这里就不能使用上面的插入算法了，因为对于升序排列的数组，按照上面插入实现，结果必然是一个全为右子节点的链表。</p>
<p>具体实现思想是这样的，因为二叉树搜索树的每个节点都是它左右子树的中点，因此利用二分思想，不断的取出数组的中点，作为数的下一个节点，代码实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">SortedArrayToBST</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SortedArrayToBST(nums,<span class="number">0</span>,nums.Length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">SortedArrayToBST</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[left]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(right &lt; left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    node.left = SortedArrayToBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = SortedArrayToBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将二叉搜索树转换为有序数组实现就相对简单一些，只需要中序遍历结点即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;<span class="keyword">int</span>&gt; <span class="title">BSTToSortedArray</span>(<span class="params">TreeNode node</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    InOrder(node,(n)=&gt;list.Add(n.val));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InOrder</span>(<span class="params">TreeNode node,Action&lt;TreeNode&gt; visitor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    InOrder(node.left,visitor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(visitor != <span class="literal">null</span>)</span><br><span class="line">        visitor(node);</span><br><span class="line"></span><br><span class="line">    InOrder(node.right,visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树性能分析"><a href="#二叉搜索树性能分析" class="headerlink" title="二叉搜索树性能分析"></a>二叉搜索树性能分析</h3><p>随着新节点的插入，会形成各种形状的树，其中最极端的两种情况是：</p>
<ul>
<li>最好情况是完全二叉树或满二叉树，此时搜索次数等于根节点的高度，时间复杂度为O(log(n))</li>
<li>最坏情况是退化成链表，如下图所示，时间复杂度为O(n)</li>
</ul>
<img src="/2019/03/05/Algorithm12-RedBlackTree/list.png">
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>既然二叉树的插入、删除会造成二叉查找的退化，那么是否能够对二叉搜索树进行改进呢，因此就有了平衡二叉树，平衡二叉树需要保证随着插入、删除操作，都能够保持树的平衡，不会造成性能退化，能在O(logn)时间内完成插入、删除、查找操作，。平衡二叉树的形式多种多样，最早发明的平衡二叉树为 <a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">AVL 树</a>，但目前用的最多的还是<strong>红黑树</strong>，C# 中的 SortedSet 类就是基于红黑树的有序列表。</p>
<p>平衡二叉树的严格定义是这样：<strong>对于树的任一节点，其左右子树的高度相差不超过1</strong>。</p>
<p>实际上很多平衡二叉树并不是严格遵循定义的，比如下面要介绍的红黑树，发明平衡二叉树的初衷是解决二叉搜索树退化问题的，因此只要能够保证时间复杂度不退化，就是满足需求的平衡二叉树。</p>
<h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><p>红黑树的原理理解起来不太容易，为了能够更好的理解红黑树，这里先介绍另一种平衡二叉树结构，叫做2-3树，在理解了2-3树的原理之后，就能够很容易红黑树了。</p>
<h3 id="2-3查找树定义"><a href="#2-3查找树定义" class="headerlink" title="2-3查找树定义"></a>2-3查找树定义</h3><p>一颗2-3查找树或者是一颗空树，或者包含如下节点：</p>
<p>2-节点：该节点内包含 1 个键值、2个子节点，左子树所有节点都小于该节点，右子树所有节点都大于该节点。（与二叉搜索树节点一致）<br>3-节点：该节点内包含 2 个键值、3个子节点，左子树所有节点都小于该节点，右子树所有节点都大于该节点，中子数所有节点的值都在 2 个键值之间。<br>4-节点：该节点内包含 3 个键值、4个子节点，3个键值划分出4个区间，每个子节点对应一个区间，4-节点通常分解为2个2-节点，通过下图可以看出，4-节点分解之后，形成一个完全二叉树，并且根节点高度增长了1，2-3树就是通过这种方式来实现生长的。</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/4NodeParse.png">
<p>下图是一颗2-3查找树：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3Tree.png">
<p>因为2-3查找树只是为了方便理解红黑树，所以这里只介绍它的相关原理，并不做具体的代码实现了。</p>
<h3 id="2-3查找树的查找"><a href="#2-3查找树的查找" class="headerlink" title="2-3查找树的查找"></a>2-3查找树的查找</h3><p>它的查找从根节点开始，按照如下过程进行查找：</p>
<ol>
<li>与结点的键值对比，如果相等，则返回该节点</li>
<li>如果小于键值区间，则递归查找左子节点</li>
<li>如果处于键值区间，则递归查找中子节点</li>
<li>如果大于键值区间，则递归查找右子节点</li>
</ol>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3Tree_Search.png">
<h3 id="2-3查找树的插入"><a href="#2-3查找树的插入" class="headerlink" title="2-3查找树的插入"></a>2-3查找树的插入</h3><p>因为2-3查找树要保持其平衡性，要比二叉搜索树插入复杂一些，流程大致如下：</p>
<ol>
<li>首先找到新节点插入位置，这里和二叉搜索树类似，最终在树的底部找到插入的父节点，这个过程是自上而下的查找。</li>
<li>在找到父节点之后，根据父节点种类的不同，需要不同的插入方式。</li>
</ol>
<p>根据父节点的种类，可以分为以下几种情况：</p>
<ul>
<li>A:向2-节点插入，将2-节点转化为3-节点，并将新键保存到3-节点中</li>
<li>B:向3-节点插入，此时根据父节点类型不同，又分为三种情况：<ul>
<li>B1:没有父节点(为根节点)，将3-节点转换为4-节点(由2个2-节点表示)。</li>
<li>B2:父节点为2-节点：将3-节点转换为4-节点，然后取出中键，将父节点转换成3-节点，该节点的中、右子树指向4-节点的左右子树（不存在中树了，因为中键取出了）。</li>
<li>B3:父节点为3-节点：<ol>
<li>同样先将3-节点转换为4-节点并分解。</li>
<li>然后并将中键插入到父节点中，但是父节点也是3-节点，在对该父节点重复步骤1，直到父节点为2-节点，此时处理方式同 B2。</li>
<li>如果直到树的根节点都是3-节点，此时向根节点插入，处理方式同 B1。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>向父节点为2-节点的3-节点中插入数据：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3Tree_Insert.png">
<p>向父节点为3-节点的3-节点中插入数据：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3Tree_Insert2.png">
<h3 id="2-3查找树的性能"><a href="#2-3查找树的性能" class="headerlink" title="2-3查找树的性能"></a>2-3查找树的性能</h3><p>2-3树性能主要体现在两点 ：</p>
<ul>
<li>局部变换：将4-节点分解时，只影响其相邻的几个节点，而树的其他节点不需要做检查和调整。</li>
<li>全局特性：局部变换不会影响树的有序性和平衡性。</li>
<li>自平衡性：与二叉搜索树的自根向叶节点的生长不同，2-3树是自叶节点向根节点的生长，能够始终保持完美平衡。</li>
</ul>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3Tree_BadSit.png">
<p>按照降序插入数据，在二叉搜索树中将会退化成链表，但是2-3树最终形成一颗完全二叉树。</p>
<p>其实在2-3树种进行插入、删除操作，能够始终保持完美平衡，因此，<strong>在一颗大小为 n 的2-3树种，查找和插入操作访问的节点个数必然不会超过$\lg{n}$个，即最坏情况的时间复杂度为$O(\lg{n})$。</strong></p>
<h3 id="2-3查找树的实现"><a href="#2-3查找树的实现" class="headerlink" title="2-3查找树的实现"></a>2-3查找树的实现</h3><p>既然2-3查找树能够实现完美平衡，那么为什么在实际中却很少使用过呢，原因主要有一下几方面：</p>
<ul>
<li>需要维护多种节点类型，以及节点之间的转换、键值复制，会造成额外的性能开销，在节点较少时，性能可能比二叉搜索树还要慢。</li>
<li>实现不方便，需要处理的情况太多，代码不容易维护。</li>
</ul>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>在理解了2-3树的原理之后，再来理解红黑树就会容易很多，概括来说：<strong>红黑树是用标准二叉查找树（和颜色信息）来表示2-3树</strong>。为了实现这种表示，需要将2-3树的节点替换成二叉节点，2-节点不需要额外处理，因为它本身就是二叉节点，只需要对3-节点进行替换，替换方式是这样的：将3-节点表示为由一条左斜的红色链接相连的两个2-节点。</p>
<p>另外一种等价的定义是这样的：</p>
<p>红黑树是含有红黑链接，并满足以下条件的二叉查找树：</p>
<ul>
<li>红链接均为左链接（右子节点不能为红链接）。</li>
<li>没有任何一个节点同时和两条红链接相连（节点与父节点链接、节点与左子节点链接，不能同时为红链接）。</li>
<li>该树是完美黑色平衡的，即任意叶子节点到根节点的路径上的黑链接数量相同。</li>
</ul>
<p>满足这样定义的红黑树与2-3树是一一对应的（如果没有这些约束，3-节点就会有多种表示方式，一颗2-3树可能对应多种红黑树表示），对应转换关系如下图：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/2-3TreeToRedBlackBST.png">
<h3 id="红黑树节点定义"><a href="#红黑树节点定义" class="headerlink" title="红黑树节点定义"></a>红黑树节点定义</h3><p>因为每个节点只有一个父节点，因此可以将<strong>与父节点的链接颜色</strong>，存储到该节点当中，通过设置一个布尔值 isRed 指示节点与父节点链接的颜色，isRed = true 表示红链接，反之为黑链接，并且<strong>规定空链接为黑色（即根节点为黑色）</strong>，节点定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">public class RedBlackTree&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">bool</span> IsRed;</span><br><span class="line">        <span class="keyword">public</span> Node Left;</span><br><span class="line">        <span class="keyword">public</span> Node Right;</span><br><span class="line">        <span class="keyword">public</span> T Item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h3><p>当红黑树进行插入、删除时，有可能遇到红色的右链接、两个连续的红链接等不符合红黑树约束的情况，此时就需要利用旋转进行维护，以保持其有序性和完美平衡性。通过下图和代码理解一下旋转的具体实现。（最好是自己能够画一下这个过程，加深理解）</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/RedBlackBSP_Rotate.png">
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">RotateLeft</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node x = h.Right;</span><br><span class="line">    h.Right = x.Left;</span><br><span class="line">    x.Left = h;</span><br><span class="line">    x.IsRed = h.IsRed;</span><br><span class="line">    h.IsRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">RotateRight</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node x = h.Left;</span><br><span class="line">    h.Left = x.Right;</span><br><span class="line">    x.Right = h;</span><br><span class="line">    x.IsRed = h.IsRed;</span><br><span class="line">    h.IsRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>用二叉搜索树的方式，向红黑树中插入新的键值，会在底部增加一个新的叶节点，<strong>并且新节点与父节点的链接总是红链接</strong>。红黑树和2-3树是一一对应的，插入可以原理也是相同的，只需要将2-3树的节点分解为红黑节点，就能完成红黑树的插入，下面按照2-3树的插入情形分类，来看看红黑树是如何与2-3树一一对应的。</p>
<ul>
<li>A:向2-节点插入新键，将2-节点转换为3-节点。<ul>
<li>A1:如果插入到左子结点，不需要额外处理。</li>
<li>A2:如果插入到右子节点，产生了红色右链接，所以需要坐旋转。</li>
</ul>
</li>
<li>B:向3-节点插入新键，根据新键所在区间，分为以下三种情况<ul>
<li>B1:大于3-节点的两个键，插入到右子结点，插入之后形成左右两个红链接，此时需要将两个红链接变为黑色链接。</li>
<li>B2:小于3-节点的两个键，插入到左子结点，插入之后形成两个连续红链接，此时只需右旋转即可得到 B1 情况。</li>
<li>B3:介于两个键值之间，插入到中子结点，插入后形成两个连续红链接，一条红色左链接和一条红色右链接，此时只需左旋转红色右链接即可得到 B2 情况。</li>
</ul>
</li>
</ul>
<p>红黑树中向3-节点插入新键，与2-3树中3-节点插入新键的处理方式是类似的，最终都是形成一颗完全二叉树，只不过2-3树利用4-节点的分解来实现，而红黑树中采用旋转和颜色转换，虽然形式上略有区别，但是目的是一致的。</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/RedBlackBSP_3NodeInsert.png">
<p>在上图中可以看到，最后一步处理都是颜色转换，需要将节点左右两个红链接转换为黑链接，同时还需要节点的与其父节点的链接转为红链接(这就等价于2-3树插入中，4-节点分解时，将上层2-节点转换为3-节点、3-节点转换为4节点)，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlipColor</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h.IsRed = !h.IsRed;</span><br><span class="line">    h.Left.IsRed = !h.Left.IsRed;</span><br><span class="line">    h.Right.IsRed = !h.Right.IsRed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然颜色转换会修改父节点的链接颜色，那么就可能造成父节点不符合红黑树约束，因此需要继续向上转换父节点，所以这是一个从新插入节点到根节点的递归过程，对于每个节点，只要按照如下顺序进行检查，就能保证插入后与2-3树的一一对应关系(和2-3插入相同，都是自下而上分解4-节点的过程)：</p>
<ol>
<li>右子节点为红色、左子结点为黑色，进行左旋转。</li>
<li>左子节点为红色、左子节点的左子节点也为红色，进行右旋转。</li>
<li>左子节点、右子节点都为红色，进行颜色转换。</li>
</ol>
<p>为什么是这么一个检查顺序，其实这就是上面 B3 情况的处理流程，从“3-节点插入”图中可以看出，B1 是 B2 的子集、B2 是 B3 的子集，因此只需要按照 B3 的流程进行<strong>检查处理</strong>，就能够完成B1、B2 的检查处理。</p>
<p>最后，需要注意的是，在进行颜色转换时，对于<strong>根节点，要始终保持黑色</strong>，这是因为红链接表示3-节点的左子链接，而根节点没有父节点，所以不能表示为红链接。</p>
<p>以下是插入的实现代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   tree = InsertInternal(tree, t);</span><br><span class="line">   tree.IsRed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">InsertInternal</span>(<span class="params">Node h, T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Node(t)</span><br><span class="line">       &#123;</span><br><span class="line">           IsRed = <span class="literal">true</span></span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> comp = <span class="keyword">this</span>.comparer.Compare(t, h.Item);</span><br><span class="line">   <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) h.Left = InsertInternal(h.Left, t);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) h.Right = InsertInternal(h.Right, t);</span><br><span class="line">   <span class="keyword">else</span> h.Item = t;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (h.Right.IsRed &amp;&amp; !h.Left.IsRed) h = RotateLeft(h);</span><br><span class="line">   <span class="keyword">if</span> (h.Left.IsRed &amp;&amp; h.Left.Left.IsRed) h = RotateRight(h);</span><br><span class="line">   <span class="keyword">if</span> (h.Left.IsRed &amp;&amp; h.Right.IsRed) FlipColor(h);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>虽然红黑树的插入已经很复杂了，但是红黑树的删除更加麻烦，因为它不仅需要在（为了删除结点而）构造临时4-节点时沿着查找路径向下进行变换，还要在分解遗留4-结点时沿着查找路径向上进行变换（同插入操作）。</p>
<p>下面先从比较简单删除最小值开始，一步步了解如何实现红黑树的删除操作。</p>
<h4 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h4><p>因为最小值只可能在树的底部，并且是左链接，因此，先自上而下遍历初步调整左链接，这个过程是为了保证最终要删除的节点不是2-节点（2-节点删除会破坏整棵树的完美平衡性）；再自下而上的进行平衡调整。</p>
<p>首先是自上而下进行左子节点遍历，作用是将节点调整为非2-节点，可能会遇到以下几种情况：</p>
<ol>
<li>在根节点：<ol>
<li>根节点及其左右子节点都是2-节点，合并为4-节点。</li>
<li>否则需要保证根节点的左子节点不为2-节点，可以从右侧兄弟节点借一个键来。</li>
</ol>
</li>
<li>其他非根节点：<ol>
<li>如果左子节点不是2-节点，不需要额外处理。</li>
<li>如果左子节点是2-节点，且它的兄弟节点不是2-节点，将兄弟节点中的一个键移动到左子节点中。</li>
<li>如果左子节点和兄弟节点都是2-节点，将左子节点、兄弟节点、父节点中的最小键合并为4-节点。</li>
</ol>
</li>
</ol>
<p>要将上述过程转换为代码，需要解决几个问题：</p>
<ol>
<li>如何判断 h 节点的左子节点为2-节点</li>
<li>如何实现将 h 节点的左子节点的兄弟节点的一个键转移到左子节点中</li>
<li>如何将 h 节点的左子节点、兄弟节点、h节点中的最小键合并为4-节点</li>
</ol>
<p>为了解决上面的问题，我们需要在回忆一下2-节点、3-节点、4-节点在红黑树中怎么表示，有一点需要注意，在下图中可以看到4-节点存在两个连续的红链接，这与红黑树的特性是违背的，但是因为这个4-节点只是临时存在，在进行自下而上的平衡调整时，就会消除这个问题，因此在转换4-节点是允许不满足红黑树特性的4-节点。</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/234Node.png">
<p>在清楚3-节点、4-节点如何表示之后，第一个问题就非常容易解决了，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断节点 h 的左子节点是否为2节点：</span></span><br><span class="line"><span class="comment">// 如果 左子链接为红链接，那么左子节点和 h 构成了 3-节点</span></span><br><span class="line"><span class="comment">// 如果 左孙子链接为红链接，那么左子节点和左孙子节点构成了 3-节点</span></span><br><span class="line"><span class="comment">// 如果 左子链接、左孙子链接都为红链接，那么 h节点、左子节点、左孙子节点构成了4-节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此节点 h 左子节点为2-节点的条件是：</span></span><br><span class="line"><span class="keyword">if</span>(!h.Left.IsRed &amp;&amp; !h.Left.Left.IsRed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// h 左子节点为 2-节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个问题解决起来比较麻烦，需要依次经过”颜色转换-右旋转右子节点-左旋转节点-颜色转换“，通过下面示例图来理解一下：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/MoveRedLeft.png">
<p>第三个问题稍微容易一些，因为自上向下处理过程中，能够确保 h 节点不是2-节点，因此解决问题3只需要将颜色进行转换，即可得到一个左右红链接的4-节点。这里需要再次强调一下，4-节点是自上而下调整过程中产生的临时节点，会在自下而上分解平衡的过程中进行消除，因此并不会影响红黑树的特性，合并过程如下图：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/CombineToLeft.png">
<p>在解决了上面三个问题之后，代码实现起来就容易多了，直接上代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左子节点红链接 或 左孙子节点红链接表示3-节点</span></span><br><span class="line"><span class="comment">// 左子节点、左孙子节点都为红表示4-节点</span></span><br><span class="line"><span class="comment">// 左子节点、左孙子节点都不为红表示2-节点</span></span><br><span class="line"><span class="keyword">if</span> (!h.Left.IsRed &amp;&amp; !h.Left.Left.IsRed)</span><br><span class="line">&#123;</span><br><span class="line">    MoveRedToLeft(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">MoveRedToLeft</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FlipColor(h);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断 h 右子节点是否为 3-节点 或 4-节点</span></span><br><span class="line">   <span class="keyword">if</span> (h.Right != <span class="literal">null</span> &amp;&amp; h.Right.Left != <span class="literal">null</span> &amp;&amp; h.Right.IsRed)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 右子节点3-节点 或 4-节点，将右子节点的键移到左子节点中</span></span><br><span class="line">       h.Right = RotateRight(h.Right);</span><br><span class="line">       h = RotateLeft(h);</span><br><span class="line">       FlipColor(h);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍解释下上面代码，因为第二问题和第三个问题的解决方法，第一个步骤是相同的，区别部分在于右子节点非2-节点时，可以将右子节点的键转移到左子节点中，因此有了上面代码的第二个 if 判断。</p>
<p>在自上而下调整完毕之后，需要接着进行自下而上的分解调整时产生的4-节点，这里和插入时的分解4-节点非常类似，平衡代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">Blance</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (h.Right.IsRed) h = RotateLeft(h);</span><br><span class="line">   <span class="keyword">if</span> (h.Left.IsRed &amp;&amp; h.Left.Left.IsRed) RotateRight(h);</span><br><span class="line">   <span class="keyword">if</span> (h.Left.IsRed &amp;&amp; h.Right.IsRed) FlipColor(h);</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后完整的删除最小值代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (tree == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 因为自上而下遍历过程中，能够保证左子节点非2-节</span></span><br><span class="line">   <span class="comment">// 因此左子节点与父节点的链接为红链接，为了递归中统一</span></span><br><span class="line">   <span class="comment">// 处理，如果根节点非2-节点，将根节点也设置为红色。</span></span><br><span class="line">    <span class="keyword">if</span> (!tree.Left.IsRed &amp;&amp; !tree.Right.IsRed)</span><br><span class="line">        tree.IsRed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   tree = RemoveMinInternal(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 删除最小值的递归函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>删除最小值后的左子树根<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="h"&gt;</span>需要删除左子树中最小值的节点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RemoveMinInternal</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (h.Left == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 左子节点红链接 或 左孙子节点红链接表示3-节点</span></span><br><span class="line">   <span class="comment">// 左子节点、左孙子节点都为红表示4-节点</span></span><br><span class="line">   <span class="comment">// 左子节点、左孙子节点都不为红表示2-节点</span></span><br><span class="line">   <span class="keyword">if</span> (!h.Left.IsRed &amp;&amp; !h.Left.Left.IsRed)</span><br><span class="line">   &#123;</span><br><span class="line">       h = MoveRedToLeft(h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 继续自上而下递归调整</span></span><br><span class="line">   h.Left = RemoveMinInternal(h.Left);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始自下而上进行分解4-节点，平衡红黑树</span></span><br><span class="line">   <span class="keyword">return</span> Blance(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除最大值"><a href="#删除最大值" class="headerlink" title="删除最大值"></a>删除最大值</h4><p>在理解最小值的删除之后，最大值的删除与之类似，同样首先需要自上而下的进行调整，然后再自下而上进行回溯，分解创建的4-节点，以保持红黑树的特性。</p>
<p>与删除最小值不同，因为最大值在底层的右子节点，所以需要保证右子节点不为2-节点，因此也会有以下几种情况：</p>
<ol>
<li>如果节点的右子节点不为2-节点，则不需要额外处理。</li>
<li>如果节点的右子节点是2-节点，左子节点不是2-节点，则将左侧的键移到右子节点，构成3-节点</li>
<li>如果节点的在右子节点、左子节点都为2-节点，则将左子节点、右子节点、父节点组合成一个四节点。</li>
</ol>
<p>第1、3和删除最小值类似，重点说一下第2种情况，在向下遍历路径上的节点 h 转换流程：“颜色转换-右旋转-颜色转换”，如下图所示：</p>
<img src="/2019/03/05/Algorithm12-RedBlackTree/MoveRedRight.png">
<p>自下而上的消除4-节点的方式是相同的，直接给出删除最大值的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMax</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (tree == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!tree.Left.IsRed &amp;&amp; !tree.Right.IsRed)</span><br><span class="line">       tree.IsRed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   tree = RemoveMaxInternal(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RemoveMaxInternal</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为左链接可以为红链接，所以可以直接将</span></span><br><span class="line">    <span class="comment">// 左链接的红链接旋转到右链接，使得右子节点变成3-节点或4-节点</span></span><br><span class="line">    <span class="keyword">if</span> (h.Left.IsRed)</span><br><span class="line">       h = RotateRight(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h.Right == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点为2-节点</span></span><br><span class="line">    <span class="keyword">if</span>(!h.Left.IsRed &amp;&amp; !h.Right.IsRed)</span><br><span class="line">    &#123;</span><br><span class="line">       h = MoveRedToRight(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.Right = RemoveMaxInternal(h.Right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Blance(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">MoveRedToRight</span>(<span class="params">Node h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FlipColor(h);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断左侧子节点是否非2-节点（3-节点、4-节点）</span></span><br><span class="line">   <span class="keyword">if</span>(h.Left != <span class="literal">null</span> &amp;&amp; h.Left.Left != <span class="literal">null</span> &amp;&amp; h.Left.Left.IsRed)</span><br><span class="line">   &#123;</span><br><span class="line">       h = RotateRight(h);</span><br><span class="line">       FlipColor(h);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除任意值"><a href="#删除任意值" class="headerlink" title="删除任意值"></a>删除任意值</h4><p>在理解了最小值和最大值的删除之后，再来实现任意值得删除，就容易一些，方法与删除最大/最小值类似，同样需要先自上而下进行搜索调整，如果发现要删除的节点不在树底部，需要将要删除的节点和它左子树的最小节点进行交换（和二叉搜索树的删除相同），自上而下搜索完成之后，删除结点，然后自下而上地回溯搜索路径，将临时的4-节点进行分解，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="literal">null</span> || !Contains(t))</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!IsRedNode(tree.Left) &amp;&amp; !IsRedNode(tree.Right))</span><br><span class="line">       tree.IsRed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   tree = Remove(tree, t);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tree != <span class="literal">null</span>)</span><br><span class="line">       tree.IsRed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">Remove</span>(<span class="params">Node h, T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (comparer.Compare(h.Item, t) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (!IsRedNode(h.Left) &amp;&amp; !IsRedNode(h.Right))</span><br><span class="line">           h = MoveRedToLeft(h);</span><br><span class="line"></span><br><span class="line">       h.Left = Remove(h.Left, t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (IsRedNode(h.Left))</span><br><span class="line">           h = RotateRight(h);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (comparer.Compare(h.Item, t) == <span class="number">0</span> &amp;&amp; h.Right == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!IsRedNode(h.Right) &amp;&amp; !IsRedNode(h.Right.Left))</span><br><span class="line">       &#123;</span><br><span class="line">           h = MoveRedToRight(h);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (comparer.Compare(h.Item, t) == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 找到右子树的最小值，替换到要删除的节点</span></span><br><span class="line">           Node x = MinNode(h.Right);</span><br><span class="line">           h.Item = x.Item;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 替换完成之后，只需要将最小值节点删除即可</span></span><br><span class="line">           h.Right = RemoveMinInternal(h.Right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           h.Right = Remove(h.Right, t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Balance(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树之所以比较难学，个人认为主要原因在于它的旋转、颜色转换等操作的作用不够直观，并且这些操作会影响父子、兄弟节点，更是难以缕清之间的关系，所以将红黑树的操作和2-3树进行一一对应起来，便于学习和理解。</p>
<p>对于2-3树来说，3-节点、4-节点用红、黑链接有多种表示方式，因此红黑树规定了一些约束，这些约束一是保证一个2-3树只对应一种红黑树表示，另一个重要作用就是简化代码的实现。</p>
<p>最后附上完整<a href="https://github.com/huosk/Algo/blob/master/CSharp/Collections/RedBlackTree.cs" target="_blank" rel="noopener">代码</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数组分区使用小结</title>
    <url>/2019/02/26/ArrayPartitioning/</url>
    <content><![CDATA[<h1 id="数组分区使用小结"><a href="#数组分区使用小结" class="headerlink" title="数组分区使用小结"></a>数组分区使用小结</h1><p>在学习算法过程中，经常会跟数组进行打交道，其中难免会遇到数组的排序、删除等等操作，其中很多都应用了数组的分区的方法，比如：</p>
<a id="more"></a>
<ul>
<li>插入排序将数组分为已排序和未排序两个区。（冒泡、选择也是如此）。</li>
<li>快速排序算法中的分区其实也使用了该方法，将数组分为大于分界点、小于分界点的两个区。</li>
</ul>
<p>在刚开始接触算法的时候，总是努力的去理解算法思想、去记范式代码怎么写，后来发现学过之后还是很难写出来，归根结底还是没有掌握其方法，所以有必要进行专门的总结学习，本文主要介绍数组分区的实现和使用。</p>
<h2 id="分区实现介绍"><a href="#分区实现介绍" class="headerlink" title="分区实现介绍"></a>分区实现介绍</h2><p>一般的，数组分区问题可以采用以下步骤来解决：</p>
<ol>
<li>确定分区方式，已排序/未排序、保留区/删除区等等。</li>
<li>初始化分区长度，设置分区尾部索引，指向分区队尾的下个位置。</li>
<li>遍历另一个分区，将之不断交换到另一个分区中。</li>
</ol>
<p>还是通过几个例子来具体看下如何使用。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>回顾一下之前介绍的选择排序思想，选择排序将待排序数据分为两个部分，每次遍历待排序部分，选择其中最小的元素，将之交换到已排序区的尾部，直到所有待排序区的元素处理完毕。</p>

<p>同样的，插入排序、冒泡排序都是基于分区思想来实现的，代码就不实现了，感兴趣可以参考之前的<a href="https://huosk.github.io/2019/01/27/algorithm07/">文章</a>。</p>
<h2 id="快速排序的分区"><a href="#快速排序的分区" class="headerlink" title="快速排序的分区"></a>快速排序的分区</h2><p>在快速排序中，需要将数组中选取一个分界点，然后将大于分界点的元素置于分界点左侧，大于分界点的置于其右侧，要实现此功能，可以利用分区的思想来实现。</p>
<ol>
<li>首先将待分区的数据分为小于分界点区(A区)和待处理区(B区)，目标就是遍历待处理区，将小元素交换到 A 区。</li>
<li>初始时，A 区长度为0，尾部索引为 0(指向 B 区第一个元素)，B 区等于待处理数据长度。</li>
<li>遍历 B 区，将小于分界点的元素，交换到 A 区尾部。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Partition</span><span class="params">(n,i)</span></span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">-- 将分区点先交换到最后，避免中间被交换</span></span><br><span class="line">    n[i],n[#n]=n[#n],n[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 保存小于分界点的分区的尾部索引</span></span><br><span class="line">    <span class="keyword">local</span> minTail = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>,#n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> n[j] &lt; n[#n] <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 小于分区点，将之交换到小分区点尾部</span></span><br><span class="line">        n[minTail],n[j] = n[j],n[minTail]</span><br><span class="line">        minTail = minTail + <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 最后，再将分区点交换到小元素区的尾部</span></span><br><span class="line">    n[minTail],n[#n] = n[#n],n[minTail]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="数组多元素删除"><a href="#数组多元素删除" class="headerlink" title="数组多元素删除"></a>数组多元素删除</h2><p>我们知道在删除单个数组元素时，需要将删除位置之后的元素进行移动拷贝，索引值越大需要移动的元素就越少，删除最后一个元素则不需要进行移动拷贝，根据这个思路，在删除多个元素时，可以先将所要要删除的元素交换到数组的末尾，然后进行一次性删除，避免数组的移动拷贝。</p>
<p>将要删除的元素置于数组末尾，这就可以采用数组分区方法来实现，步骤如下：</p>
<ol>
<li>首先将数组分为保留区、待处理区。</li>
<li>初始时，保留区元素为长度为 0，尾部索引为 0（指向待处理第一个元素）。</li>
<li>遍历待处理区，将不满足删除条件的交换到保留区尾部，遍历完成之后，待处理区剩下的就是要删除的元素。</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RemoveAll</span><span class="params">(nums,val)</span></span></span><br><span class="line">    <span class="keyword">if</span> nums == <span class="literal">nil</span> <span class="keyword">or</span> #nums == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> endOfRemain = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>,#nums <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> nums[i] ~= val <span class="keyword">then</span></span><br><span class="line">        nums[endOfRemain],nums[i]=nums[i],nums[endOfRemain]</span><br><span class="line">        endOfRemain = endOfRemain + <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> endOfRemain - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 散列表</title>
    <url>/2019/02/21/algorithm11-hashmap/</url>
    <content><![CDATA[<h1 id="数据结构与算法-散列表"><a href="#数据结构与算法-散列表" class="headerlink" title="数据结构与算法 - 散列表"></a>数据结构与算法 - 散列表</h1><p>在之前介绍了二分查找、利用跳表进行查找，在查找效率上都非常高，但是它们有个共同的特点，就是都是基于元素比较的查找。本节介绍一种新的查找方式-散列表，又称哈希表。</p>
<a id="more"></a>
<p>散列表的底层依赖于数组，算是数组概念的推广，正因为数组支持直接寻址，能够在O(1)时间复杂度内找到目标，才有了散列表高效的查找。</p>
<p>考虑这样一个例子，要记录一个考场内所有考生的信息，如果按照座位号进行存储的话比较容易，直接使用数组来存储即可；如果要求按照身份证号来查找，那么应该如何进行存储，才能实现高效的查找呢，一种可行的办法是采用身份证号的后几位数字，比如后3位，当通过身份证号进行查找时，只需要截取后几位数，作为数组的索引来读取数组中的数据。</p>
<p>这种实现方式就是散列思想的应用，其中身份证号叫做<strong>键</strong>；将关键字转为数组下表的方法叫做<strong>散列函数</strong>；散列函数计算到的值叫做<strong>散列值</strong>。</p>
<img src="/2019/02/21/algorithm11-hashmap/hash_algo.png">
<p>上面例子的散列函数形式大致如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashCode</span>(<span class="params"><span class="keyword">string</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">string</span> suffix = id.sub(length<span class="number">-3</span>,length);</span><br><span class="line">  <span class="keyword">int</span> hashCode = tointeger(suffix);</span><br><span class="line">  <span class="keyword">return</span> HashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在继续介绍下面内容之前，先介绍几个概念：</p>
<p><strong>槽/桶</strong>：散列表是依赖于数组的结构，数组中的每一个元素称为一个槽/桶，可以通过散列值计算出其数组下标。<br><strong>装载因子</strong>：一个衡量数组使用程度的指标，常用$\alpha$表示，其值：$\alpha$ = 散列表中元素数 / 槽数。</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列表的核心在于散列函数的设计，如果散列函数设计不当，可能会造成散列表性能退化到O(n)，一个优秀的散列函数应该满足下面三个条件：</p>
<ol>
<li>一致性 - 键相等，散列值必须相等</li>
<li>高效性 - 计算简单，复杂度不能太高</li>
<li>均匀性 - 均匀的分布所有的键</li>
</ol>
<p>一致性其实分为两个方面，如果键相等，则散列值应该相等；如果键不相等，则散列值应该不相等，但是这几乎是不可能的，这种键不相等，但是散列值相等的情况，称为<strong>散列冲突</strong>。</p>
<p>高效性比较容易解释，散列函数如果复杂度很高，会降低散列表的效率。</p>
<p>均匀性就是保证所有的键能够均匀的散列到整个范围中，保证均匀性最好的办法就是保证键的每一位都在散列函数中起到了相同的作用，实现散列函数最常见的错误就是忽略了键的高位，很遗憾的是，没有什么好的方法来测试所有的键是否被均匀的散列。</p>
<p>在介绍了散列函数的几个特点之后，下面介绍几个具体实现散列函数的方法：乘法散列法、除法散列法、全域散列法。</p>
<h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>除法散列法的核心思想是将键 k 除以 m 求余：</p>
<script type="math/tex; mode=display">
Hash(k)=k\mod{m}</script><p>除法散列法的重点在于 m 的选择，这里需要注意以下几点：</p>
<ul>
<li>不能是$2^p$，如果 $m = 2^p$，相等于散列函数只保留了 p 个最低位，忽略了高位的计算，这与之前提到的均匀性要求是违背的。</li>
<li>当 k 是按基数$2^p$表示的字符串时，$m=2^p-1$也是非常差的选择，因为任意置换字符串中字符位置，不会改变散列值。</li>
</ul>
<p>通常可以选择一个不太接近$2^p$的<a href="https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0" target="_blank" rel="noopener">素数</a>，例如要使用散列表来存储大约包含2000个元素的字符串，如果我们能够承受平均每次查找3个元素（由于散列冲突造成），那么可以选择$2000 / 3 \approx {667}$，距离该值相近的2的整数幂为 512、1024,可选择的素数比较多：710、709、719、727……</p>
<p>假定选择了727，那么基数为 x 和 x+727的散列值是相同的，比如基数为315、1042、1769的键对应的散列值都是 315，这就是发生了散列冲突，需要在这冲突的元素中，找到要查找的目标。</p>
<h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>乘法散列法包含以下两步骤来处理键 k：</p>
<ol>
<li>将 k 乘以小数 A (0&lt;A&lt;1)，然后提取结果的小数部分。</li>
<li>将上一步得到的小数部分，乘以 m，并将结果向下取整。</li>
</ol>
<script type="math/tex; mode=display">
Hash(k) = \lfloor m(kA \mod 1)\rfloor</script><p>这里 m 的选择并不是特别重要，一般 $m = 2^p$；A 的选取比较有讲究，一般 $A = s / 2^w$，其中 w 为计算机的字长，Knuth 认为 $A=\sqrt{5}-1 / 2 \approx 0.618$。</p>
<h3 id="全域散列法"><a href="#全域散列法" class="headerlink" title="全域散列法"></a>全域散列法</h3><p>在某些极端情况下，恶意的攻击者可能会针对你的散列函数，精心设计一些冲突数据，使得散列表查询的时间复杂度从O(1)迅速退化为O(n)，比如有10万条记录，效率下降将近10万倍，正常情况下散列表查询只需要 0.1 秒，退化后需呀 1 万秒，消耗大量的资源来进行散列表的查找，而不能处理其他用户请求，达到DDos 攻击的目的，这就是散列表冲突攻击的基本原理。</p>
<p>因此，在设计散列函数时，除了要考虑键的均匀散列，还要具备一定的随机性，不管对手选择怎样的键，都能够均匀的进行处理。</p>
<p>全域散列法是利用一组精心设计的散列函数（这组散列函数称为函数簇），每次散列时，随机从中选取一个作为散列函数，这样就会极大的降低复杂度退化的可能性。</p>
<p>那么这组散列函数如何设计呢，这里直接给出结果，相关的证明可以参考算法导论中的详细介绍，首先给出散列函数的原型，然后逐一解释其中参数的含义：</p>
<script type="math/tex; mode=display">
Hash_{ab}(k) = ((ak+b)\mod p)\mod m</script><ul>
<li>P 是一个足够大的素数</li>
<li>A 是 [1,P-1] 之间的整数</li>
<li>B 是 [0,P-1] 之间的整数</li>
<li>M 是散列表的槽数</li>
</ul>
<p>函数簇定义为：</p>
<script type="math/tex; mode=display">
{h_{ab}:a\in[1,P-1],b\in[0,P-1]}</script><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>即便是 md5 这种哈希算法，都会存在散列冲突，常用的解决办法有两种：开放寻址法、链接法。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的思想是在遇到散列冲突之后，接着向后进行<strong>探查</strong>，直到找到空闲位置。探查的方式包含以下几种：</p>
<ul>
<li>线性探查法</li>
<li>二次探查法</li>
<li>双重探查法</li>
</ul>
<h4 id="线性探查法"><a href="#线性探查法" class="headerlink" title="线性探查法"></a>线性探查法</h4><p>线性探查法的思路非常简单，以散列表的查找为例，首先根据键找到散列表相应的元素 Q，如果不是要查找目标，接着查找下一个元素，依次探查到最后，再从头探查，直到元素Q，用图表示如下：</p>
<img src="/2019/02/21/algorithm11-hashmap/open_addr_linear.png">
<p>线性探查采用的散列函数如下：</p>
<script type="math/tex; mode=display">
Hash(k,i)=(hash(k) + i) \mod m,i \in [0,m-1]</script><p>其中hash 是一个普通的散列函数，线性探查过程如下：</p>
<ul>
<li>首先检查 hash(k) 是否为探查目标，找到了，或者为空，则结束查找，否则继续。</li>
<li>探查 Hash(k,1) - Hash(k,m-1)</li>
<li>如果没有探查到，则说明目标不在散列表中</li>
</ul>
<p>从上面过程可以看出，最坏的探查情况是要遍历整个散列表，并且随着散列表的数据增长，查找时间也会不断的增加。</p>
<h4 id="二次探查法"><a href="#二次探查法" class="headerlink" title="二次探查法"></a>二次探查法</h4><p>二次探查法与线性探查法类似，只不过线性探查法的探查步长为 1，而二次探查法的步长是成平方递增的，它的散列函数如下：</p>
<script type="math/tex; mode=display">
Hash(k,i) = (hash(k) + c_1{i} + c_2{i}^2) \mod {m}，i \in [0,m-1]</script><p>其中$c_1$、$c_2$为正整数。</p>
<h4 id="双重探查法"><a href="#双重探查法" class="headerlink" title="双重探查法"></a>双重探查法</h4><p>双重探查法是开放寻址法最好的探查方法之一，因为它产生的散列排布具备随机选择排布特性，它的散列函数如下：</p>
<script type="math/tex; mode=display">
Hash(k,i) = (h_1(k) + i * h_2(k)) \mod m，i \in [0,m-1]</script><p>为了能够查找整个散列表，$h_2(k)$必须与 m <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA" target="_blank" rel="noopener">互素</a>，实现两数互素的办法有很多，这里只介绍两种</p>
<ol>
<li>让 m 取2的整数次幂，$h_2(k)$总是返回奇数。（2的幂和任何奇数互素）</li>
<li>让 m 为素数，$h_2(k)$的返回值总是比 m 略小。(两个数中较大的为素数，则两数互素)</li>
</ol>
<h3 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h3><p>在链接法中，将所有散列值相同的元素，通过结点指针链接起来，散列槽中存放这头结点的指针。</p>
<img src="/2019/02/21/algorithm11-hashmap/hash_linked.png">
<h4 id="链接法散列性能分析"><a href="#链接法散列性能分析" class="headerlink" title="链接法散列性能分析"></a>链接法散列性能分析</h4><p>以散列表的查询为例，分析一下采用链接法的散列表的性能，给定一个元素数量为 n，槽数为 m 的散列表 T，定义 T 的装载因子$\alpha = n / m$，表示一个链平均存储元素数，值越大说明元素越多，空闲位置越少，散列冲突概率越大，下面借用此概念来做性能分析。</p>
<ul>
<li>最坏的情况下，所有 n 个元素都在一个槽中，此时散列表退化为普通链表，查询时间复杂度变成 O(n)</li>
<li>平均情况依赖于元素的平均分布情况，一次不成功的查找的平均时间为$\Theta(1+\alpha)$</li>
<li>在所有元素平均分布的情况下，一次成功查找所需的平均时间为$\Theta(1+\alpha)$</li>
</ul>
<h3 id="开放寻址法-vs-链接法"><a href="#开放寻址法-vs-链接法" class="headerlink" title="开放寻址法 vs 链接法"></a>开放寻址法 vs 链接法</h3><p>开放寻址法优点：</p>
<ul>
<li>所有元素存储在数组中，能够利用 CPU 缓存加快查询速度。</li>
<li>数组结构序列化起来比较简单</li>
</ul>
<p>开放寻址法缺点：</p>
<ul>
<li>对于散列冲突的元素，查询、删除时间复杂度较高。</li>
<li>装载因子不能太大，太大的话，散列表退化几率将会增加。</li>
</ul>
<p>综上，<strong>当数据量比较小的情况下，适合采用开放寻址方式。</strong></p>
<p>链接法的优点：</p>
<ul>
<li>内存利用率比较高。</li>
<li>对于散列冲突的元素，查询、删除等操作时间复杂度较低。</li>
<li>装载因子可以较大，虽然会增加链表的长度，但是在效率上仍然是可以接受的。</li>
</ul>
<p>链接法的缺点：</p>
<ul>
<li>由于使用链表，需要额外的指针空间，内存会有额外消耗。</li>
<li>由于使用链表，内存空间是不连续的，不利于 CPU 缓存。</li>
</ul>
<p>综上：<strong>链接法适用于数据量非常大的情况，相比与开放寻址法，链接法更加灵活，可优化空间比较大（对链表的优化）。</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在介绍玩一些理论知识之后，看一下实际的散列表应该如何实现，这里采用链接法处理散列冲突，代码参考 C# 的 Dictionary。</p>
<img src="/2019/02/21/algorithm11-hashmap/hashmap_design.png">
<p>对上图稍作解释：</p>
<ul>
<li>buckets 是散列表的槽，int类型数组，存储着指向链表的头结点的指针。</li>
<li>entries 是散列元素数组，Entry类型，Entry.next 指向链接的下一个结点，-1 表示为最后一个结点。</li>
</ul>
<h3 id="插入的实现"><a href="#插入的实现" class="headerlink" title="插入的实现"></a>插入的实现</h3><p>插入的核心流程是：</p>
<ol>
<li>获取对象的散列值(hashCode)，根据散列值计算出槽位(targetBucket)。</li>
<li>根据槽位在 entries 数组找到元素（链头），根据 next 指针遍历整条链，如果某个结点的键值与要插入的键值相等，说明已经存在，直接返回。</li>
<li>如果不在散列表中则进行插入，将新 Entry 添加到 entries 数组，并将 Entry.next 指向链头，更新散列表的槽，使之指向新的链头。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 舍弃符号位</span></span><br><span class="line">   <span class="keyword">int</span> hashCode = <span class="keyword">this</span>.comparer.GetHashCode(key) &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据散列值，计算槽位</span></span><br><span class="line">   <span class="keyword">int</span> targetBucket = hashCode % <span class="keyword">this</span>.buckets.Length;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> entryIndex = <span class="keyword">this</span>.buckets[targetBucket];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查散列表是否已经存在要插入的键值</span></span><br><span class="line">   <span class="keyword">while</span> (entryIndex &gt;= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.entries[entryIndex].hashCode == hashCode &amp;&amp;</span><br><span class="line">           <span class="keyword">this</span>.comparer.Equals(<span class="keyword">this</span>.entries[entryIndex].key, key))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 相同的键值已经插入到散列表中</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       entryIndex = <span class="keyword">this</span>.entries[entryIndex].next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 插入新值</span></span><br><span class="line">   <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 动态扩容 - 开始</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.freeCount &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       index = <span class="keyword">this</span>.freeList;</span><br><span class="line">       <span class="keyword">this</span>.freeList = <span class="keyword">this</span>.entries[index].next;</span><br><span class="line">       <span class="keyword">this</span>.freeCount--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.entries.Length)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 扩容</span></span><br><span class="line">           <span class="keyword">this</span>.Resize();</span><br><span class="line">           targetBucket = hashCode % <span class="keyword">this</span>.buckets.Length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       index = <span class="keyword">this</span>.count;</span><br><span class="line">       <span class="keyword">this</span>.count++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 动态扩容 - 结束</span></span><br><span class="line">   <span class="keyword">this</span>.entries[index].hashCode = hashCode;     <span class="comment">// 保存散列值</span></span><br><span class="line">   <span class="keyword">this</span>.entries[index].next = <span class="keyword">this</span>.buckets[targetBucket];    <span class="comment">// 将next 指向当前的链头</span></span><br><span class="line">   <span class="keyword">this</span>.entries[index].key = key;</span><br><span class="line">   <span class="keyword">this</span>.entries[index].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">   <span class="keyword">this</span>.buckets[targetBucket] = index; <span class="comment">// 将链头指向新插入的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除的实现"><a href="#删除的实现" class="headerlink" title="删除的实现"></a>删除的实现</h3><p>删除元素的流程如下：</p>
<ol>
<li>获取对象的散列值(hashCode)，根据散列值计算出槽位(targetBucket)。</li>
<li>根据槽位在 buckets 数组中找到链头索引，根据链头遍历整条链，检查每个结点是否为要删除的结点。</li>
<li>在删除时，要注意维护好整条链的链接，以及更新 buckets 槽中的链头指针。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentNullException(<span class="string">"key"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> hashCode = <span class="keyword">this</span>.comparer.GetHashCode(key) &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">   <span class="keyword">int</span> targetBucket = hashCode % <span class="keyword">this</span>.buckets.Length;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> entryIndex = <span class="keyword">this</span>.buckets[targetBucket];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> lastNode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.buckets != <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (entryIndex &gt;= <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.entries[entryIndex].hashCode == hashCode &amp;&amp;</span><br><span class="line">               <span class="keyword">this</span>.comparer.Equals(<span class="keyword">this</span>.entries[entryIndex].key, key))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 找到要删除的元素</span></span><br><span class="line">               <span class="keyword">if</span> (lastNode &lt; <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 要删除的结点为头结点</span></span><br><span class="line">                   <span class="keyword">this</span>.buckets[targetBucket] = <span class="keyword">this</span>.entries[entryIndex].next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 要删除的前置节点，与后置结点链接</span></span><br><span class="line">                   <span class="keyword">this</span>.entries[lastNode].next = <span class="keyword">this</span>.entries[entryIndex].next;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 释放结点</span></span><br><span class="line">               <span class="keyword">this</span>.entries[entryIndex].hashCode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 空闲结点也是以链式进行存储，将新的空闲结点指向当先空闲链头</span></span><br><span class="line">               <span class="keyword">this</span>.entries[entryIndex].next = <span class="keyword">this</span>.freeList;</span><br><span class="line">               <span class="keyword">this</span>.entries[entryIndex].key = <span class="keyword">default</span>(TKey);</span><br><span class="line">               <span class="keyword">this</span>.entries[entryIndex].<span class="keyword">value</span> = <span class="keyword">default</span>(TValue);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 更新空闲结点的头指针</span></span><br><span class="line">               <span class="keyword">this</span>.freeList = entryIndex;</span><br><span class="line">               <span class="keyword">this</span>.freeCount++;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           entryIndex = <span class="keyword">this</span>.entries[entryIndex].next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找的实现"><a href="#查找的实现" class="headerlink" title="查找的实现"></a>查找的实现</h3><p>在明白插入和删除之后，插入就很简单了，这里就不实现了，详细的代码实现可以参考<a href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,3b9a0882313262cd" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><p>上面虽然使用了链接法，但是没有使用链表，而是采用 Entry 数组来模拟链表功能，在这里 Entry.next 是一个指向 entries 的指针，它有两方面作用：</p>
<ol>
<li>当 Entry 存储着数据时，next 指向下一个散列冲突结点。</li>
<li>当 Entry 可利用时（即没有存储数据），next 指向下一个空闲的节点。</li>
</ol>
<p>freeList 字段记录着闲置链表的头结点索引，当值为 -1 时表示没有闲置的节点。当需要向 entries 中插入数据时，首先检查闲置链表是否为空，如果为空，再从 entries 中分配。</p>
<p>最后在啰嗦一句 C# 的 Dictionary<k,t> 不是线程安全的，如果涉及到多线程的遍历和修改，需要自行加锁，或者直接使用  ConcurrentDictionary<tkey,tvalue> 或 ImmutableDictionary<tkey,tvalue> 类。</tkey,tvalue></tkey,tvalue></k,t></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>C#中的数值溢出检查</title>
    <url>/2019/02/19/EnsureOverflowInCSharp/</url>
    <content><![CDATA[<h1 id="C-中的数值溢出检查"><a href="#C-中的数值溢出检查" class="headerlink" title="C#中的数值溢出检查"></a>C#中的数值溢出检查</h1><p>在 C# 中进行算术运算、数值类型转换时，可能发生边界溢出问题。比如对于 32 位整型（int），最大值为$2^{31}-1$，最小值为$-2^{31}$，如果超出此范围即为越界。</p>
<a id="more"></a>
<p>一般处理越界有两种方法，第一种是采用 System.OverflowException 异常捕获机制，第二种是执行算术运算之前进行越界检查。</p>
<h2 id="System-OverflowException异常捕获"><a href="#System-OverflowException异常捕获" class="headerlink" title="System.OverflowException异常捕获"></a>System.OverflowException异常捕获</h2><p>在 C# 中有两种情况会引发 System.OverflowException 异常：</p>
<ul>
<li>执行算术运算时，运算结果超过类型范围</li>
<li>数值类型转换时，比如 int 向 byte 转换</li>
</ul>
<p>数值运算引发越界：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">780000000</span>;</span><br><span class="line">    <span class="keyword">checked</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Square the original value.</span></span><br><span class="line">            <span class="keyword">int</span> square = <span class="keyword">value</span> * <span class="keyword">value</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125; ^ 2 = &#123;1&#125;"</span>, <span class="keyword">value</span>, square);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OverflowException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> square = Math.Pow(<span class="keyword">value</span>, <span class="number">2</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Exception: &#123;0&#125; &gt; &#123;1:E&#125;."</span>,square, Int32.MaxValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大范围类型向小范围类型转换：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> <span class="keyword">value</span> = <span class="number">241</span>;</span><br><span class="line">    <span class="keyword">checked</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">sbyte</span> newValue = (<span class="keyword">sbyte</span>)<span class="keyword">value</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Converted the &#123;0&#125; value &#123;1&#125; to the &#123;2&#125; value &#123;3&#125;."</span>,</span><br><span class="line">                              <span class="keyword">value</span>.GetType().Name, <span class="keyword">value</span>,</span><br><span class="line">                              newValue.GetType().Name, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OverflowException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Exception: &#123;0&#125; &gt; &#123;1&#125;."</span>, <span class="keyword">value</span>, SByte.MaxValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要特别注意的是，<strong>需要进行越界检查的代码，必须在 checked 块中，否则系统将不会引发越界异常。</strong></p>
<h2 id="提前检查"><a href="#提前检查" class="headerlink" title="提前检查"></a>提前检查</h2><p>对于可能发生越界的运算，在进行计算之前，对运算进行越界评估，比如下面：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2147483640</span>;</span><br><span class="line">        <span class="keyword">if</span>( i &gt; <span class="keyword">int</span>.MaxValue - <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Overflow"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于其他运算也是类似，只不过检查方法有些差别。这种方法也存在一些局限性，通常只用在整型的检查，对于浮点类型来说，由于精度影响，计算出来的结果可能会有误差。所以在实际项目中，最好采用第一种方式来进行越界检查。</p>
]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 跳表</title>
    <url>/2019/02/16/algorithm10-skiplist/</url>
    <content><![CDATA[<h1 id="数据结构与算法-跳表"><a href="#数据结构与算法-跳表" class="headerlink" title="数据结构与算法 - 跳表"></a>数据结构与算法 - 跳表</h1><p>在前面介绍了二分查找，它是一种时间复杂度为$O(\log{n})$的高效查询算法，因为它依赖于有序数组，因此存在一些局限性。我们知道链表不要求连续内存，但是它不支持随机访问，比如在链表 L 中，如果需要查找第 k 个元素，就需要从头开始挨个结点进行查找，那么应该如何提高这种有序链表查找效率呢，基于这个出发点，出现了跳表这种数据结构，</p>
<a id="more"></a>
<p>在介绍跳表之前，首先思考一下，对于一个有序链表，如何才能提高它的查找效率呢？</p>
<p>参考前面的二分查找思想，是不是同样可以将数据的中点提取出来，这样不就可以直接访问到中点了？至于结果行不行的通，先看下如果采用这种方法时的查找过程，见下图。</p>
<img src="/2019/02/16/algorithm10-skiplist/skiplist_bs.png">
<p>可以看出，如果我们挨个遍历的的话需要遍历8个元素，通过提取二分中点来查询则需要经过6个元素，虽然两者相差不多，但是对于规模非常大的数据来说，两者的差距也越大。</p>
<h2 id="跳表是什么"><a href="#跳表是什么" class="headerlink" title="跳表是什么"></a>跳表是什么</h2><p>跳表的思想和上面所说的比较类似，都是通过提取多层索引来提高元素访问效率，但是跳表是通过间隔 n 个元素作提取，而非提取中间点，如下图：</p>
<img src="/2019/02/16/algorithm10-skiplist/skiplist.png">
<h2 id="跳表的性能"><a href="#跳表的性能" class="headerlink" title="跳表的性能"></a>跳表的性能</h2><p>首先分析跳表的查询的时间复杂度：</p>
<ol>
<li>根据上图可以看出第1层索引的结点个数为 ${n}/{2^1}$，第2层结点个数为${n}/{2^2}$，依次类推第k层的结点个数为$n/{2^k}$。</li>
<li>假设跳表有 h 层索引，最高层只有首尾两个结点，即$n/{2^h}=2$，可以得到$h=\log_2{n}-1$，加上原链表本身一共 $\log_2{n}$ 层。</li>
<li>那么每层的复杂度是多少呢？即要遍历多少结点，因为经过上层的索引之后，就能够锁定查找的目标在下层的范围，所以每层最多遍历3个结点。</li>
<li>因此通过跳表查找元素的时间复杂度为：$T(n)= O(3\log_2{n}) = O(\log_2{n})$。</li>
</ol>
<p>跳表的空间复杂度：</p>
<p>通过上面计算，知道第k层的节点个数为$n/{2^k}$，根据下面的几何级数求和公式，(h=$\log_2n-1$)可以计算出总结点个数为：n-2，因此跳表的空间复杂度为O(n)。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k=0}^{h}x^k &= \frac{x^{h+1}-1}{x-1}
\end{aligned}</script><p>这里需要强调的是，虽然空间复杂度为O（n），但是索引结点只存储结点指针，并不存储数据内容，在实际开发中，链表存储的数据内容通常是非常大的，此时就不必太强调空间复杂度。</p>
<h2 id="跳表的实现"><a href="#跳表的实现" class="headerlink" title="跳表的实现"></a>跳表的实现</h2><p>与链表不同，跳表的节点还需要存储它的索引信息，下面是节点类设计：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表类型</span></span><br><span class="line">public class SkipList&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: IComparable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳表节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkipListNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 节点包含的层</span></span><br><span class="line">        <span class="keyword">public</span> SkipLevel[] levels;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后退节点</span></span><br><span class="line">        <span class="keyword">public</span> SkipListNode backward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点数据</span></span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkipLevel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 前进节点</span></span><br><span class="line">        <span class="keyword">public</span> SkipListNode forward;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SkipList 表示跳表数据类型，包含头结点引用和尾节点引用。<br>SkipListNode 表示链表的节点，每个节点都可能包含多层索引和后退节点，索引用 SkipLevel 表示，其中 forward 表示节点在该层跳转的节点，可以通过下图来帮助理解。</p>
<img src="/2019/02/16/algorithm10-skiplist/skipnode.png">
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>查找应该从头结点的最顶层索引开始，递归的遍历前进节点，因为跳表的元素都是有序排序的，所以当节点的前进节点大于要查找的元素时，就需要进入下层索引进行查找，当所有层都遍历完成之后，得到了一个边界节点，需要进一步比较确认，它的前进节点是不是要查找的元素，详细代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找指定节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SkipListNode <span class="title">FindNode</span>(<span class="params">T target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 从头结点开始</span></span><br><span class="line">   <span class="keyword">var</span> node = head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从最顶层索引开始查找</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (node.levels[i] != <span class="literal">null</span> &amp;&amp; node.levels[i].forward.item.CompareTo(target)&lt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 跳转到该层的前进节点</span></span><br><span class="line">           node = node.levels[i].forward;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 循环退出，说明 node 的下一个节点，要么大于查找目标，要么等于查找目标</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进一步判断是否为查找目标</span></span><br><span class="line">   <span class="keyword">if</span> (node.levels[<span class="number">0</span>] != <span class="literal">null</span> &amp;&amp; node.levels[<span class="number">0</span>].forward.item.CompareTo(target) == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> node.levels[<span class="number">0</span>].forward;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>向跳表中插入元素时，必须同时更新索引，如果不更新，就可能造成两个索引节点之间节点过多，查询时间复杂度也会退化为O(n)。</p>
<img src="/2019/02/16/algorithm10-skiplist/skiplist_insert.png">
<p>为了解决该问题，最直接的办法就是每次插入新元素之后，把插入位置之后的索引重新进行计算，但是这样在效率上就会比较低。有一种比较折中的办法，既能够很大程度的降低跳表退化概率，同时在插入效率上也比较高，该方法是在插入时，随机的选取一个层，在该层和之下层中插入索引结点。</p>
<img src="/2019/02/16/algorithm10-skiplist/skiplist_insert_balence.png">
<p>结合上图理解一下跳表的插入步骤：</p>
<ol>
<li>随机选取层索引，下面更新选取层和其下的所有层，上面是[0,2]。</li>
<li>找到各层需要插入的位置，上面各层都是结点5。</li>
<li>更新各层的索引的前进结点，在上图中，是将各层结点5的前进结点指向新结点6，将6的前进节点指向结点5之前的前进结点。</li>
<li>更新后退结点。</li>
</ol>
<p>结点属性的变化关系如下图：</p>
<img src="/2019/02/16/algorithm10-skiplist/skiplist_insert_node_balence.png">
<p>代码实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 获取随机索引层[1,MAX_LEVEL_COUNT]</span></span><br><span class="line">   <span class="keyword">int</span> level = RandomLevel();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建新节点</span></span><br><span class="line">   SkipListNode node = <span class="keyword">new</span> SkipListNode();</span><br><span class="line">   node.backward = head;</span><br><span class="line">   node.levels = <span class="keyword">new</span> SkipLevel[level];</span><br><span class="line">   node.item = t;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在每层中，找到要插入的位置（临界结点），</span></span><br><span class="line">   <span class="comment">// 并且暂时借用新节点的levels,将找到的节点存到其中</span></span><br><span class="line">   SkipListNode temp = head;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line">       node.levels[i] = <span class="keyword">new</span> SkipLevel();</span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="literal">null</span> &amp;&amp; temp.levels!= <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              temp.levels[i] != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">              temp.levels[i].forward != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">              temp.levels[i].forward.item.CompareTo(t) &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           temp = temp.levels[i].forward;</span><br><span class="line">       &#125;</span><br><span class="line">       node.levels[i].forward = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 然后设置临界结点和新结点的前进结点和后退节点</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 要插入的临界结点</span></span><br><span class="line">       <span class="keyword">var</span> bound = node.levels[i].forward;</span><br><span class="line">       temp = bound.levels[i].forward;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置前进结点</span></span><br><span class="line">       bound.levels[i].forward = node;</span><br><span class="line">       node.levels[i].forward = temp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置后退结点</span></span><br><span class="line">       node.backward = bound;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(temp != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           temp.backward = node;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(node.levels[<span class="number">0</span>].forward == <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       tail = node;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在选择索引层时使用了随机算法，为了保证随机结果能够均匀分布，将随机算法实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">RandomLevel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXLEVELCOUNT; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.random.Next() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           level++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>在理解了跳表的插入过程之后，删除操作也就很好理解了，除了要删除源链表的结点之外，还要删除该节点对应的索引节点，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">T t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SkipListNode[] needUpdates = <span class="keyword">new</span> SkipListNode[<span class="keyword">this</span>.levelCount];</span><br><span class="line">   SkipListNode temp = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查找边界点:</span></span><br><span class="line">   <span class="comment">// A[i] &lt; t,A[i+1]&gt;= t，即找到A[i]之后</span></span><br><span class="line">   <span class="comment">// 需要进一步判断就是否为要删除的值</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="literal">null</span> &amp;&amp; temp.GetForward(i) != <span class="literal">null</span> &amp;&amp; temp.GetForward(i).item.CompareTo(t) &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           temp = temp.levels[i].forward;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       needUpdates[i] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 源链表中的节点，如果该值与要删除的不相等，说明要删除的元素在跳表中不存在</span></span><br><span class="line">   <span class="keyword">var</span> node = temp.GetForward(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; node.item.CompareTo(t) == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// A-&gt;B-&gt;C，更新为：A-&gt;C，其中B为要删除的结点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.levelCount; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           SkipListNode forward = needUpdates[i].levels[i].forward;</span><br><span class="line">           <span class="keyword">if</span> (forward.item.CompareTo(t) == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               needUpdates[i].levels[i].forward = forward.levels[i].forward;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面介绍了跳表一些常用操作和实现，相对于之后要介绍的二叉平衡树要简单，在查询、插入等操作上效率也非常高。在开源K-V<br>数据库 Redis 中就使用了跳表，感兴趣的可以<a href="https://github.com/antirez/redis/blob/unstable/src/t_zset.c" target="_blank" rel="noopener">学习一下</a>，最后完整的代码在<a href="https://github.com/huosk/Algo/blob/master/CSharp/Collections/SkipList.cs" target="_blank" rel="noopener">这里</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 二分查找</title>
    <url>/2019/02/13/binarysearch/</url>
    <content><![CDATA[<h1 id="数据结构与算法-二分查找"><a href="#数据结构与算法-二分查找" class="headerlink" title="数据结构与算法 - 二分查找"></a>数据结构与算法 - 二分查找</h1><p>前面介绍了插入排序、选择排序、快排等几种排序算法，后面会用几篇文章介绍几种查找算法，之所以要先介绍排序算法，再介绍查找算法，是因为要进行查找的数据都是已经排好序的，这是因为对于很多查找算法要求数据是有序的。这里将会介绍几种非常高效的算法：二分查找、红黑树、散列表、跳表。</p>
<a id="more"></a>
<p>下面介绍二分查找，二分查找也叫折半查找，相信大家都玩过或者见过猜数字游戏，由 A 向知道正确数字的 B 报出一个数字，B 告诉 A 所报数字是大于/小于所猜数字，然后继续进行猜测，直到猜到正确数字，如果希望最快的速度猜出数字，就需要每次报中间值。这就是二分思想的一种应用：将所要查找的数字与中间数进行比较，如果大于中间数，则用同样的方法在后半部分查找，如果小于，则用同样方法在前半部分查找。</p>
<img src="/2019/02/13/binarysearch/BinarySearch.png">
<p>用递归式表示二分查找如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
    mid &= \left \lfloor \frac{s+e}{2} \right \rfloor\\
    BinarySearch(n,s,e) &= BinarySearch(n,s,mid-1),(n[mid] < target)\\
    BinarySearch(n,s,e) &= BinarySearch(n,mid+1,e),(n[mid] > target)
\end{cases}</script><p>转换成代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch</span><span class="params">(n,low,high,target)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 最终也没有找到</span></span><br><span class="line">  <span class="keyword">if</span> low &gt; high <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 中间位置</span></span><br><span class="line">  <span class="keyword">local</span> mid = (low+high) // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> n[mid] == target <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line">  <span class="keyword">elseif</span> n[mid] &gt; target <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> BinarySearch(n,low,mid<span class="number">-1</span>,target)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> BinarySearch(n,mid+<span class="number">1</span>,high,target)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>非递归形式代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchNoRecu</span><span class="params">(n,target)</span></span></span><br><span class="line">    <span class="comment">-- low,high 初始化</span></span><br><span class="line">    <span class="keyword">local</span> low,high = <span class="number">1</span>,#n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> mid = (low + high) // <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> n[mid] == target <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      <span class="keyword">elseif</span> n[mid] &gt; target <span class="keyword">then</span></span><br><span class="line">        high = mid - <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        low = mid + <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 最终没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>虽然上面代码是正确的，但是在某些情况可能得不到想要的结果，比如下面数组中，我们希望找到第一个等于6的值。</p>
<script type="math/tex; mode=display">
A = 1,6,6,7,8</script><p>如果使用上面算法进行查找的话，返回值为3，并不是我们期望的第一个满足条件的值，那么该如何修改上面算法呢。我们可以这么考虑该问题，既然第二个6不是查找目标，那么它和其他不满足条件的元素一样，需要继续执行递归查找，那么此时查找条件就不能是简单的相等了，还需要是第一个相等的值，翻译成代码就是：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">n[mid<span class="number">-1</span>] ~= target</span><br></pre></td></tr></table></figure>
<p>注意上面使用了mid-1，因此就需要边界下溢问题，当 mid = 0时，n[mid] 为第一个元素，因此也是满足条件的，最终代码实现如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchFirst</span><span class="params">(n,low,high,target)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 最终也没有找到</span></span><br><span class="line">  <span class="keyword">if</span> low &gt; high <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 中间位置</span></span><br><span class="line">  <span class="keyword">local</span> mid = (low+high) // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> n[mid] == target <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 需要额外的条件</span></span><br><span class="line">    <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> n[mid<span class="number">-1</span>] ~= target <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">-- 这里是查找第一个满足条件，因此需要继续在前半段进行查找，如果是查找</span></span><br><span class="line">      <span class="comment">-- 最后一个满足条件的，则需要在后半段进行查找</span></span><br><span class="line">      <span class="keyword">return</span> BinarySearchFirst(n,low,mid<span class="number">-1</span>,target)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">elseif</span> n[mid] &gt; target <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> BinarySearchFirst(n,low,mid<span class="number">-1</span>,target)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> BinarySearchFirst(n,mid+<span class="number">1</span>,high,target)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其他类似的问题，实现思路和上面是类似的：</p>
<ul>
<li>查找最后一个满足条件的元素</li>
<li>查找第一个大于等于目标的元素</li>
<li>查找最后一个小于等于目标的元素</li>
</ul>
<h2 id="二分查找性能"><a href="#二分查找性能" class="headerlink" title="二分查找性能"></a>二分查找性能</h2><p>那么二分查找的时间复杂度是多少呢？每次查找都会讲数据规模进行折半，那么最坏的情况是，没有找到满足条件的元素，此时数据规模为0。</p>
<p>经过 k 次查找，数据规模的变化如下：</p>
<script type="math/tex; mode=display">
n,\frac{n}{2^1},\frac{n}{2^2},\frac{n}{2^3}……\frac{n}{2^k}</script><p>最后一次查找的数据规模为：$\frac{n}{2^k}$，此时值等于1，因为下一次数据规模为0就停止了查找，所以可以计算出 k 的值。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{n}{2^k} &= 1\\
k &= \log_2{n}
\end{aligned}</script><p>而单次查找的时间复杂度为$O(1)$，因此二分查找的时间复杂度为：$O(1)\log{n}=O(\log{n})$</p>
<p>也可以采用之前介绍的主方法来计算时间复杂度，首先将递归式换种写法：</p>
<script type="math/tex; mode=display">
T(n) = aT(n/b) + f(n)</script><ol>
<li>根据二分查找的定义可以知道，a = 1,b = 2,f(n)=1</li>
<li>然后比较f(n)=1，和 $n^{\log_b^a}$=$n^0$=1 的渐进大小，两者的渐进值相同，满足主定理的第二种情况，因此时间复杂度为:$T(n)=O(n)=n^{\log_b^a}\log{n}$=$\log{n}$</li>
</ol>
<p>对数是一个效率非常恐怖的数量级，比如从$2^32$(约42亿)个元素中查找某元素，最多只需要进行32次比较。</p>
<h2 id="二分查找的局限"><a href="#二分查找的局限" class="headerlink" title="二分查找的局限"></a>二分查找的局限</h2><ol>
<li>二分查找的数据必须是有序的。</li>
<li>二分查找依赖于数组的随机访问，如果采用其他顺序列表进行存储，则需要先根据位置，找到相应的中间元素，这样就完全失去了二分查找的意义，时间复杂度也会变大。</li>
<li>由于二分查找依赖于数组，而数组又是连续的内存结构，因此不太适用于数据规模太大的查找。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>UGUI ScrollRect 优化</title>
    <url>/2019/02/12/endlessscrollrect/</url>
    <content><![CDATA[<h1 id="UGUI-ScrollRect-优化"><a href="#UGUI-ScrollRect-优化" class="headerlink" title="UGUI ScrollRect 优化"></a>UGUI ScrollRect 优化</h1><p>在之前的文章中提过，ScrollRect 优化一般有两种方法，一种是采用 LayoutElement 占位符，这种方法的缺点在于需要频繁的变换父子关系，从而造成 Layout 需要不断的重构，如果元素数量比较大的情况下，就会消耗大量资源，造成帧率降低；另一种方法时基于位置变换实现，本次实现也是基于 UGUI 的 LayoutGroup 来实现。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>算法实现的核心包括越界检测和位置移动，为了保证滚动视图进行连续的滚动，至少要保证在可视区（View）之外有两个元素，此时，边界检测范围为可视区+上下各一个元素大小的区域，如下图所示。</p>
<img src="/2019/02/12/endlessscrollrect/PosChange.png">
<p>在 ScrollRect 滑动过程中，因为需要频繁的进行越界检测和位置移动，所以这里采用双向链表来管理 UI 元素，通过维持链表的有序性（索引、位置），来提高元素遍历的效率。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后附上工程<a href="https://github.com/huosk/EndlessScrollRect" target="_blank" rel="noopener">代码</a>，这里只是提供一种 ScrollRect 实现的思路和简单示例，工程没有经过深度的测试，<strong>使用前请慎重考虑</strong>，后续会随着项目使用进行逐步完善。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 排序算法(下)</title>
    <url>/2019/02/02/algorithm08/</url>
    <content><![CDATA[<h1 id="数据结构与算法-排序算法-下"><a href="#数据结构与算法-排序算法-下" class="headerlink" title="数据结构与算法 - 排序算法(下)"></a>数据结构与算法 - 排序算法(下)</h1><p>上一篇介绍了排序算法中的选择排序、冒泡排序、插入排序，这三种算法的平均情况时间复杂度都为$O(n^2)$，因此对于数据规模比较大的时候，就不适用了。本节介绍两种效率比较高的算法，归并排序、快速排序。</p>
<a id="more"></a>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思想是：将要排序的数组分成两个子数组，将子数组进行排序，然后合并子数组。可以看出来，归并排序具有非常明显的分治策略特征。排序过程如下：</p>
<img src="/2019/02/02/algorithm08/merge_sort.gif">
<p>用递归式表示归并排序如下：</p>
<script type="math/tex; mode=display">
T(n,s,e)=T(n,s,\left \lfloor \frac{e-s}{2} \right \rfloor) + T(n,{\left \lfloor \frac{e-s}{2} \right \rfloor}+1,e)+Merge(n,s,e),(e>s)</script><p>代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">递推公式：</span></span><br><span class="line"><span class="comment">merge_sort(p..r) = merge(merge_sort(p..q),merge_sort(q+1,r))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">终止条件</span></span><br><span class="line"><span class="comment">p &gt;= r 不用继续分解</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 合并两个子数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(t,p,q,r)</span></span></span><br><span class="line">  <span class="keyword">local</span> i,j = p,q+<span class="number">1</span></span><br><span class="line">  <span class="keyword">local</span> temp = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> i&lt;= q <span class="keyword">and</span> j &lt;= r <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> t[i] &lt;= t[j] <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">table</span>.<span class="built_in">insert</span>(temp,t[i])</span><br><span class="line">      i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">table</span>.<span class="built_in">insert</span>(temp,t[j])</span><br><span class="line">      j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">local</span> start,endIndx = i,q</span><br><span class="line">  <span class="keyword">if</span> j &lt;= r <span class="keyword">then</span></span><br><span class="line">    start,endIndx = j,r</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> start&lt;= endIndx <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(temp,t[start])</span><br><span class="line">    start = start + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> tindex=<span class="number">1</span>,#temp <span class="keyword">do</span></span><br><span class="line">    t[p+tindex<span class="number">-1</span>]=temp[tindex]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge_sort</span><span class="params">(t,p,r)</span></span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">local</span> q = (p+r) // <span class="number">2</span></span><br><span class="line">  merge_sort(t,p,q)</span><br><span class="line">  merge_sort(t,q+<span class="number">1</span>,r)</span><br><span class="line">  </span><br><span class="line">  merge(t,p,q,r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>下面分析一下归并排序：</p>
<p>空间复杂度：因为每次合并都需要分配额外的内存，所以所以最大需要 n 大小数组，因此空间复杂度为$O(n)$。<br>时间复杂度：采用主方法来计算时间复杂度：</p>
<ol>
<li>首先将递归公式改成主方法要求形式：$T(n)=2T(n/2)+n$,其中 a=2，b=2，f(n)=n。</li>
<li>然后比较 f(n)=n，与$n^{\log_b^a}$=$n$，两者值相同，满足主定理的第二种情况，所以时间复杂度为：$O(n^{\log_b^a}\log{n})=O(n\log{n})$</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想是这样，对于待排序的数组A，选定数组中的任意元素作为分区点，然后将小于分区点的元素放到前面，大于分区点的放到后面。排序过程如下：</p>
<img src="/2019/02/02/algorithm08/quick_sort.gif">
<p>递归公式如下：</p>
<script type="math/tex; mode=display">
QuickSort(n,s,e) = QuickSort(n,s,p) + QuickSort(n,p,e)，(p为分区点，s<=e)</script><p>在上面递归式中，q代表分区点，分区点的选取方案有多种，可以选取头元素、尾元素作为分区点，但是更多的是采用随机分区点。根据递归公式写出递归代码:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 分区点选取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span><span class="params">(n,s,e)</span></span></span><br><span class="line">  <span class="comment">-- 随机分区点选取</span></span><br><span class="line">  <span class="keyword">local</span> p = <span class="built_in">math</span>.<span class="built_in">random</span>(s,e)</span><br><span class="line">  n[p],n[e]=n[e],n[p]</span><br><span class="line">  p = e</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 已处理区的尾指针</span></span><br><span class="line">  <span class="keyword">local</span> i = s</span><br><span class="line">  <span class="keyword">for</span> j = s,e <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> n[j] &lt; n[p] <span class="keyword">then</span></span><br><span class="line">      n[i],n[j] = n[j],n[i]</span><br><span class="line">      i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> i &lt; p <span class="keyword">then</span></span><br><span class="line">    n[i],n[p]=n[p],n[i]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 快速排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span><span class="params">(n,s,e)</span></span></span><br><span class="line">  <span class="keyword">if</span> s &gt;= e <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">local</span> p = partition(n,s,e)</span><br><span class="line">  quick_sort(n,s,p<span class="number">-1</span>)</span><br><span class="line">  quick_sort(n,p+<span class="number">1</span>,e)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里需要解释一下分区算法的实现思路，它是将待分区的数组分为“已处理”、“未处理”两部分，已处理部分都是小于分区点的元素，其中 i 相当于已处理区的尾指针（已处理和未处理区的分界点，指向的元素属于未处理区），分区过程通过遍历未处理区，如果元素小于分区点，插入到已处理区（与 i 指向的元素进行交换）,最后将分区点与 i 进行交换。</p>
<p>然后分析一下快速排序：</p>
<p>空间复杂度：快速排序也是原址排序，所以空间复杂度为$O(1)$<br>是否稳定排序：因为分区过程中，涉及到元素的交换，所以不是稳定的排序<br>利用主方法还计算快排算法的时间复杂度：</p>
<ol>
<li>首先将递归式写成主方法要求的形式：$T(n)=2T(n/2)+n$</li>
<li>根据上式可知，a = 2，b = 2，f(n)=n。</li>
<li>比较$f(n)=n$，$n^{\log_b^a}=n$，两者相等，所以时间复杂度为:$n{\log}n$</li>
</ol>
<blockquote>
<p>对于快排来说，分区点的选取尤其重要，如果分区点选取不合适，可能造成每次分区都需要遍历整个数组，时间复杂度就会退化为$O(n^2)$，上面采用随机选取分区点，就是为了降低这种可能性。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">时间复杂度</th>
<th style="text-align:left">空间复杂度</th>
<th style="text-align:left">是否稳定排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">$n\log{n}$</td>
<td style="text-align:left">$O(n)$</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">$n\log{n}$</td>
<td style="text-align:left">$O(1)$</td>
<td style="text-align:left">否</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 排序算法(上)</title>
    <url>/2019/01/27/algorithm07/</url>
    <content><![CDATA[<p>在游戏开发中，经常会用到排序算法，比如背包物品排序、排行榜排序等等。本节主要介绍几种排序算法，包括冒泡排序、插入排序、选择排序，快速排序、归并排序、桶排序、基数排序，对于这些排序算法，在平时使用中，应该如何选择呢？或者说应该从哪些方面对比这些算法，通常包括以下几方面：<br><a id="more"></a></p>
<ul>
<li>时间复杂度</li>
<li>空间复杂度（主要比较是否原址排序）</li>
<li>是否稳定</li>
</ul>
<p>在开始正式介绍之前，先把问题和输入描述一下：</p>
<p>将一个数组按照从小到大进行排序。<br>输入：一个包含 n 个元素的数组 v。<br>输出：将数组 v 按照从小到大重排。</p>
<p>然后在安利一个算法可视化网站，<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">这里</a>可以看到各种排序算法执行过程。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序应该算是最简单的一种排序算法了，它的规则是这样：将待排序数据分为已排序和未排序两部分，每次遍历，从数组中找到最小的元素，将它与待排序区第一个元素进行位置交换；剩下的数组还未排序，接着用同样的方法处理剩下的元素，直到整个元素都是有序的。</p>
<img src="/2019/01/27/algorithm07/select_sort.gif">
<p>从问题中，很明显的看出数据规模在不断减小，应该能够很容易的写出它的递归式：</p>
<script type="math/tex; mode=display">
T(v,s)= T(v,s+1) + f(v,i),s+1 < n</script><p>具体实现代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindMinAndSwap</span><span class="params">(v, s)</span></span></span><br><span class="line">    <span class="comment">-- 存储最小值索引</span></span><br><span class="line">    <span class="keyword">local</span> minIndex = s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = s, #v <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v[i] &lt; v[minIndex] <span class="keyword">then</span></span><br><span class="line">            minIndex = i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 交换</span></span><br><span class="line">    v[s], v[minIndex] = v[minIndex], v[s]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelectSort</span><span class="params">(v, s)</span></span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= #v <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 找到最小值并交换</span></span><br><span class="line">        FindMinAndSwap(v, s)</span><br><span class="line"></span><br><span class="line">        SelectSort(v, s + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>非递归形式：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelectSortNoRecursion</span><span class="params">(v)</span></span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #v <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j = i, #v <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> v[j] &lt; v[minIndex] <span class="keyword">then</span></span><br><span class="line">                minIndex = j</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        v[i], v[minIndex] = v[minIndex], v[i]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>下面分析一下它的复杂度：</p>
<ul>
<li>选择排序是一种不稳定排序，因为每次排序都要将最小元素和未排序首元素进行交换。</li>
<li>空间复杂度，因为是原址排序，所以空间复杂度为 O(1)。</li>
<li>时间复杂度，因为包含嵌套循环，并且内存循环规模在不断减小，中间不涉及跳出循环，所以最好情况、最坏情况、平均情况都相同，可以很容易得到时间复杂度为：</li>
</ul>
<script type="math/tex; mode=display">
T(n) = \sum_{k=1}^{n}k = \frac{n(n+1)}{2} = O(n^2)</script><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的思想也比较简单，冒泡排序也是将带排序的数据分为已排序和未排序两个区，每次遍历未排序区，将最大的元素交换到未排序区末尾（排序区头），冒泡排序只进行相邻元素的比较，如果相邻元素不满足排序规则，就交换位置，遍历完之后，最大元素就被交换到了末尾。文字描述不够直观，看下面动画。</p>
<img src="/2019/01/27/algorithm07/bub_sort.gif">
<p>递归式表示 (e 表示未排序区尾端索引)：</p>
<script type="math/tex; mode=display">
BubSort(n,e)=Bub(n,e)+BubSort(n,e-1),(e>1)</script><p>根据递归式转换成Lua代码:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一次冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bub</span><span class="params">(t,e)</span></span></span><br><span class="line">  <span class="keyword">if</span> e &lt; <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>,e<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> t[i] &gt; t[i+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">      t[i],t[i+<span class="number">1</span>] = t[i+<span class="number">1</span>],t[i]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bub_sort</span><span class="params">(t,e)</span></span></span><br><span class="line">    <span class="keyword">if</span> e &lt; <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    bub(t,e)</span><br><span class="line"></span><br><span class="line">    bub_sort(t,e<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面代码是写完了，但是还可以在进行优化，首先看一下上面冒泡函数的意义，它是把最大的元素通过不断的位置交换，最终交换到数组尾部，但是如果没有发生交换呢？不就说明每个元素与后一个元素都满足排序要求，即已经是有序的了，因此如果在一次冒泡中，如果没有发生位置交换，则说明未排序区元素已经有序，排序完成了，下面用非递归再实现一下。</p>
<p>非递归形式：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bub_sort_norecu</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="comment">-- 每次冒泡，未排序区都在减小</span></span><br><span class="line">  <span class="keyword">for</span> i = #t,<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">-- 记录一次冒泡过程中，是否发生了位置交换</span></span><br><span class="line">    <span class="keyword">local</span> swap = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 冒泡：从未排序头-&gt;未排序尾元素</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>,i <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> j &lt; i <span class="keyword">and</span> t[j] &gt; t[j+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">        t[j],t[j+<span class="number">1</span>] = t[j+<span class="number">1</span>],t[j]</span><br><span class="line">        swap = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> swap <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>最好情况渐进时间复杂度为：$O(n)$，最坏情况为：$O(n^2)$，平均情况时间复杂度为：$O(n^2)$，计算过程比较麻烦，下面详细解释一下。</p>
<p>逆序对：在集合A中，<code>i&lt;j</code>并且<code>A[i]&gt;A[j]</code>，则称A[i]、A[j]为逆序对；反之称之为有序对。</p>
<p>对于一个包含 n 个元素的数组，从中任意取出2个元素（前后顺序不能变），一共有$C_n^2$种取法，这两个元素不是有序对就是逆序对，因此：</p>
<script type="math/tex; mode=display">
C_n^2=有序对数+逆序对数</script><p>例如：数组<2,3,8,6,1>的逆序对为：<2,1> <3,1> <8,1> <8,6> <6,1>共5个逆序对。<br>再例如：对于完全有序的数组<1,2,3,4,5,6>，从其中任取两个元素都是有序对，因此有序对个数为：$C_6^2=15$，逆序对个数为：0。<br>排序的过程就是减少逆序对，增加有序对的过程，当逆序对个数为0时，说明排序完毕。</1,2,3,4,5,6></6,1></8,6></8,1></3,1></2,1></2,3,8,6,1></p>
<p>还是回到冒泡排序的平均情况复杂度分析，最好情况是完全有序，即逆序对个数为0；最坏情况为完全逆序，逆序对个数为：$C_n^2$，即需要进行$C_n^2$次位置交换；此时我们可以简单的认为平均情况下需要进行$(0+C_n^2)/2$次交换，因此平均情况时间复杂度为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
  T(n) &= \frac{C_n^2}{2}\\
      &= \frac{n*(n-1)}{4}\\
      &= O(n^2)  
\end{aligned}</script><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本思想是：将数据分为未排序和已排序两个区，已排序区在未排序区之前，将未排序区的元素依次取出，然后插入到已排序区中。</p>
<img src="/2019/01/27/algorithm07/insert_sort.gif">
<p>按照分治策略解决该问题，也比较简单，这里直接上递归式，其中 e 表示w未排序去头端索引：</p>
<script type="math/tex; mode=display">
T(n,e)=T(n,e+1)+insert(n,e)，（e<n）</script><p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.Length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; val)</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来分析一下插入排序的复杂度：</p>
<p>插入排序是一种稳定的算法<br>插入排序为原址排序，所以空间复杂度为：$O(1)$<br>最好情况复杂度：输入的数据完全有序，此时只需要$O(n)$的复杂度<br>最坏情况复杂度：输入的数据完全逆序，此时的复杂度为：$O(n^2)$<br>平均情况复杂度：还是利用上面逆序对来计算，最好情况逆序对为0,最怀情况的逆序对为$C_n^2$，平均情况的逆序对为$C_n^2 / 2$，因此平均情况时间复杂度为：$O(n^2)$</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止，介绍了选择排序、冒泡排序、插入排序，细心的可能已经发现，这三种排序算法都是将集合分为两个区：已排序区、未排序区，不同的地方在于，将未排序元素转换到已排序区中，下面通过一个表格再来总结一下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">是否稳定</th>
<th style="text-align:left">最好情况</th>
<th style="text-align:left">最坏情况</th>
<th style="text-align:left">平均情况</th>
<th style="text-align:left">空间复杂度</th>
<th style="text-align:left">区别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(1)$</td>
<td style="text-align:left">找到最小，放到队头</td>
</tr>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$O(n)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(1)$</td>
<td style="text-align:left">从头到尾，遇大则交换</td>
</tr>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$O(n)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(n^2)$</td>
<td style="text-align:left">$O(1)$</td>
<td style="text-align:left">未排序头元素，从已排序尾向头作比较，将待排元素插入</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 有根树的表示</title>
    <url>/2019/01/26/algorithm06/</url>
    <content><![CDATA[<h1 id="数据结构与算法-有根树的表示"><a href="#数据结构与算法-有根树的表示" class="headerlink" title="数据结构与算法 - 有根树的表示"></a>数据结构与算法 - 有根树的表示</h1><p>前面介绍了链表、队列、栈，它们都是线性数据结构，下面介绍另一种形式的结构-树形结构，它的应用非常广泛，比如堆排序、二叉搜索、A*算法等等，本文不会介绍关于这些算法的东西，主要学习一下有根树相关的一些概念、表示方法，以及一些常用操作的实现。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>什么是树？现实中的树是一个主干，主干上分出很多的枝干，枝干再进分，最后是树叶。有根树与这种结构非常相似，如下图所示。</p>
<img src="/2019/01/26/algorithm06/Tree-Sample.png">
<p>可以看出，树是由一个个结点组成的，结点之间通过线连接，形成一种父子关系，每个结点可以有多个子结点，但是只能有一个父结点，其中有两种比较特殊的结点：</p>
<ul>
<li>根结点：没有父结点的结点</li>
<li>叶子结点：没有子结点的结点</li>
</ul>
<p>关于结点还有几个相关概念：深度、高度、层数。</p>
<ul>
<li>深度：根结点到结点所经历的边数</li>
<li>高度：从最底层叶子结点到结点所经历的边数</li>
<li>层数：结点的深度 + 1</li>
<li>树的高度 = 根结点的高度</li>
</ul>
<img src="/2019/01/26/algorithm06/Tree-HightDepth.png">
<p>关于区分高度和深度有个小窍门，我们平时说高度，比如楼高，都是从底层地面往上数，树的高度也是从最底层往上数；一般说深度，比如水井深度，都是从最顶层往下数，树的深度也是从最顶层往下数。</p>
<p><strong>二叉树</strong>：树的每个结点<strong>最多</strong>有两个子结点</p>
<p><strong>完全二叉树</strong>：树的叶子结点都在最底下两层，最后一层的叶子结点都靠左排列，并且除了最后一层，其它层的子结点数量到达最大。（整个树按照<strong>从左到右、从上到下</strong>遍历过去，中间不能出现空洞，这种完全二叉树适合使用数组进行存储）。</p>
<p><strong>满二叉树</strong>：完全二叉树的进化体，树的叶子结点都在最底层，除了叶子结点，其他结点的子结点数量都达到最大个数。</p>
<img src="/2019/01/26/algorithm06/Tree-CompleteTree.png">
<p>一个包含 n 个元素的完全二叉树，对于任意编号为 i 的元素，具备如下性质：</p>
<ul>
<li>当 i = 0 时，该元素为二叉树的根；i &gt; 0 时，其父结点编号为 $i/2-1$。</li>
<li>i 结点的左子结点如果存在，则索引为 $2i+1$。</li>
<li>i 结点的右子结点如果存在，则索引为 $2i+2$。</li>
</ul>
<h2 id="树的表示法"><a href="#树的表示法" class="headerlink" title="树的表示法"></a>树的表示法</h2><h3 id="左右孩子表示法"><a href="#左右孩子表示法" class="headerlink" title="左右孩子表示法"></a>左右孩子表示法</h3><p>根据不同的需求，树可以有不同的表示方法，对于子结点数量确定的树，如二叉树（最多两个子结点）、四叉树、八叉树，可以使用“父-子”关系表示，即父结点下面连接的结点都是该结点的子结点，大概的结点数据结构类似下面：</p>
<img src="/2019/01/26/algorithm06/Tree-TwoBranchTree.png">
<h3 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h3><p>但是对于子结点数量不确定的树，上面这种表示方法就不太适用了，即使采用一个数组来存储子结点，也有可能造成内存上的浪费。这种情况，可以采用一种叫做“左孩子右兄弟”的表示法，这种表示法中，每个结点都有两个指针：</p>
<ul>
<li>一个指向该结点最左侧的孩子结点</li>
<li>一个指向该结点右侧的兄弟结点</li>
</ul>
<img src="/2019/01/26/algorithm06/Tree-LeftChildRightSibiling.png">
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>在介绍树的遍历之前，不妨根据之前所学的分治策略，来分析一下如何遍历一个树。</p>
<ol>
<li>分解问题，主问题是要遍历根结点以及它所有的子结点、孙子结点等等，可以将问题分解成：<ul>
<li>处理根结点</li>
<li>遍历左子结点</li>
<li>遍历右子结点<br>其中后两个子问题和主问题是相同的，所以可以使用递归。</li>
</ul>
</li>
<li>解决问题，递归什么时候终止呢？如果不能存在左子结点/右子结点时，就应该停止递归。</li>
<li>合并结果。</li>
</ol>
<p>可以写出它的递归公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(node)=T(node.left)+T(node.right)+f(node),(node不为空)
\end{aligned}</script><p>在解决子问题时，根据处理根结点的时序不同，可以分为前序遍历、中序遍历、后序遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">preOrder</span>(<span class="title">binaryTreeNode</span>&lt;T&gt; *<span class="title">t</span>)&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(t!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(t);</span><br><span class="line">      preOrder(t-&gt;leftChild);</span><br><span class="line">      preOrder(t-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">inOrder</span>(<span class="title">binaryTreeNode</span>&lt;T&gt; *<span class="title">t</span>)&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(t!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">      inOrder(t-&gt;leftChild);</span><br><span class="line">      visit(t);</span><br><span class="line">      inOrder(t-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">postOrder</span>(<span class="title">binaryTreeNode</span>&lt;T&gt; *<span class="title">t</span>)&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(t!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">      postOrder(t-&gt;leftChild);</span><br><span class="line">      postOrder(t-&gt;rightChild);</span><br><span class="line">      visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>C#值类型装箱与拆箱</title>
    <url>/2019/01/26/boxandunboxincsharp/</url>
    <content><![CDATA[<h1 id="C-值类型装箱与拆箱"><a href="#C-值类型装箱与拆箱" class="headerlink" title="C#值类型装箱与拆箱"></a>C#值类型装箱与拆箱</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在之前文章中提到了，值类型具有两种表现形式：已装箱和未装箱，这两种状态的转换过程称之为装箱和拆箱。从内存分配的角度来说，装箱就是将值类型经过处理从线程栈复制到托管堆；拆箱则是将已装箱的值类型实例从托管堆复制到线程栈。<br><a id="more"></a></p>
<h2 id="装箱与拆箱的性能损耗"><a href="#装箱与拆箱的性能损耗" class="headerlink" title="装箱与拆箱的性能损耗"></a>装箱与拆箱的性能损耗</h2><p>装箱流程：</p>
<ol>
<li>在托管堆中分配内存，内存大小 = 值类型大小 + 对象指针 + 同步块索引。</li>
<li>逐字段将值类型复制到新分配的内存。</li>
<li>返回对象指针，指针指向新分配的内存，至此，值类型转换成了引用类型。</li>
</ol>
<p>拆箱流程：</p>
<ol>
<li>获取已装箱对象中各个字段的地址，这个过程称之为拆箱，在这个过程开始时会对已装箱对象进行检查，首先检查是否为null，如果为null，抛出NullReferenceException；然后检查已装箱对象是否为所转值类型，如果不是则抛出InvalidCastException。至此拆箱操作已经完成了，拆箱其实就是获取字段指针的过程，但是一般紧接着都会发生一次字段复制，所以也将字段复制考虑到拆箱性能损耗。</li>
<li>将字段逐一从托管堆复制到线程栈中。</li>
</ol>
<h2 id="装箱的产生"><a href="#装箱的产生" class="headerlink" title="装箱的产生"></a>装箱的产生</h2><p>为了避免装箱和拆箱产生性能损耗，首先我们需要知道什么时候我们写的代码会发生装箱操作，下面主要列举四种情形。</p>
<h3 id="1-值类型转换为object类型"><a href="#1-值类型转换为object类型" class="headerlink" title="1. 值类型转换为object类型"></a>1. 值类型转换为object类型</h3><p>最容易发现的一种情况是显示转换为object类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//值类型强转object类型时，发生装箱</span><br><span class="line">int number = 10;</span><br><span class="line">object boxedNumber = number;</span><br></pre></td></tr></table></figure></p>
<p>还有一种比较容易忽略的情况，值类型作为object类型实参，所以很多方法重载多个版本来减少值类型的装箱和拆箱<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int number = 10;</span><br><span class="line"></span><br><span class="line">//调用Console.WriteLine(string,object)函数时，因为第二个参数需要Object类型,</span><br><span class="line">//所以需要将number进行装箱</span><br><span class="line">Console.WriteLine(&quot;Box number:&quot;,number);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-将值类型转换为Interface类型"><a href="#2-将值类型转换为Interface类型" class="headerlink" title="2. 将值类型转换为Interface类型"></a>2. 将值类型转换为Interface类型</h3><p>这是因为接口变量必须包含对堆对象的引用。<br>同样也包括两种情况，一种是显示转换，第二种是作为实参进行传递。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//随意定义</span><br><span class="line">public interface IDoSomething&#123;&#125;</span><br><span class="line"></span><br><span class="line">//自定义结构，实现接口</span><br><span class="line">public struct Vector3 : IDoSomething</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	public void TestBox()</span><br><span class="line">	&#123;</span><br><span class="line">		//生成值类型实例</span><br><span class="line">		Vector3 v = new Vector3();</span><br><span class="line">		</span><br><span class="line">		//将值类型转换为接口类型，此时发生装箱</span><br><span class="line">		IDoSomething ido = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-调用基类方法"><a href="#3-调用基类方法" class="headerlink" title="3. 调用基类方法"></a>3. 调用基类方法</h3><p>在调用值类型实例的基类方法（GetType、MemberwiseClone、ToString、GetHashCode、Equals）时，会造成装箱，原因是在访问基类方法时，需要基类方法由System.Object类型定义，要求this实参是指向托管堆的指针，但是有一种特殊的情况不会造成装箱，那就是，在调用基类virtual方法时，如果override方法没有调用base方法，就不会发生装箱，下面通过代码来详细看下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Vector2</span><br><span class="line">&#123;</span><br><span class="line">	private readonly int _x;</span><br><span class="line">	private readonly int _y;</span><br><span class="line"></span><br><span class="line">	public Vector2(int x,int y)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">		_y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//显式调用基类方法</span><br><span class="line">public void TestBaseCall()</span><br><span class="line">&#123;</span><br><span class="line">	Vector2 v = new Vector2(1,1);</span><br><span class="line"></span><br><span class="line">	//由于调用基类的ToString方法，所以会发生装箱</span><br><span class="line">	Console.WriteLine(v.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义的类型重写了基类的virtual方法，并且override方法中没有调用base，则不会造成装箱<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Vector2</span><br><span class="line">&#123;</span><br><span class="line">	private readonly int _x;</span><br><span class="line">	private readonly int _y;</span><br><span class="line"></span><br><span class="line">	public Vector2(int x,int y)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">		_y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//重写基类的ToString方法，并且不能调用base.ToString</span><br><span class="line">	public override string ToString()</span><br><span class="line">	&#123;</span><br><span class="line">		return string.Format(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;,_x.ToString(),_y.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void TestVirtualCall()</span><br><span class="line">&#123;</span><br><span class="line">	Vector2 v = new Vector2(1,1);</span><br><span class="line">	</span><br><span class="line">	//调用v的ToString方法，由于v重写了ToString方法</span><br><span class="line">	//并且没有调用基类的ToString方法，所以不会造成装箱</span><br><span class="line">	Console.WriteLine(v.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了以上这些显示的调用，在一些类的实现当中，也会涉及到基类方法的调用，比如Dictionary，HashTable需要调用对象的GetHashCode计算哈希码，如果没有重写GetHashCode就会造成装箱，解决办法是重写GetHashCode方法和Equals方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Vector2</span><br><span class="line">&#123;</span><br><span class="line">	private readonly int _x;</span><br><span class="line">	private readonly int _y;</span><br><span class="line"></span><br><span class="line">	public Vector2(int x,int y)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">		_y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//重写基类的ToString方法，并且不能调用base.ToString</span><br><span class="line">	public override string ToString()</span><br><span class="line">	&#123;</span><br><span class="line">		return string.Format(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;,_x.ToString(),_y.ToString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void TestBaseCall()</span><br><span class="line">&#123;</span><br><span class="line">	Dictionary&lt;Vector2,object&gt; testMap = new Dictionary&lt;Vector2,object&gt;();</span><br><span class="line">	</span><br><span class="line">	//由于向Dictionary添加元素时需要调用GetHashCode，而且Vector2类型没有重写GetHashCode</span><br><span class="line">	//所以会造成装箱。</span><br><span class="line">	testMap.Add(new Vector2(1,1),new object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，已将将常见的装箱情况总结完了，在平时编码过程中，如果对一些代码是否会发生装箱、拆箱不太确定，可以使用反编译工具，查看IL编码来查看是否包含box语句来判断，这里推荐使用开源工具<a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy</a>进行查看。</p>
]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的值类型与引用类型</title>
    <url>/2019/01/26/valuetypevsreftype/</url>
    <content><![CDATA[<h1 id="C-中的值类型与引用类型"><a href="#C-中的值类型与引用类型" class="headerlink" title="C#中的值类型与引用类型"></a>C#中的值类型与引用类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Clr包括对象类型分为两种：值类型、引用类型<br>引用类型和值类型都可以通过new来实例化，引用类型在调用new时，clr在托管堆为实例分配内存，并将内存地址返回，而值类型再调用new时，clr在线程栈上为实例分配内存，并返回值本身。<br>下面从几个方面对值类型和引用类型进行对比。<br><a id="more"></a></p>
<h2 id="值类型与引用类型对比"><a href="#值类型与引用类型对比" class="headerlink" title="值类型与引用类型对比"></a>值类型与引用类型对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th>—-</th>
<th style="text-align:center">值类型</th>
<th style="text-align:right">引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存分配</td>
<td style="text-align:center">线程栈</td>
<td style="text-align:right">托管堆</td>
</tr>
<tr>
<td>内存回收</td>
<td style="text-align:center">直接释放</td>
<td style="text-align:right">等待垃圾回收器回收</td>
</tr>
<tr>
<td>new实例</td>
<td style="text-align:center">返回值本身</td>
<td style="text-align:right">返回内存地址，如果垃圾回收器第0代内存满时，可能引起垃圾回收</td>
</tr>
<tr>
<td>变量赋值</td>
<td style="text-align:center">逐字段复制</td>
<td style="text-align:right">赋值内存地址</td>
</tr>
<tr>
<td>类型特点</td>
<td style="text-align:center">轻量、无额外字段</td>
<td style="text-align:right">需要额外字段（类型地址指针、同步块索引）</td>
</tr>
<tr>
<td>常见类型</td>
<td style="text-align:center">数值类型、枚举类型、struct类型</td>
<td style="text-align:right">string、clas类</td>
</tr>
<tr>
<td>是否支持继承</td>
<td style="text-align:center">值类型都是密封类型，所以不支持继承</td>
<td style="text-align:right">单继承</td>
</tr>
<tr>
<td>接口实现</td>
<td style="text-align:center">支持</td>
<td style="text-align:right">支持</td>
</tr>
<tr>
<td>表现方式</td>
<td style="text-align:center">未装箱、已装箱</td>
<td style="text-align:right">总是已装箱</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中利用反射创建各种对象</title>
    <url>/2019/01/26/createinstancebyreflect/</url>
    <content><![CDATA[<h1 id="反射构造各种类型实例"><a href="#反射构造各种类型实例" class="headerlink" title="反射构造各种类型实例"></a>反射构造各种类型实例</h1><p>在使用反射时，经常要动态的创建各种类型的实例对象，下面就总结一下，如何使用反射创建普通类型对象、数组、委托、泛型对象。<br><a id="more"></a></p>
<h2 id="一般类型对象"><a href="#一般类型对象" class="headerlink" title="一般类型对象"></a>一般类型对象</h2><p>对于一般类型，直接使用Activity.CreateInstance(Type)进行创建。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">object</span> obj = Activitor.CreateInstance(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><ol>
<li>使用Activitor.CreateInstance创建  </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//数组元素类型</span></span><br><span class="line">        Type elementType = <span class="keyword">typeof</span>(Data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据数组元素类型，生成数据类型，MakeArrayType可以传递int参数，表示数组的维数</span></span><br><span class="line">        <span class="comment">//默认不传递的话，表示一维数组</span></span><br><span class="line">        Type arrayType = elementType.MakeArrayType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用Activitor.CreateInstance创建数组对象实例</span></span><br><span class="line">        <span class="comment">//注意，必须向构造器传递数组的长度，这里为10</span></span><br><span class="line">        <span class="keyword">object</span> arrObj = Activator.CreateInstance(arrayType,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(((Data[])arrObj).Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用Array.CreateInstance进行创建</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//数组元素类型</span></span><br><span class="line">        Type elementType = <span class="keyword">typeof</span>(Data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个参数为数据元素的类型，第二个为数组长度</span></span><br><span class="line">        <span class="comment">//Array.CreateInstance还提供了其他几个重写方法，可以支持多为数组的创建</span></span><br><span class="line">        Array arrObj = Array.CreateInstancee(elementType,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="委托类型创建"><a href="#委托类型创建" class="headerlink" title="委托类型创建"></a>委托类型创建</h2><p>委托类型创建，可以通过Delegate.CreateDelegate(Type,object,MethodInfo);</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> delete <span class="keyword">void</span> <span class="title">CustomDele</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//创建静态函数的委托</span></span><br><span class="line">        CreateStaticDelete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建成员函数的委托</span></span><br><span class="line">        CreateInstanceDelete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateStaticDelete</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//要生成委托的类型</span></span><br><span class="line">        Type delType = <span class="keyword">typeof</span>(CustomDele);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要绑定的方法</span></span><br><span class="line">        MethodInfo mInfo = <span class="keyword">typeof</span>(Program).GetMethod(<span class="string">"SayHello"</span>,BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用Delegate.CreateDelegate()创建委托</span></span><br><span class="line">        <span class="comment">//第一个参数为委托类型</span></span><br><span class="line">        <span class="comment">//第二个参数为方法实体对象，如果是成员函数，需要制定，静态则不需要指定</span></span><br><span class="line">        <span class="comment">//第三个参数为绑定方法的MethodInfo</span></span><br><span class="line">        Delegate deleObj = Delegate.CreateDelegate(delType,<span class="literal">null</span>,mInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用委托，如果委托具备参数，可以向DynamicInvoke传递参数</span></span><br><span class="line">        deleObj.DynamicInvoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateInstanceDelete</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取委托类型</span></span><br><span class="line">        Type delType =<span class="keyword">typeof</span>(CustomDele);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建实例对象</span></span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        MethodInfo mInfo = <span class="keyword">typeof</span>(Cat).GetMethod(<span class="string">"Sleep"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为委托要绑定的是成员函数，所以要传递类实例</span></span><br><span class="line">        Delegate deleObj = Delegate.CreateDelegate(delType,cat,mInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用委托</span></span><br><span class="line">        CustomDele act = (CustomDele)deleObj;</span><br><span class="line">        act();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sleep</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建泛型对象"><a href="#创建泛型对象" class="headerlink" title="创建泛型对象"></a>创建泛型对象</h2><blockquote>
<p>在创建泛型对象之前，首先要了解一下泛型相关的知识，泛型可以分为开发类型和封闭类型。<br><strong>开放类型</strong>是指未指定了泛型的类型参数的泛型，如Dictionary<tkey,tvalue>就是开放类型，开放类型是不能构造实例的，很好理解，因为不知道创建的TKey，TValue是什么类型。<br><strong>封闭类型</strong>是指指定了泛型类型参数的，如Dictionary<string,int>这里的string类型和int类型称之为类型实参。</string,int></tkey,tvalue></p>
</blockquote>
<p>下面看一下如何具体创建一个泛型实例对象</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//首先获取泛型的开放类型</span></span><br><span class="line">        Type openType = <span class="keyword">typeof</span>(Dictionary&lt;,&gt;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后获取封闭类型</span></span><br><span class="line">        Type closeType = openType.MakeGenericType(<span class="keyword">typeof</span>(<span class="keyword">string</span>),<span class="keyword">typeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后根据封闭类型创建类型实例</span></span><br><span class="line">        <span class="keyword">object</span> obj = Activitor.CreateInstance(closeType);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(obj.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 分治策略</title>
    <url>/2019/01/24/algorithm05/</url>
    <content><![CDATA[<h1 id="数据结构与算法-分治策略"><a href="#数据结构与算法-分治策略" class="headerlink" title="数据结构与算法 - 分治策略"></a>数据结构与算法 - 分治策略</h1><p>前面介绍了一些复杂度分析方法，以及一些基础的数据结构，后续将会开始介绍一些常见算法和一些高级的数据结构，在介绍这些内容之前呢，首先需要先了解一下分治策略，分治策略只是为解决某些问题提供了指导思想，真正落到编码上的，其实是递归方法，因此可以认为递归是分治策略的一种实现手段。</p>
<a id="more"></a>
<p>考虑这么一个情景，小A去电影院看电影，入座之后，小A想知道自己是第几排，但是灯光比较暗，不好一排排数，小A就问他前排，心想如果知道前排是第几，就能知道自己排数了。但是前排同样也不知道，他也问前一排，就这样一直问道第一排，它回复后面说自己在第一排，就这么一排排回复过去，最后小A就知道自己所在排数了。</p>
<p>另一个比较常见的例子是阶乘的求解，我们知道：$!n = !(n-1) * n$，即 n 的阶乘等于 n-1 的阶乘乘以 n。</p>
<p>这些都是分治策略的典型应用，采用分治法解决问题，包含以下三个步骤：</p>
<ol>
<li>分解：问题能够分解多个子问题，子问题的形式与原问题相同，只是规模更小。比如上面阶乘的例子，把 n 阶乘的问题，分解为 n-1 阶乘子问题；电影院例子中把“当前第几排”分解为“前排第几排”。这些子问题的特点都是规模在不断缩小。</li>
<li>解决：当问题经过递归的分解之后，子问题规模已经足够小，可以终止递归，直接求解。上面电影院例子中，当到第一排之后，不需要再问前排；阶乘例子中，1的阶乘等于1，即分解到1之后就停止了。</li>
<li>合并：子问题的解能够组合成原问题的解。先说电影院例子，知道前排结果之后，只需要+1就是所求结果；阶乘例子中，知道n-1阶乘之后，乘以n就是所求结果。</li>
</ol>
<h2 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h2><p>递归式是用来描述递归的，它通常是一个等式或者不等式。上面两个例子，我们可以用文字来描述分治的三个步骤，虽然很详细，但是还是不够直观，下面看看用递归式怎么描述？</p>
<ul>
<li>电影院：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
    T(n) = \begin{cases}
        1&(n=1)\\
        T(n-1)+1&(n>1)\\
    \end{cases}
\end{aligned}</script><p>当前排问题 T(n)，可以分解为前排问题 T(n-1)，当递归到第一排时，不需要再进行递归，可以直接求解。</p>
<ul>
<li>阶乘：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
    T(n)= \begin{cases}
        1&(n=1)\\
        T(n-1)*n&(n>1)\\
    \end{cases}
\end{aligned}</script><p>递归式是解决递归问题的关键，通过将主问题分解成多个规模更小的子问题，在编写递归函数时，可以认为子问题已经解决（第二步），不要企图在脑子里面一层一层的思考递归怎么执行，那样就会走进思维误区；把关注点放到子问题的分解和合并上（第一、三步），这样能够帮助我们轻松的编写递归代码。</p>
<h2 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>再看一个类似的例子，小A上楼要走 n 阶台阶，每一步只能走 1-2 阶，求小A 上楼有多少种走法。</p>
<p>我们先使用暴力枚举法，看看如何解决该问题，这里直接上代码，还是比较容易理解。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get_GoUpstairSitCnt</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="comment">-- 存储各种走法所走的台阶数</span></span><br><span class="line">    <span class="comment">-- 初始时，第一步有两种走法：1阶、2阶</span></span><br><span class="line">    <span class="keyword">local</span> t = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      t = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      t = &#123;<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 每走一步，都分为两种情形，即都会增加一种情况</span></span><br><span class="line">    <span class="comment">-- 最多走的步数不会超过台阶数 n</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> allsituations = #t</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,allsituations <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 走 1 阶</span></span><br><span class="line">        <span class="keyword">if</span> t[j] &lt; n <span class="keyword">then</span></span><br><span class="line">          t[j] = t[j] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 走 2 阶</span></span><br><span class="line">        <span class="keyword">if</span> t[j] &lt; n <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">table</span>.<span class="built_in">insert</span>(t,t[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> #t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>暴力枚举法的时间复杂度具体的我们先不去关心，但是通过嵌套循环就知道复杂度不低，接着尝试用分治策略，看看能不能求解该问题。下面按照分支策略步骤一步步来分析。</p>
<ol>
<li>分解问题，要走 n 阶台阶，初始时能够确定的只有第一步的走法：1阶、2阶，走完第一步，那么剩下的怎么走呢，能够发现这个和主问题是一样的，只不过台阶减少了，即问题的规模变小了，因此可以采用递归来解决。通过上面分析，我们得到两个子问题：<ol>
<li>第一步走 1 阶，剩余台阶的走法</li>
<li>第一步走 2 阶，剩余台阶的走法</li>
</ol>
</li>
<li>解决问题，上面两个问题都是采用递归来解决，解决递归就是要找到它的终止条件，考虑一下，什么时候递归可以停止呢？<ol>
<li>剩余 1 阶，只有 1 种走法</li>
<li>剩余 2 阶，只有 2 种走法</li>
</ol>
</li>
<li>合并，将两种子问题结果相加，就是主问题的解。</li>
</ol>
<p>经过上面的分析，应该能够很容易的写出递归式了。</p>
<script type="math/tex; mode=display">
T(n)=\begin{cases}
  1&(n=1)\\
  2&(n=2)\\
  T(n-1)+T(n-2)&(n>2)
\end{cases}</script><p>有了递归式，代码就很容易写了：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">T</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">elseif</span> n==<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> T(n<span class="number">-1</span>)+T(n<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="求解最大数组"><a href="#求解最大数组" class="headerlink" title="求解最大数组"></a>求解最大数组</h3><p>再看一个复杂一点的例子，一个包含正负元素的数组，求它的连续子数组中，元素求和值最大的子数组。例如下面一个数组：</p>
<img src="/2019/01/24/algorithm05/Recursion.png">
<p>解决这个问题的办法有很多，最简单暴力的方法，就是遍历各种可能性，然后查找最大值，代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- Lua示例</span></span><br><span class="line"><span class="comment">--- 查找最大子数组</span></span><br><span class="line"><span class="comment">--- 因为 Lua 数组下标从 1 开始，所以输出的结果为：43、5、8</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find_Max_Subarray</span><span class="params">(arr)</span></span></span><br><span class="line">  <span class="keyword">local</span> low,high</span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">max</span> = <span class="built_in">math</span>.mininteger</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>,#arr <span class="keyword">do</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j = i,#arr <span class="keyword">do</span></span><br><span class="line">      sum = sum + arr[j]</span><br><span class="line">      <span class="keyword">if</span> sum &gt; <span class="built_in">max</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">max</span> = sum</span><br><span class="line">        low = i</span><br><span class="line">        high = j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>,low,high</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这段代码的渐进复杂度为$T(n) = O(n^2)$，可以看到暴力枚举法的复杂度比较高，通过分治策略，看看能不能找到其他的解决办法。根据分治策略的执行步骤，我们尝试着来做一下：</p>
<ol>
<li>首先需要对问题进行分解，即缩小问题规模，我们可以简单的把数组均分，那么问题就变成了，如何在两个分数组中查找最大子数组。这里可以分为三种情况，可能在左侧分数组、可能在右侧分数组、可能跨越两个数组，考虑这三种情况，可以得到四个子问题：<ul>
<li>在左侧分数组中，查找最大子数组</li>
<li>在右侧分数组中，查找最大子数组</li>
<li>跨越左右分数组，查找最大子数组</li>
<li>比较前面三种问题的解，得到最优的解</li>
</ul>
</li>
</ol>
<p>在上面四个子问题中，前两种个和主问题相同，都是求一个数组的最大子数组，只不过数据规模变小了，可以采用递归来计算。</p>
<ol>
<li>第二步需要解决子问题，这里子问题有四个，但是前两是相同的。先考虑前两个子问题的怎么解决，随着问题规模不断的递归分解，最终需要求解的数组元素只有一个了，此时子问题已经足够简单，可以直接给出解，终止递归；第三个子问题是从两个数组中，找到横跨两个数组的最大数组，该子问题与主问题已经主问题不同了，所以这里就没有必要递归了，直接求解即可，代码见下；最后一个子问题，和主问题也不相同，所以直接求解。</li>
<li>最后一步是合并，这一步比较简单，就是根据前三个子问题的解，在第四个子问题中进行比较，得出主问题的解。</li>
</ol>
<p>使用递归式描述如下：</p>
<script type="math/tex; mode=display">
T(arr,low,high)=\begin{cases}
  arr[low]&(low = high)\\
  max(T(arr,low,mid),
  T(arr,mid,high),G(arr,low,mid,high))&(low < high,mid = \left \lfloor {(low + high)/2} \right \rfloor)
\end{cases}</script><p>这里先给出第三个子问题的求解的 Lua 代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find_Max_Cross_Subarray</span><span class="params">(arr,low,mid,high)</span></span></span><br><span class="line">  <span class="comment">-- 保存最大子数组的起始索引</span></span><br><span class="line">  <span class="keyword">local</span> left_index,right_index</span><br><span class="line">  <span class="keyword">local</span> leftMax = <span class="built_in">math</span>.mininteger</span><br><span class="line">  <span class="keyword">local</span> rightMax = <span class="built_in">math</span>.mininteger</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 查找左侧最大子数组</span></span><br><span class="line">  <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i = mid,low,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + arr[i]</span><br><span class="line">    <span class="keyword">if</span> sum &gt; leftMax <span class="keyword">then</span></span><br><span class="line">      leftMax = sum</span><br><span class="line">      left_index = i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 查找右侧最大子数组</span></span><br><span class="line">  sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i = mid+<span class="number">1</span>,high <span class="keyword">do</span></span><br><span class="line">    sum = sum + arr[i]</span><br><span class="line">    <span class="keyword">if</span> sum &gt; rightMax <span class="keyword">then</span></span><br><span class="line">      rightMax = sum</span><br><span class="line">      right_index = i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 合并两边</span></span><br><span class="line">  <span class="keyword">return</span> leftMax+rightMax,left_index,right_index</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>第三个子问题解决之后，因为前两个子问题与主问题相同，而最后一个子问题又需要前三个子问题的结果，所以这里就直接求解主问题，直接上 Lua 代码。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find_Max_Subarray_Recursion</span><span class="params">(arr,low,high)</span></span></span><br><span class="line">  <span class="comment">-- 当递归不断执行，进行一段时间之后，数组只剩一个元素，此时不需要再进行递归，可以直接得出结果</span></span><br><span class="line">  <span class="keyword">if</span> low == high <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> arr[low],low,high</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 将数组分为左右两部分，即将问题分解为更小规模子问题</span></span><br><span class="line">    <span class="comment">-- 将中间值向下取整</span></span><br><span class="line">    <span class="keyword">local</span> mid = (low + high) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 左侧分数组求解</span></span><br><span class="line">    <span class="keyword">local</span> leftMax,leftLow,leftHigh = Find_Max_Subarray_Recursion(arr,low,mid)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 右侧分数组求解</span></span><br><span class="line">    <span class="keyword">local</span> rightMax,rightLow,rightHigh = Find_Max_Subarray_Recursion(arr,mid+<span class="number">1</span>,high)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 跨越左右分数组求解</span></span><br><span class="line">    <span class="keyword">local</span> crossMax,crossLow,crossHigh = Find_Max_Cross_Subarray(arr,low,mid,high)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 比较三种问题的解，得出最大子数组</span></span><br><span class="line">    <span class="keyword">if</span> leftMax &gt; rightMax <span class="keyword">and</span> leftMax &gt; crossMax <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> leftMax,leftLow,leftHigh</span><br><span class="line">    <span class="keyword">elseif</span> rightMax &gt; leftMax <span class="keyword">and</span> rightMax &gt; crossMax <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> rightMax,rightLow,rightHigh</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> crossMax,crossLow,crossHigh</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="递归中的重复计算问题"><a href="#递归中的重复计算问题" class="headerlink" title="递归中的重复计算问题"></a>递归中的重复计算问题</h2><p>还是看上面爬楼梯的例子，其中包含了很多重复的计算，随着 n 值的减小，重复的次数呈指数级递增，以 n = 6 为例，通过下面的图示，对重复计算有个直观了解。</p>
<img src="/2019/01/24/algorithm05/dumpli.png">
<p>从上图可以看出来，对 n = 2 计算了 5 次，n = 3 计算了 3 次，如果 n 增长到7，6结点下面的所有结点重复次数将会递增 1 倍，这种指数级的重复增长，是对资源的极大浪费，一个解决办法就是采用缓存，将计算过结果缓存起来，爬楼梯的例子修改如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> cache = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">T</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">elseif</span> n==<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> cache[n] ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> cache[n]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> count = T(n<span class="number">-1</span>) + T(n<span class="number">-2</span>)</span><br><span class="line">  cache[n] = count</span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="根据递归式计算时间复杂度"><a href="#根据递归式计算时间复杂度" class="headerlink" title="根据递归式计算时间复杂度"></a>根据递归式计算时间复杂度</h2><p>递归式的一个非常重要的应用，是用来计算递归算法的时间复杂度，在《算法导论》一书中介绍了三种根据递归式来计算时间复杂度的解法。分别是：</p>
<ul>
<li>代入法</li>
<li>递归树法</li>
<li>主方法求解递归式</li>
</ul>
<p>代入是首先要求对递归式的解作出猜测，然后将猜测的值代入递归式进行验证，所以这就要求计算着对数学公式比较敏感，否则比较难猜测出正确的解；递归树法是将递归过程，利用树形结构进行表示，然后通过观察树的结构，来对解作出猜测，再将猜测结果代入递归式进行验证；这里主要介绍第三种方法，通过递归式的主方法来进行求解。</p>
<p>主方法求解是将递归式表示成如下形式：</p>
<script type="math/tex; mode=display">
T(n)=aT(n/b) + f(n)</script><p>以上递归式描述是这样的：将一个规模为 n 的问题分解为 a 个子问题，每个子问题的规模为 $n/b$，时间复杂度为 $T(n/b)$；$f(n)$是子问题分解、组合所花费的时间。</p>
<blockquote>
<p>需要注意的是，这里 $n/b$ 可能不为整数，但是替换成 $T(\left \lfloor n/b \right \rfloor)$或$T(\left \lceil n/b \right \rceil)$对渐进时间复杂度并不会产生影响，所以后续的计算都是忽略舍入问题的。</p>
</blockquote>
<p>主方法依赖于下面的主定理：</p>
<p>令$a\geqslant{1}、b&gt;1$是常数，$f(n)$是函数。则对于递归式：</p>
<script type="math/tex; mode=display">
T(n)=aT(n/b)+f(n)</script><p>$T(n)$的渐进复杂度满足下面三种情况：</p>
<script type="math/tex; mode=display">
T(n)=\begin{cases}
  \Theta(n^{\log_{b}^{a}})&f(n)=O(n^{\log_b^{a-\varepsilon}}),{\varepsilon}>0\\
  \Theta(n^{\log_{b}^{a}}{\lg}n)&f(n)=\Theta(n^{\log_b^a})\\
  \Theta(f(n))&f(n)={\Omega}(n^{\log_b^{a+\varepsilon}}),{\varepsilon}>0\\
\end{cases}\\</script><p>主定理根据 $f(n)$ 与 $n^{\log_b^a}$ 的关系，分为三种情况，首先T(n)的渐进复杂度是由两者之间较大的值决定的，若 $n^{\log_b^a}$ 更大，则为第一种情况；若$f(n)$更大，则满足第3种情况；若两者值相当，则满足第2种情况，对 $n^{\log_b^a}$ 乘上一个对数因子。</p>
<p>需要注意的是，f(n)与$n^{\log_b^a}$两者比较的是渐进界，对于两者的渐进界比较结果和多项式比较结果如果不一致，说明此时不在上面三种情况之中，因此此时就主定理就不再适用。</p>
<p>通过两个例子，看看主方法怎么用。</p>
<p>先看第一个例子：</p>
<script type="math/tex; mode=display">
T(n)=9T(n/3)+n</script><ul>
<li>首先，对于这个递归式，可以知道$a=9,b=3,f(n)=n$</li>
<li>然后，比较$f(n)=n$、$n^{\log_b^a}$=$n^{\log_3^9}$=$n^3$ 两者的渐进界，符合第一种情况，因此</li>
</ul>
<script type="math/tex; mode=display">
T(n)=\Theta(n^{\log_{b}^{a}})=\Theta(n^{\log_3^9})=\Theta(n^2)</script><p>再看第二个例子：</p>
<script type="math/tex; mode=display">
T(n)=T(2n/3)+1</script><ul>
<li>首先，根据递归式可知：$a=1,b=3/2,f(n)=1$</li>
<li>然后，比较 $f(n)=1$ 和 $n^{\log_b^a}$ = $n^0$ = 1 比较两者的渐进界，满足第2种情况，因此:</li>
</ul>
<script type="math/tex; mode=display">
T(n)=\Theta(n^{\log_{b}^{a}}{\lg}n)=\Theta(\lg{n})</script><blockquote>
<p>关于主方法这部分内容，详细可以参考《算法导论》的第四章，里面给出了更加详细的介绍和证明。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 队列</title>
    <url>/2019/01/21/algorithm04/</url>
    <content><![CDATA[<h1 id="数据结构与算法-队列"><a href="#数据结构与算法-队列" class="headerlink" title="数据结构与算法 - 队列"></a>数据结构与算法 - 队列</h1><p>在上一篇介绍了栈，栈是一种<strong>后进先出</strong>的数据结构，本章将要介绍的是队列，队列是<strong>先进先出</strong>结构，比如取车站排队取票，谁先来的谁先取，新来的只能后取。</p>
<a id="more"></a>
<p>可以向队列中插入、删除数据，其专有称呼为“入队”、“出队”：</p>
<ul>
<li>入队：向队尾添加元素</li>
<li>出队：从队头删除元素</li>
</ul>
<img src="/2019/01/21/algorithm04/Queue-Enqueue.png">
<img src="/2019/01/21/algorithm04/Queue-Dequeue.png">
<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>队列的实现可以采用数组或者链表，本文实现基于数组的队列，队列常用的操作包括：入队、出队、获取队头元素。从上图可以看出，一个队列需要两个指针，队头指针指向队列的第一个元素，队尾指针是一个尾后指针，指向最后一个元素的下一个位置。</p>
<p>入队：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params">T item</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.Length)&#123;</span><br><span class="line">        T[] newArray = <span class="keyword">new</span> T[items.Length == <span class="number">0</span> ? defaultSize : items.Length * <span class="number">2</span>];</span><br><span class="line">        Array.Copy(items, newArray, items.Length);</span><br><span class="line">        items = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail++;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Dequeue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"Queue under flow"</span>);</span><br><span class="line">    <span class="keyword">var</span> item = items[head];</span><br><span class="line">    items[head] = <span class="keyword">default</span>(T);</span><br><span class="line">    head++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码看起来没上面问题，但是自信分析之后，就会发现，随着不断的插入、删除元素，数组就会不断的扩容，并且数组会随着队头指针的移动，造成数组头部会有一部分空间被闲置。如何利用这部分闲置的空间呢？最直接的办法就是当数组满时，将数据移动到头部，这种数据移动效率比较低，其实有另一种比较常见的方法，是采用循环队列。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列实现有以下几点需要注意：</p>
<ol>
<li>入队时，尾指针并不是简单的自增，需要使之能够循环，即 $Tail = (Tail + 1）% length$</li>
<li>出队时，头指针能够循环，即$Head = (Head + 1)% length$</li>
<li>动态扩容时，如果$Head<tail$，只需要将数组原样拷贝到新数组；否则就需要根据队列顺序拷贝元素，即 head->数组结尾，0-&gt;Head，见下图。</tail$，只需要将数组原样拷贝到新数组；否则就需要根据队列顺序拷贝元素，即></li>
</ol>
<img src="/2019/01/21/algorithm04/Queue-CircleExpand.png">
<p>详细代码在<a href="https://github.com/huosk/Algo/blob/master/CSharp/Collections/Queue.cs" target="_blank" rel="noopener">这里</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>队列在大部分语言中都有实现，C# 语言中就采用循环队列来实现，感兴趣的可以参考<a href="https://referencesource.microsoft.com/#System/compmod/system/collections/generic/queue.cs,6dba415a0e1792b0" target="_blank" rel="noopener">这里</a>。在日常开发中，队列也是一种比较常用的数据结构，比如异步任务队列、线程池、消息队列等等。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 栈</title>
    <url>/2019/01/20/algorithm03/</url>
    <content><![CDATA[<h1 id="数据结构与算法-栈"><a href="#数据结构与算法-栈" class="headerlink" title="数据结构与算法 - 栈"></a>数据结构与算法 - 栈</h1><p>栈是一种<strong>后进先出</strong>的数据结构，栈的常见操作包括入栈（Push）、出栈（Pop），栈就好像一摞盘子，每次放盘子总是放到最上面，同样每次也是从最上面取。</p>
<a id="more"></a>
<img src="/2019/01/20/algorithm03/Stack_Push.png">
<img src="/2019/01/20/algorithm03/Stack_Pop.png">
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>可以使用数组或者链表来实现栈结构，本文采用基于数组的链表实现，下面主要实现栈的入栈、出栈、查询栈顶元素等操作。</p>
<p>入栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.Length)&#123;</span><br><span class="line">        T[] newArray = <span class="keyword">new</span> T[items.Length == <span class="number">0</span> ? defaultSize : items.Length * <span class="number">2</span>];</span><br><span class="line">        Array.Copy(items, newArray, items.Length);</span><br><span class="line">        items = newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size++] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> (<span class="keyword">new</span> InvalidOperationException(<span class="string">"stack under flow"</span>));</span><br><span class="line"></span><br><span class="line">    var top = items[--size];</span><br><span class="line">    items[size] = <span class="keyword">default</span>(T);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码在<a href="https://github.com/huosk/Algo/blob/master/CSharp/Collections/Stack.cs" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>栈这种数据结构在日常开发中还是比较常用的，主要的应用场景包括：</p>
<ul>
<li>函数调用</li>
<li>表达式求值</li>
<li>括号匹配</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>在进行单步调试时，可能经常会看到调用栈这个东西，正如它的名字所指，它是一种栈结构，我们通过一段代码来简单看下它是如何工作的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="keyword">add</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> v1,<span class="keyword">int</span> v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = v1 + v2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/01/20/algorithm03/Stack_Pop-FuncCall.png">
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>编译器通常利用两个栈来实现表达式的计算，其中一个栈用来保存操作数，另一个栈来保存操作符。</p>
<p>开始时，从左向右遍历表达式，当遇到操作数时，直接压入操作数栈；当遇到运算符时，就需要与操作符栈顶元素进行比较，如果栈顶元素优先级高，将当前运算符入栈；如果比栈顶元素优先级低或者相同，取出栈顶运算符，从操作数栈取出相应数量的操作数，然后进行计算，最后把计算结果压入操作数栈，继续执行比较。</p>
<p>下面通过一个流程图来帮助一下理解。</p>
<img src="/2019/01/20/algorithm03/Stack_Pop-Expression.png">
<p><a href="https://github.com/huosk/Algo/blob/master/CSharp/Sample/Stack/Expression.cs" target="_blank" rel="noopener">这里</a>有一个非常简单的示例</p>
<h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>假如要解析字符串，其中包括圆括号()、方括号[]、大括号{}，它们必须成对出现，并且可以相互嵌套。那么如何检测括号是否合法呢？</p>
<p>用栈这种数据结构能够非常简单的解决此问题，同样需要从左往右遍历字符串，遇到左括号时，直接入栈；遇到右括号，与栈顶元素是否成对儿，成对儿则弹出，否则不合法；字符串遍历完成之后，如果栈不为空，则不合法。</p>
<p>流程图如下:</p>
<img src="/2019/01/20/algorithm03/Stack_Bracket.png">]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Jenkins在Unity3D项目中的使用</title>
    <url>/2019/01/19/jenkinswithunity/</url>
    <content><![CDATA[<h1 id="Jenkins在Unity3D项目中的使用"><a href="#Jenkins在Unity3D项目中的使用" class="headerlink" title="Jenkins在Unity3D项目中的使用"></a>Jenkins在Unity3D项目中的使用</h1><p>Jenkins是一款开源的持续集成(CI)、持续交付(CD)软件，主要用于各种任务的自动化，包括自动构建、自动测试和自动部署系统。<br><a id="more"></a></p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><p>我这里使用的环境是Windows，其他的安装方法可以参考<a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">这里</a>。</p>
<p>Jenkins的安装方式有很多种，我这里直接使用Window安装包进行安装，这里是<a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">下载地址</a>，安装过程比较简单，没上面需要多说的，安装完成之后，Jenkins服务就会自动启动。</p>
<h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h2><p>因为这里主要针对的是Unity3D项目的自动构建，所以在进行Jenkins配置之前，需要提前安装好Unity3D编辑器。</p>
<p>各种环境安装完成之后，在浏览器中输入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 登录jenkins，第一次登录需要初始密码，根据界面提示可以在相应文件中找到，只需要重新注册账号密码即可。</p>
<p>在成功登录到 Jenkins 之后，按照下面步骤配置Jenkins：</p>
<ul>
<li>安装 Unity3D 构建插件。打开“系统设置-&gt;插件管理”页面，在“Available”标签内搜索“unity3d”，然后选择unity3d插件进行安装，安装完成之后重启Jenkins。</li>
</ul>

<img src="/2019/01/19/jenkinswithunity/searchunityplugin.png">
<ul>
<li>配置 Unity3D 全局工具。打开“系统设置-&gt;全局工具配置”，找到Unity3D工具，点击“Add Unity3D”按钮，然后输入名字，和Unity3D的安装目录。</li>
</ul>
<img src="/2019/01/19/jenkinswithunity/settool.png">
<ul>
<li>配置 Unity3D 全局默认配置。打开“系统设置-&gt;系统设置”，在下面找到“Unity3d default configuration”，在“Global argLine”中输入：</li>
</ul>
<img src="/2019/01/19/jenkinswithunity/defaultsetting.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-logFile &quot;$WORKSPACE/build.log&quot; -quit -batchmode -nographics -executeMethod $BuildMethod -output &quot;$WORKSPACE/Builds/test.exe&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>将下面脚本放到Unity3D项目中的Editor 目录下，该脚本只实现了Windows平台的构建，如果需要其他平台，可以参照”PerformWindowsBuild”自行实现。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyEditorScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">string</span>[] SCENES = FindEnabledEditorScenes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">string</span> APP_NAME = <span class="string">"YourProject"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">string</span> TARGET_DIR = <span class="string">"target"</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Custom/CI/Build Windows"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PerformWindowsBuild</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> target_dir = APP_NAME + <span class="string">".exe"</span>;</span><br><span class="line">        GenericBuild(SCENES, TARGET_DIR + <span class="string">"/"</span> + target_dir, BuildTargetGroup.Standalone, BuildTarget.StandaloneWindows, BuildOptions.None);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span>[] <span class="title">FindEnabledEditorScenes</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        List&lt;<span class="keyword">string</span>&gt; EditorScenes = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (EditorBuildSettingsScene scene <span class="keyword">in</span> EditorBuildSettings.scenes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!scene.enabled) <span class="keyword">continue</span>;</span><br><span class="line">            EditorScenes.Add(scene.path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EditorScenes.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GenericBuild</span>(<span class="params"><span class="keyword">string</span>[] scenes, <span class="keyword">string</span> target_dir, BuildTargetGroup <span class="keyword">group</span>, BuildTarget build_target, BuildOptions build_options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EditorUserBuildSettings.SwitchActiveBuildTarget(<span class="keyword">group</span>, build_target);</span><br><span class="line">        <span class="keyword">var</span> res = BuildPipeline.BuildPlayer(scenes, target_dir, build_target, build_options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新建构建任务。点击新建任务，输入任务名称，任务类型选择“自由风格”，然后点击“OK”进入任务配置页面。</li>
</ul>
<img src="/2019/01/19/jenkinswithunity/newtask.png">
<ul>
<li>配置任务。<ul>
<li>首先配置项目目录，在“General”标签下面的“Advanced”中，勾选“Use custom workspace”，然后输入项目工程的目录和显示名称。</li>
<li>然后在Buiild标签下面，添加“Invoke Unity3D Editor”，“Unity3d installation name”选择Unity版本，“Editor command line arguments”这里如果不填任何内容，将使用Unity3D全局默认配置。</li>
<li>如果使用全局默认参数，还需要指定一些参数值，在“General”标签下面，勾选“参数化构建过程”，添加“选项参数”，参数的名称设置为“BuildMethod”，“Choices”设置为“MyEditorScript.PerformWindowsBuild”。</li>
</ul>
</li>
</ul>
<img src="/2019/01/19/jenkinswithunity/setworkspace.png">
<img src="/2019/01/19/jenkinswithunity/buildparam.png">
<img src="/2019/01/19/jenkinswithunity/buildsetup.png">
<p>所有的配置完成之后，就可以进行自动化构建了，进入到任务页面，然后选择”Build with Parameters”,”BuildMethod”选择“MyEditorScript.PerformWindowsBuild”，然后点击“Build”,稍等一下，如果成功的话，生成的程序将会在“target/”目录下。</p>
<h2 id="基于Git的构建"><a href="#基于Git的构建" class="headerlink" title="基于Git的构建"></a>基于Git的构建</h2><p>待完成</p>
<h2 id="基于SVN的构建"><a href="#基于SVN的构建" class="headerlink" title="基于SVN的构建"></a>基于SVN的构建</h2><p>待完成</p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 链表</title>
    <url>/2019/01/16/algorithm02/</url>
    <content><![CDATA[<h1 id="数据结构与算法-链表"><a href="#数据结构与算法-链表" class="headerlink" title="数据结构与算法 - 链表"></a>数据结构与算法 - 链表</h1><p>在日常的开发中，链表是一种非常常用的数据结构，与数组相同，链表也是一种线性列表，与数组不同的是，数组元素的顺序由下标来决定，链表的下标则通过指针来决定。<br><a id="more"></a><br><img src="/2019/01/16/algorithm02/LinkedListVsArray.png"></p>
<p>通过上图可以看出，数组和链表主要存在以下几点不同：</p>
<ol>
<li>链表是由一个个结点组成，每个结点都保存着指向下个结点的指针；数组的线性顺序由下标决定。</li>
<li>数组的地址是连续的，但是链表的结点则不连续。（连续地址带来的好处时可以缓存）</li>
</ol>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>对于集合类型来说，最常用的操作就是插入、删除和查找。在执行这些操作时，通常有两种情况，以删除操作为例：</p>
<ol>
<li>已知要删除的结点对象。</li>
<li>已知结点存储的值。这种情况下，需要先找到对应的结点。</li>
</ol>
<h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><img src="/2019/01/16/algorithm02/LinkedListVsArray_Insert.png">
<p>向数组中插入数据，分为两种情况：</p>
<ol>
<li>数组没有空闲位置，此时需要为数组重新分配一块更大的连续内存，并且分配完成之后，需要将数组元素拷贝到新数组中。</li>
<li>数组有空闲位置，此时需要将插入位置之后的数组元素，向后拷贝移动，为新元素腾出位置。</li>
</ol>
<p>向链表中插入数据，假设要在结点 A、B 之间插入一个新结点 C，那么只需要将 A 的指向下个结点的指针，使之指向 C 结点，C 结点指向 B 结点。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表插入部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedNode&lt;T&gt; <span class="title">InsertAfter</span>(<span class="params"><span class="keyword">int</span> position, T item</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"position out of index"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p = head;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; j &lt; position)</span><br><span class="line">   &#123;</span><br><span class="line">       p = p.next;</span><br><span class="line">       j++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode&lt;T&gt;(item);</span><br><span class="line">   newNode.next = p.next;</span><br><span class="line">   p.next = newNode;</span><br><span class="line"></span><br><span class="line">   length++;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析这段代码的复杂度：</p>
<ul>
<li>最好情况：O(1)</li>
<li>最坏情况: O(n)</li>
<li>均摊复杂度：O(n)</li>
</ul>
<p>需要注意的是，这里最坏情况和均摊时间复杂度之所以为 O(n)，是因为在进行删除之前进行索引，如果知道在哪个结点下面进行插入，那么复杂度将变为 O(1)，见下面代码。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkedNode&lt;T&gt; <span class="title">InsertAfter</span>(<span class="params">LinkedNode&lt;T&gt; node, T item</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"position out of index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> LinkedNode&lt;T&gt;(item);</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; j &lt; position)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> newNode = <span class="keyword">new</span> LinkedNode&lt;T&gt;(item);</span><br><span class="line">        newNode.next = p.next;</span><br><span class="line">        p.next = newNode;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3>
<p>通过上图可以看到，与数据的插入类似，如果已知要删除的结点，首先需要找到它的前置结点，然后将前置结点的指针指向要删除结点的下个结点，代码示例如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">LinkedNode&lt;T&gt; node</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理Null情况</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == head)</span><br><span class="line">    &#123;<span class="comment">//要处理的结点为头结点</span></span><br><span class="line">        <span class="keyword">var</span> h = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        h.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> p = head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next != node)</span><br><span class="line">            p = p.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        p.next = node.next;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>最好情况复杂度：O(1)</li>
<li>最坏情况复杂度：O(n)</li>
<li>均摊情况复杂度：O(n)</li>
</ul>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>一般编写代码，最容易出现错误的地方就是边界情况和异常情况，在实现链表时尤其如此，因此，在编写链表代码时，要把边界情况处理全面。常见的一些边界条件如下：</p>
<ul>
<li>链表为空</li>
<li>链表只包含一个、两个结点</li>
<li>要处理的结点是头结点、尾结点</li>
</ul>
<p>通过设置哨兵，可以简化边界的处理，并且可以是代码变得更加简洁。哨兵通常是一个<strong>哑对象</strong>，它的下一个结点指针通常指向链表的头结点或者尾结点。我们利用哨兵来对删除操作进行修改：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">headNil = <span class="keyword">new</span> LinkedNode(<span class="keyword">default</span>(T));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">LinkedNode&lt;T&gt; node</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p = headNil;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next != node)</span><br><span class="line">        p = p.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    p.next = node.next;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>最好情况复杂度：O(1)</li>
<li>最坏情况复杂度：O(n)</li>
<li>均摊情况复杂度：O(n)</li>
</ul>
<p>哨兵的主要作用是简化边界处理，并不能够降低渐进时间复杂度（会降低渐进复杂度的系数）。因为每个链表都需要额外的空间来保存哨兵，比如对于需要大量小链表的情景，就会造成内存空间的浪费。</p>
<h2 id="常见的链表"><a href="#常见的链表" class="headerlink" title="常见的链表"></a>常见的链表</h2><p>链表的种类很多，可以是单向链接或者双向链接，单向链接每个结点只存储下一个结点的指针(next)，而双向链接还存储了上一个结点的指针(prev)；也可以是循环或者非循环的，循环链表的最后一个结点的next指针指向链表的第一个结点；可以是已排序或者未排序的，具体的链表结果可以看下图，分别展示了单向非循环链表、双向非循环链表、双向循环链表。</p>
<img src="/2019/01/16/algorithm02/LinkedListTypes.png">
<p>最后附上<a href="https://github.com/huosk/Algo/blob/master/CSharp/Collections/LinkedList.cs" target="_blank" rel="noopener">源码</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法 - 复杂度分析</title>
    <url>/2019/01/12/algorithm/</url>
    <content><![CDATA[<h1 id="数据结构与算法-复杂度分析"><a href="#数据结构与算法-复杂度分析" class="headerlink" title="数据结构与算法 - 复杂度分析"></a>数据结构与算法 - 复杂度分析</h1><p>学习算法是为了更快、更节省内存的解决问题，那么如何判断定一个算法是不是足够快、足够省内存，这就需要复杂度分析。复杂度分析包括<strong>时间复杂度分析</strong>和<strong>空间复杂度分析</strong>。<br><a id="more"></a><br>复杂度分析能力之于开发者，就像审美能力之于设计师，因此，其重要性是不言而喻的。说道这里，可能会想到，我们平时常用的测试性能的方法，直接把算法跑一遍，然后直接可以知道算法跑的快慢了，为什么还要费劲去分析呢？首先可以肯定的说，这两种方法都有不同的应用场景，比如很多刷题平台，测试算法快慢就是这种方法，并且该方法还有一个名字，叫做<strong>事后统计法</strong>。但是，这种方法存在一定的局限性，主要有两方面：</p>
<ol>
<li>测试结果与运行环境相关。同样的算法在不同的计算机上，运行的速度不一样。</li>
<li>测试结果与数据规模相关。同样一个排序算法，排列100个元素，和排列100万个元素用时肯定不同。</li>
</ol>
<p>所以就需要一种不用进行数据输入，就能够知道算法快慢的方法，这就是复杂度分析方法。这里需要注意的是，复杂度分析只是粗略的估计算法的执行效率，对于特定的数据规模，复杂度低的不一定比复杂度高的执行速度快，如果现在还不能理解这句话，没关系，等看完本文之后再来理解。</p>
<h2 id="O-n-表示法"><a href="#O-n-表示法" class="headerlink" title="$O(n)$表示法"></a>$O(n)$表示法</h2><p>首先考虑一个问题，如果给定一段代码，来计算它的执行时间，如何来进行计算？很简单，把每一条语句的执行时间求和就可以了嘛，看下面一段代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算过程如下：</p>
<ol>
<li>首先假设每一条语句执行时间相同，都为单位时间$t$</li>
<li>第2行执行1次，时间为：$1t$</li>
<li>第3行执行n次，时间为：$nt$</li>
<li>第4行执行n次，时间为：$nt$</li>
<li>第6行执行1次，时间为：$1t$</li>
<li>总计时间为：$T_1(n)=(1+n+n+1)t=(2n+2)t$</li>
</ol>
<p>到此为止，我们已经估算出来上面代码时间了，时间与输入的 n 有关，关系如下图：</p>
<img src="/2019/01/12/algorithm/liner.png">
<p>再看一个稍微复杂点的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;n;++j)&#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是根据上面的步骤，计算时间复杂度：</p>
<ol>
<li>首先假设每一条语句的执行时间相同，都为单位时间$t$</li>
<li>第2行执行1次，时间为：$1t$</li>
<li>第3行执行n次，时间为：$nt$</li>
<li>第4行执行n次，时间为：$nt$</li>
<li>第5行为嵌套循环，执行$n*n$次，时间为$n^2t$</li>
<li>第6行在内层循环体内，执行次数是$n*n$，时间为$n^2t$</li>
<li>第9行执行1次，时间为:$1t$</li>
<li>总计时间为：$T_2(n)=(1+n+n+n^2+n^2+1)t=(2n^2+2n+2)t$</li>
</ol>
<p>可以看出来，最终的时间依旧跟 n 有关，关系如下图：</p>
<img src="/2019/01/12/algorithm/power.png">
<p>通过上面例子可以看到，每次我们都假设，每一条语句的执行时间是相同的，即我们并不关心每一条语句执行需要多少时间，而只关注它与单位时间的函数关系，所以我们可以用另一种形式来写上面的表达式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T_1(n)  &= (2n+2)t\\
        &= O(2n+2)\\
T_2(n)  &= (2n^2+2n+2)t\\
        &= O(2n^2+2n+2)
\end{aligned}</script><p>这就是大 O 时间复杂度表示法，它表示算法执行时间，在数据规模 n 发生变化时的变化趋势，因此，也叫<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p>
<p>因为关注的重心在于变化趋势（函数图形形状），而公式中的低阶、常量、系数部分对趋势影响较小，所以都可以忽略。因此上面的两个表达式就成了：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T_1(n)  &= O(2n+2)\\
        &= O(n)\\
T_2(n)  &= O(2n^2+2n+2)\\
        &= O(n^2)
\end{aligned}</script><p>通过下图可以看到，两者之间的趋势是一致的。</p>
<img src="/2019/01/12/algorithm/compare.png">
<h2 id="几个小技巧"><a href="#几个小技巧" class="headerlink" title="几个小技巧"></a>几个小技巧</h2><p>通过上面例子，可能会发现以下几个计算复杂度的规律：</p>
<ol>
<li>最大值法则：最终结果只与复杂度最高的（循环次数最多）的代码有关。（因为低阶对于趋势的影响较小，所以忽略）</li>
<li>乘法法则：嵌套代码的复杂度 = 本身复杂度 x 外层循环复杂度。比如第二个例子中的第5、6行，它们的复杂度 = 本身复杂度 x 外层循环复杂度 = n x n。</li>
</ol>
<h2 id="几种常见的复杂度"><a href="#几种常见的复杂度" class="headerlink" title="几种常见的复杂度"></a>几种常见的复杂度</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">复杂度</th>
<th style="text-align:left">表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">常数阶</td>
<td style="text-align:left">$O(1)$</td>
</tr>
<tr>
<td style="text-align:left">对数阶</td>
<td style="text-align:left">$O(\log{n})$</td>
</tr>
<tr>
<td style="text-align:left">线性阶</td>
<td style="text-align:left">$O(n)$</td>
</tr>
<tr>
<td style="text-align:left">线性对数阶</td>
<td style="text-align:left">$O(n\log{n})$</td>
</tr>
<tr>
<td style="text-align:left">K方阶</td>
<td style="text-align:left">$O(n^2)$,$O(n^3)$,$O(n^k)$</td>
</tr>
<tr>
<td style="text-align:left">指数阶</td>
<td style="text-align:left">$O(2^n)$</td>
</tr>
<tr>
<td style="text-align:left">阶乘阶</td>
<td style="text-align:left">$O(n!)$</td>
</tr>
</tbody>
</table>
</div>
<p>通过下图，可以直观的看到它们的趋势。</p>
<img src="/2019/01/12/algorithm/changjiantuxing.png">
<h3 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶$O(1)$"></a>常数阶$O(1)$</h3><p>首先看下面一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br></pre></td></tr></table></figure>
<p>很简单吧，这段代码一共执行了3条语句，那么复杂度为3，那么用大 O 表示呢？$T(n) = O(3)$，看上去没什么问题，但是如果代码有5行、10行、10万行呢？难道还写成$O(5)$、$O(10)$、$O(100000)$？看上去不好看，所以对于<strong>不随着数据规模变化的复杂度</strong>（表达式里面没有n），统统都用$O(1)$表示。</p>
<h3 id="对数阶-O-log-n"><a href="#对数阶-O-log-n" class="headerlink" title="对数阶$O(\log{n})$"></a>对数阶$O(\log{n})$</h3><p>对数阶时间复杂度非常常见，并且非常高效。但是复杂度最难分析，这是因为它并不像其他复杂度，可以通过相乘、相加来得到，它往往需要我们先总结规律，然后找出指数形式，最后再求对数。</p>
<p>先看下面一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面提到的最大值法则，我们只需要计算循环部分的复杂度，那么就需要计算到底循环了多少次，下面是计算步骤：</p>
<ol>
<li>假设循环停止时，执行了 k 次，接下来就变成了求 k 的问题。</li>
<li>我们有哪些已知条件呢？<ul>
<li>当执行 k 次后，循环停止，即 i = n。</li>
<li>每执行 1 次，i 都乘以 2，执行 k 次后，$i = 2^k$</li>
</ul>
</li>
<li>根据已知条件可得：$2^k=n$</li>
<li>最后求得： $k=\log_2{n}$</li>
</ol>
<p>上面每次循环 i 都乘以2，如果乘以3、乘以5、乘以10000呢？最终的结果将是 $\log<em>{3}{n}、\log</em>{5}{n}、\log_{10000}{n}$。在使用大 O 表示法时，统统记做 $O(\log{n})$ 表示，这是为什么呢？</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(n) = \log_{k}{n} = \log_{k}2*\log_2{n}
\end{aligned}\tag{换底公式}</script><p>其中$\log_{k}2$是与 n 无关的常量，所以在大 O 表示法中可以忽略，所以对数阶都可以表示为:$O(\log{n})$</p>
<p>理解了对数阶之后，再来看线性对数阶$O(n\log{n})$就很简单了，还记得上面提到的乘法法则吗？将对数阶$O(\log{n})$外面嵌套一个循环就成了线性对数阶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n)&#123;</span><br><span class="line">            j = j * <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以按照上面的方法，自己计算一下，这段代码的复杂度。</p>
<h3 id="多维输入"><a href="#多维输入" class="headerlink" title="多维输入"></a>多维输入</h3><p>在之前的例子中，时间复杂度由数据规模 n 来决定，还有一些算法，它的数据输入包含多个维度，比如下面一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        sum_1 = sum_1 + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        sum_2 = sum_2 + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面例子中，它的复杂度是有 m、n 来决定，并且都是线性复杂度，再来复习一下复杂度计算方法。</p>
<ol>
<li>首先假设所有的运算时间相同，都为单位时间 $t$</li>
<li>第2行执行1次，时间为：$t$</li>
<li>第3、4行执行次数为 m 次，时间为： $mt$</li>
<li>第7行执行1次，时间为：$t$</li>
<li>第8、9行执行 n 次，时间为：$nt$</li>
<li>第12行执行1次，时间为：$t$</li>
<li>总和：$T(n)=(2m+2n+3)t$，利用大O表示法，省略低阶和单位时间：$T(n) = O(m+n)$</li>
</ol>
<h2 id="最好、最坏和平均"><a href="#最好、最坏和平均" class="headerlink" title="最好、最坏和平均"></a>最好、最坏和平均</h2><p>不知道你主要到没有，在上面所有的例子中，都没有出现 if 语句，所以每行代码的执行次数都是确定的，那么如果加入条件分支会怎么样呢？首先看下面一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x)&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是从长度为n的数组array中，查找值为x的元素，找到之后立刻结束查找，下面分析一下这段代码的复杂度。</p>
<ol>
<li>第 1、2 行复杂度：1</li>
<li>第 3 行执行多少次呢？如果不看循环体，那么它为 n，但是循环内执行了break，所以不能一概而论的认为是n了，这里就需要分情况讨论：<ol>
<li>最好的情况是，第一个元素就是要找的元素，此时复杂度为：1</li>
<li>最坏的情况是，最后一个元素才找到元素，此时复杂度为：n</li>
</ol>
</li>
<li>因此这里就引申出了最好情况复杂度、最坏情况复杂度，分别为$O(1)$、$O(n)$</li>
</ol>
<p>最好和最坏都是极端的情况，出现的几率很小，而如何表示其他情况下的复杂度呢？这里引入了<strong>平均情况时间复杂度</strong>，我们先看下上面例子有几种查找结果，以及每种情况出现的概率：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">可能情况</th>
<th style="text-align:left">出现概率</th>
<th style="text-align:left">复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">不在数组中</td>
<td style="text-align:left">$1/2$</td>
<td style="text-align:left">$T_1(n)=n$</td>
</tr>
<tr>
<td style="text-align:left">出现在位置k</td>
<td style="text-align:left">$1/2$</td>
<td style="text-align:left">$T_2(n)=?$</td>
</tr>
</tbody>
</table>
</div>
<p>出现或者不出现的概率相等，都为1/2。对于出现这种情况，数组的每个位置都有可能出现，因此每个位置出现的概率为(1/n)，因此每个位置的时间复杂度为：$k(1/n)$，（其中$k$为出现的位置），因此出现的总概率为：</p>
<script type="math/tex; mode=display">
T_2(n)=\sum_{k=1}^{n}(k/n)</script><p>平均情况时间复杂度为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(n)    &= \frac{T_1(n) + T_2(n)}{2}\\
        &= \frac{n + {\sum_{k=1}^{n}(k/n)}}{2}\\
        &= \frac{3n+1}{4}
\end{aligned}</script><p>大O表示法：</p>
<script type="math/tex; mode=display">
T(n)=O({\frac{3n+1}{4}}) = O(n)</script><h3 id="摊还分析法"><a href="#摊还分析法" class="headerlink" title="摊还分析法"></a>摊还分析法</h3><p>前面介绍了平均情况时间复杂度，这里再介绍一种特殊情况-均摊时间复杂度。先看一个例子，insert函数是将值val插入到数组array中，当数组满时，则将所有数据相加，然后把数据存到数组第一个位置，并且重置数组计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">            sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>[count] = val;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么来分析一下这段代码的事件复杂度：</p>
<ul>
<li>最好情况时间复杂度：当数组还有空闲空间时，直接设置数组元素即可，复杂度为$T(n) = 3t = O(1)$。</li>
<li>最坏情况时间复杂度：当数组满时，需要便利数组，复杂度$T(n) = (2n+6)t = O(n)$。</li>
<li>平均情况时间复杂度: 此时是多少呢，下面详细的分析一下。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">可能情况</th>
<th style="text-align:left">出现概率</th>
<th style="text-align:left">复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数组有空间(最好)</td>
<td style="text-align:left">$P_1$</td>
<td style="text-align:left">$T_1$</td>
</tr>
<tr>
<td style="text-align:left">数组满元素(最坏)</td>
<td style="text-align:left">$P_2$</td>
<td style="text-align:left">$T_2$</td>
</tr>
</tbody>
</table>
</div>
<p>上面列举了可能出现的两种情况，分别是最好情况、最坏情况。那么分别出现的概率是多少呢？换一种描述方法可能更加直观，数组 array 的长度为 n，当元素的个数为0-n-1时，此时数组有空间；当元素个数为 n 时，数组满元素。所以对于元素个数一共（n+1）种情况，对于每一种情况出现的概率都相同，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P_1 &= \frac{n}{n+1}\\
T_1 &= P_1 * 3t\\
&= (3 - \frac{3}{n+1})t\\
\\
P_2 &= \frac{1}{n+1}\\
T_2 &= P_2 * (2n+6)t\\
&= \frac{1}{n+1}*(2n+6)t\\
&= (2 + \frac{4}{n+1})t
\end{aligned}</script><p>最后，平均情况复杂度 $T(n) = T_1 + T_2 = (5 + \frac{1}{n+1})t = O(1)$。</p>
<p>同样是计算平均情况时间复杂度，为什么 find 的平均复杂度与最坏情况相同，而insert 的平均复杂度与最好情况相同？我们先对比一下这两函数有上面不同：</p>
<ol>
<li>find 在极端情况下，复杂度才为O(1),insert在绝大部分情况，复杂度都为O(1)。</li>
<li>对于insert 函数，O(1) 和 O(n) 出现比较有规律，一个 O(n)后面接着 n-1 个O(1)。</li>
</ol>
<p>对于 insert 这种情况的函数，在分析平均情况复杂度时，有一种更加简单的分析方法，叫做<strong>摊还分析法</strong>，其分析结果称作<strong>均摊时间复杂度</strong>。</p>
<p>那么如何使用摊还分析法呢？还是看上面的 insert 例子，首先已经知道，一个 O(n)后面跟着 n-1 个O(1)，可以将这些操作当作一个序列，将这个 O(n) 复杂度分摊到 n-1 个O(1)当中，分摊后整个序列的复杂度还是 O(1)，这就是摊还分析法的大致思路。</p>
<p>可以看出来，摊还分析法的使用限制很大，只有在少数特殊场景才会用到，所以这里只需要简单了解一下就好。另外，摊还分析法的分析结果叫做均摊时间复杂度，其实这里也没有必要咬文嚼字，大可以统一的认为就是平均时间复杂度。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>我们上面说了很多例子，基本都是时间复杂度分析的，主要用来描述算法的执行快慢，而现在介绍另一种复杂度分析 - 空间复杂度分析，空间复杂度关心的是内存空间的占用情况，所以在进行分析时，只需关注对象实例化语句，看下面一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">        a[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        print out a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度分析步骤：</p>
<ol>
<li>首先假设所有的类型（集合除外）占用的空间相同，都为单位空间 s</li>
<li>第2行分配1个对象，占用空间：s</li>
<li>第3行为一个数组，分配n个单位空间：ns</li>
<li>剩余代码都没有空间分配，因此为：0</li>
<li>总计：$S(n)=(1+n)s$,使用大O表示法：$S(n)=O(n)$</li>
</ol>
<p>空间复杂度分析和时间复杂度分析很像，用于时间复杂度分析的方法也都可以用到空间复杂度分析中，比如之前提到的<strong>最大值法则</strong>和<strong>乘法法则</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一共介绍了时间复杂度分析和空间复杂度分析，总的来说，这两种方法理解起来很容易，但要真正熟练掌握复杂度分析，还需要多多练习。</p>
<p>对于<strong>事后分析法</strong>和<strong>渐进复杂度</strong>这两种方法，各有长短，对于数据规模确定的情况，可能事后分析法比渐进复杂度要更精确一些，比如，对一个班的人按身高进行排序，对于这种数据规模较小的情况，完全可以采用事后分析法，对各种排序算法进行测试选择；再比如，对某宝中搜索出来的商品按照价格进行排序，提前并不知道搜索结果有多少，少的可能只有几种、多的可能上万种甚至更多，此时再使用事后分析法显然已经不太恰当，而采用渐进复杂度分析，就能知道排序用时的增长趋势。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在本文最后，通过一个练习来结束本文。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">        <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">        <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            new_array[j] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">        <span class="built_in">array</span> = new_array;</span><br><span class="line">        len = <span class="number">2</span> * len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">    <span class="built_in">array</span>[i] = element;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最好情况时间复杂度：O(1)</li>
<li>最坏情况时间复杂度：O(n)</li>
<li>均摊时间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>欧拉角</title>
    <url>/2019/01/02/eulerandgimballock/</url>
    <content><![CDATA[<h1 id="3D中的方位与角位移"><a href="#3D中的方位与角位移" class="headerlink" title="3D中的方位与角位移"></a>3D中的方位与角位移</h1><p>在三维空间中，描述物体的旋转状态有多种方式，这些方式中，可能选取的参考坐标系不同、也可能选取的基向量不同，或者是采用的数学表达方式不同，等等，这些差异就造成理解三维旋转比较困难。本文通过梳理常见旋转描述方式，希望能够帮助理解三维空间中的角位移。<br><a id="more"></a></p>
<h2 id="坐标系选择"><a href="#坐标系选择" class="headerlink" title="坐标系选择"></a>坐标系选择</h2><p>当我们描述一个物体的坐标时，首先需要选定参考坐标系，通常是世界坐标系的原点；同样的，我们在描述一个物体的旋转时，也需要选定一个参考坐标系，这里通常选择惯性坐标系。</p>
<blockquote>
<p><strong>惯性坐标系</strong>：惯性坐标系的原点与物体坐标系重合，但是坐标轴与世界坐标系平行。<br><strong>为什么引入惯性坐标系</strong>：惯性坐标系到物体坐标系只需要进行旋转，惯性坐标系到世界坐标系是需要平移，将世界坐标系到物体坐标系的转换过程分解为两个步骤进行，能够简化问题。</p>
</blockquote>
<h2 id="旋转变换表示"><a href="#旋转变换表示" class="headerlink" title="旋转变换表示"></a>旋转变换表示</h2><p>在选定好参考坐标系之后，就需要确定，从参考坐标系（惯性坐标系）到物体坐标系之间的变换如何表示，这里通常有三种方式：</p>
<ul>
<li>矩阵</li>
<li>欧拉角</li>
<li>四元数</li>
</ul>
<p>这三种方式有个优略，对于各个游戏引擎来说，针对不同的使用场景可以选取不同的表示方式。下面就针对这三种方式，进行详细分析比较，来加深对旋转的理解。</p>
<h2 id="矩阵表示旋转"><a href="#矩阵表示旋转" class="headerlink" title="矩阵表示旋转"></a>矩阵表示旋转</h2><p>构建旋转矩阵的关键在于，计算旋转矩阵的基向量，得到基向量之后，就可以组成旋转矩阵，该矩阵的意义表示从一个坐标系到目标坐标系的旋转。光看描述可能还是比较难理解，看一个具体的例子，为了简化问题，这里只进行绕$y$轴的旋转。</p>
<img src="/2019/01/02/eulerandgimballock/matrixrot.png">
<p>很容易计算得到三个基向量：</p>
<script type="math/tex; mode=display">\left\{
\begin{aligned}
x & = & (0.87,0,-0.5) \\
y & = & (0,1,0) \\
z & = & (0.5,0,0.87)
\end{aligned}
\right.</script><p>对应的旋转矩阵为：</p>
<script type="math/tex; mode=display">
 \left[
 \begin{matrix}
   0.87 & 0 & -0.5 \\
   0 & 1 & 0 \\
   0.5 & 0 & 0.87
  \end{matrix}
  \right]\tag{M}</script><p>该矩阵就表示从参考坐标系（惯性坐标系）到目标坐标系（物体坐标系）的旋转变换，参考坐标系中的任意向量$v$，都可以通过与矩阵相乘$(v*M)$，得到旋转之后的向量。</p>
<p>通过上面例子可以看到矩阵表示旋转的一些优缺点，总结如下：</p>
<p>优点：</p>
<ul>
<li>不需要关注旋转的顺序，因为整个矩阵就是一个整体，直接乘以该矩阵，就可以实现向量的旋转。</li>
<li>利用矩阵的逆矩阵，可以实现旋转的撤销（反向旋转）。</li>
<li>可以合并多个旋转矩阵，矩阵$M_1$表示坐标系A 到 B 的旋转，矩阵$M_2$坐标系 B 到 C 的旋转，那么矩阵$M_1 * M_2$表示A 到 C 的旋转。</li>
<li>最后一点是图形 API 都采用矩阵的形式来表示旋转。</li>
</ul>
<p>缺点：</p>
<ul>
<li>矩阵的表示形式比较浪费内存，矩阵使用 9 个参数来表示，和后面介绍的<em>欧拉角</em>和<em>四元数</em>来说，内存占用比较高。</li>
<li>矩阵难以使用，给定一个矩阵之后，并不能直观的知道矩阵表示一个怎样的旋转。</li>
<li>矩阵可能是病态的，旋转矩阵为正交矩阵，在变换的过程中，可能由于浮点数的精度问题，导致“矩阵蠕变”，从而导致病态矩阵。</li>
</ul>
<h2 id="欧拉角表示"><a href="#欧拉角表示" class="headerlink" title="欧拉角表示"></a>欧拉角表示</h2><p>欧拉角的基本思想是将旋转分解为，绕三个相互垂直轴的旋转组成的序列。这句话读起来非常拗口，其实非常易于理解。注意到定义中的几个要点，首先是三个绕垂直轴旋转的分量，这三个轴可以是任意的三个轴，但是通常选择笛卡尔坐标系比较有意义；其次是三个分量的顺序，这里也没有进行规定，因此可以是任意的顺序，其中有些顺序比较常用，因此人们为它起了名字，比如“head-pitch-bank”、“roll-pitch-yaw”等等。</p>
<p>通过例子来看下”head-pitch-bank”是如何进行旋转的。</p>
<ul>
<li>初始时，物体坐标系与惯性坐标系重合，红色-X轴、绿色-Y轴、蓝色-Z轴。</li>
</ul>
<img src="/2019/01/02/eulerandgimballock/01.png">
<ul>
<li>首先进行Heading 旋转，heading 为绕 y 轴的旋转分量，根据左手定则进行旋转 45 度。</li>
</ul>
<img src="/2019/01/02/eulerandgimballock/heading.png">
<ul>
<li>然后进行Pitch 旋转，Pitch 为绕 x 轴的旋转分量，需要注意的是，<strong>这里的 x 轴选取的是物体坐标系的 x 轴，而非惯性坐标系。</strong></li>
</ul>
<img src="/2019/01/02/eulerandgimballock/pitch.png">
<ul>
<li>最后是进行Bank 旋转，Bank 是绕 z 轴的旋转分量，同样的，<strong>这里的 z 轴是物体坐标系的 z 轴，而非惯性坐标的 z 轴</strong>。</li>
</ul>
<img src="/2019/01/02/eulerandgimballock/bank.png">
<h3 id="其他欧拉角旋转方式"><a href="#其他欧拉角旋转方式" class="headerlink" title="其他欧拉角旋转方式"></a>其他欧拉角旋转方式</h3><p>在前面提到，欧拉角的轴和旋转顺序的选取多种多样，“Head-pitch-bank” 只是其中的一种，还有一种比较常见的旋转方式为“Roll-pitch-yaw”，其中roll 为绕 z 旋转的分量，pitch 为绕 x 轴旋转的分量，yaw 为绕 y 轴旋转的分量，Unity3D 中就采用这种欧拉角约定。</p>
<p>如果需要在两种不同约定之间进行转换，最简单的方式是通过矩阵。</p>
<h3 id="欧拉角的优缺点"><a href="#欧拉角的优缺点" class="headerlink" title="欧拉角的优缺点"></a>欧拉角的优缺点</h3><p>优点：</p>
<ul>
<li>很容易使用，从上面例子就可以看到，欧拉角非常的直观，并且符合人类思维方式。</li>
<li>描述简洁，欧拉角只需要三个参数，就能够描述一个旋转。</li>
<li>任意三个数都是合法的欧拉角</li>
</ul>
<p>缺点：</p>
<ul>
<li>别名问题，即给定一个方位，有多种欧拉角可以描述它<ul>
<li>最常见的是任意角度加上$360^o$，都等于它自身。</li>
<li>另一个别名问题是，$pitch135^o$ 等价于$heading180^o、pitch45^o、bank180^o$。</li>
<li>最著名的别名问题是，先$heading45^o、pitch90^o$ 等价于$pitch90^o、bank45^o$，事实上只要第二个旋转轴旋转${\pm}90^o$，那么第一个轴就会和第三个轴重合，这种现象称为“万象锁”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决别名问题，一般通过限制各个旋转分量的范围，比如对于“heading-pitch-bank”约定来说：<br>heading、bank限定在 $-180^o\sim180^o$，pitch限定在$-90^o\sim90^o$。<br>“万象锁”解决办法：$当pitch=\pm90^o时，bank=0^o$</p>
</blockquote>
<ul>
<li>欧拉角的第二个问题是，两个角度之间的插值非常困难。在开发中，经常需要将摄像机平滑的进行旋转，比如从旋转 $\theta_0$ 插值到旋转 $\theta_1$，根据线性插值公式</li>
</ul>
<script type="math/tex; mode=display">
\Delta\theta=\theta_1-\theta_0\\
\theta_t=\theta_0+t*\Delta\theta</script><p>插值可能会存在很多问题，<strong>如果欧拉角没有进行限制</strong>，将得到很大角度差，假设 $\theta_0=45^o，\theta_1=720^o$，因为720 = 360*2 + 0，所以$\theta_0、\theta_1$两个角度之间只相差$45^o$，但是根据线性插值公式计算，$\Delta\theta=\theta_1-\theta_0=675^o$，旋转了将近两周！解决这个问题的方法就是采用上面的角度限制方法，对欧拉角进行限定。</p>
<p>然而，即使对角度进行了限定，仍然不能完全解决插值问题，这是由于旋转角度的周期性引起的。看下例子，$假设\theta_1=170^o、\theta_0=-170^o$，值都在限定的范围内，但是插值的结果仍然是不正确的，旋转沿着长弧旋转了$340^o$，而非短弧旋转的$20^o$。解决该问题的方法是将 $\Delta\theta$ 限制到$-180^o\sim180^o$，公式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
wrap(x) &= x-360^o*\left [ \left ( x+180^o \right )/360^o \right ]\\
\Delta\theta &= wrap(\theta_1-\theta_0)\\
\theta_t &= \theta_0+t*\Delta\theta
\end{aligned}</script><p>然而，即使有了这两个限定，仍然会遇到“万向锁”问题，插值的前两个问题可以通过角度限定来解决，但是“万向锁”是一个底层的问题，目前来说没有办法来解决它。</p>
<h2 id="四元数表示"><a href="#四元数表示" class="headerlink" title="四元数表示"></a>四元数表示</h2><p>前面介绍了旋转的矩阵和欧拉角表示方法，也介绍了这两种方式的优缺点，下面介绍第三种旋转的表示方法-四元数，它在一定程度上集中了矩阵和欧拉角的有点，它采用4个参数来表示，并且能够解决欧拉角中的“万向锁”问题，下面就详细的了解一下四元数。</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>在正式介绍四元数之前，还是需要先介绍一下复数，复数对$(a,b)$表示$a+bi$,其中$a$称作实部，$b$称作虚部，$i$为虚数，满足$i^2 = -1$。下面可能采用$(a,b)$和$a+bi$两种表达形式，两者是等价的。</p>
<h4 id="复数性质"><a href="#复数性质" class="headerlink" title="复数性质"></a>复数性质</h4><p>对于复数$a+bi$，它具备如下性质：</p>
<ul>
<li>复数相加：$(a+bi)+(c+di) = (a+c)+(b+d)i$</li>
<li>复数相减: $(a+bi)-(c+di) = (a-c)+(b-d)i$</li>
<li>复数相乘:</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
(a+bi)*(c+di) &= ac + bci + adi + bdi^2\\
&= ac + (bc+ad)i - bd\\
&= (ac - bd) + (bc + ad)i
\end{aligned}</script><ul>
<li>共轭：复数的共轭就是让虚部变负，即$p=a+bi$的共轭复数为${p}^*=a-bi$。</li>
<li>模：</li>
</ul>
<script type="math/tex; mode=display">
||p|| = \sqrt{p*{p}^*} = \sqrt{a^2+b^2}</script><h4 id="复数的几何意义"><a href="#复数的几何意义" class="headerlink" title="复数的几何意义"></a>复数的几何意义</h4><p>复数包括<strong>实部</strong>和<strong>虚部</strong>两部分，如果把实部当作横轴、虚部当作纵轴，这样复数就能表示平面内的任意点，如果把该点到原点的向量，当作是横轴正向旋转一定角度后的结果，那么复数就可以表示旋转！</p>
<p>如下图所示，复数$p = \cos\alpha +i*\sin\alpha$，它表示的旋转角为$\alpha$。</p>
<img src="/2019/01/02/eulerandgimballock/complexnumber.png">
<h4 id="扩展复数"><a href="#扩展复数" class="headerlink" title="扩展复数"></a>扩展复数</h4><p>我们知道，一个物体在三维空间的方位，都能通过物体绕轴旋转一个角度来达到。那么既然复数能够表示二维空间的旋转角度，那么能不能扩展到三维空间呢，这个问题也困扰了数学家们很久，直到1843年，爱尔兰数学家$William Hamilton$ 才解决这个问题，这就产生了四元数的概念，他通过采用三个虚部来实现3D空间旋转的表示，即四元数$\left [ w,\left ( x,y,z \right ) \right ] w,x,y,z \in \mathbb{R}$定义了复数 $w + xi + yj + zk$，其中$i,j,k$的关系如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
i^2 = j^2 = k^2 = ijk = -1\\
ij = k, ji = -k\\
jk = i, kj = -i\\
ki = j, ik = -j
\end{cases}\tag{1}</script><p>可以看到，i、j、k之间的关系，既保留了复数的性质，同时，和笛卡尔坐标系的三个基坐标轴的叉乘关系非常像，对比下图（右手坐标系）。</p>
<script type="math/tex; mode=display">
x\times y = z,y\times x = -z\\
y\times z = x,z\times y = -x\\
z\times x = y,x\times z = -y\\</script><img src="/2019/01/02/eulerandgimballock/axisprod.png">
<h3 id="四元数相关的性质"><a href="#四元数相关的性质" class="headerlink" title="四元数相关的性质"></a>四元数相关的性质</h3><h4 id="四元数的表示形式"><a href="#四元数的表示形式" class="headerlink" title="四元数的表示形式"></a>四元数的表示形式</h4><p>四元数是复数的一种扩展形式，很多复数的性质，四元数也都满足。在介绍四元数性质之前，再重复一下四元数的表示形式，这两种形式都是等价的，只不过复数形式方便进行计算，向量的表示便于记忆和书写：</p>
<ul>
<li>向量表示形式：$q=\left [ w,\vec{v} \right]$或者$q=\left [ w,\left ( x,y,z \right ) \right ]$</li>
<li>复数表示形式：$q=w + xi + yj + zk$</li>
</ul>
<h4 id="实四元数与纯四元数"><a href="#实四元数与纯四元数" class="headerlink" title="实四元数与纯四元数"></a>实四元数与纯四元数</h4><p>实四元数是所有虚部向量为零向量的四元数：</p>
<ul>
<li>向量形式：$q=[w,(0,0,0)],或者q=[w,0]$</li>
<li>复数形式：$q=w+0i+0j+0k=w$，可以看到实数可以写成实四元数的形式！</li>
</ul>
<p>纯四元数是实部为零的四元数：</p>
<ul>
<li>向量形式:$q=[0,(x,y,z)]$</li>
<li>复数形式:$q=xi+yj+zk$</li>
</ul>
<h4 id="单位四元数"><a href="#单位四元数" class="headerlink" title="单位四元数"></a>单位四元数</h4><p>在向量中，任何向量都可以用长度和单位向量方向来表示：$\vec{v}=l*\vec{n}$，其中$l=|\vec{v}|$,$\vec{n}$是$\vec{v}$同方向的单位向量$|\vec{n}|=1$。</p>
<h4 id="四元数加法"><a href="#四元数加法" class="headerlink" title="四元数加法"></a>四元数加法</h4><script type="math/tex; mode=display">\begin{aligned}
{q}_1 &= \left [ w_1,\vec{v}_1 \right]\\
{q}_2 &= \left [ w_2,\vec{v}_2 \right]\\
{q}_1+{q}_2 &= \left [ w_1+w_2,\vec{v}_1+\vec{v}_2 \right]\\
{q}_1-{q}_2 &= \left [ w_1-w_2,\vec{v}_1-\vec{v}_2 \right]
\end{aligned}</script><h4 id="四元数的系数缩放"><a href="#四元数的系数缩放" class="headerlink" title="四元数的系数缩放"></a>四元数的系数缩放</h4><ul>
<li>向量表示形式：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
{q} &= \left [ w,\vec{v} \right]\\
\lambda{q} &= \left [ \lambda{w},\lambda\vec{v} \right],\lambda \in R\\
\end{aligned}</script><ul>
<li>复数表示形式：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
{q} &= w + xi + yj + zk\\
\lambda{q} &= \lambda{w} + \lambda{x}{i} + \lambda{y}{j} + \lambda{z}{k}
\end{aligned}</script><h4 id="四元数的乘法（叉乘）"><a href="#四元数的乘法（叉乘）" class="headerlink" title="四元数的乘法（叉乘）"></a>四元数的乘法（叉乘）</h4><p>有两个四元数:${q}_1、{q}_2$，计算它们的乘积:  </p>
<script type="math/tex; mode=display">
\begin{aligned}
{q}_1 &= \left [ w_1,\vec{v}_1 \right]\\
{q}_2 &= \left [ w_2,\vec{v}_2 \right]\\

其中:\\
\vec{v}_1 &= ({x}_1, {y}_1, {z}_1)\\
\vec{v}_2 &= ({x}_2, {y}_2, {z}_2)\\

开始计算：\\
{q}_1 \times {q}_2 &= \left [ w_1,\vec{v}_1 \right]\times\left [ w_2,\vec{v}_2 \right]\\
&=\left ( {w}_1+{x}_1i+{y}_1j+{z}_1k \right )\times\left ( {w}_2+{x}_2i+{y}_2j+{z}_2k \right )\\
&={w}_1{w}_2+{w}_2{x}_1i+{w}_2{y}_1j+{w}_2{z}_1k\\
&+{w}_1{x}_2i+{x}_1{x}_2i^2+{y}_1{x}_2ji+{z}_1{x}_2ki\\
&+{w}_1{y}_2j+{x}_1{x}_2ij+{y}_1{y}_2j^2+{z}_1{y}_2kj\\
&+{w}_1{z}_2k+{x}_1{z}_2ik+{y}_1{z}_2jk+{z}_1{z}_2k^2\\

根据上面的四元数性质(1),可得：\\
&= {w}_1{w}_2 + {w}_2{x}_1i + {w}_2{y}_1j + {w}_2{z}_1k\\
&+ {w}_1{x}_2i - {x}_1{x}_2 - {y}_1{x}_2k + {z}_1{x}_2j\\
&+ {w}_1{y}_2j + {x}_1{x}_2k - {y}_1{y}_2 - {z}_1{y}_2i\\
&+ {w}_1{z}_2k - {x}_1{z}_2j + {y}_1{z}_2i - {z}_1{z}_2\\

提取公因式：\\
&\begin{gathered}
=({w}_1{w}_2 - {x}_1{x}_2 - {y}_1{y}_2 - {z}_1{z}_2)\\
+({w}_2{x}_1 + {w}_1{x}_2 - {z}_1{y}_2 + {y}_1{z}_2)i\\
+({w}_2{y}_1 + {z}_1{x}_2 + {w}_1{y}_2 - {x}_1{z}_2)j\\
+({w}_2{z}_1 - {y}_1{x}_2 + {x}_1{x}_2 + {w}_1{z}_2)k\\
\end{gathered}\\

可以看到，已经计算出了结果，整理成向量表示形式：\\
&\begin{bmatrix}
{w}_1{w}_2 - {x}_1{x}_2 - {y}_1{y}_2 - {z}_1{z}_2\\
{w}_1{x}_2 + {w}_2{x}_1 + {y}_1{z}_2 - {z}_1{y}_2\\
{w}_1{y}_2 + {w}_2{y}_1 + {z}_1{x}_2 - {x}_1{z}_2\\
{w}_1{z}_2 + {w}_2{z}_1 + {x}_1{x}_2 - {y}_1{x}_2\\
\end{bmatrix}\\

整理成向量形式为：\\
&\begin{bmatrix}
w_1w_2-\vec{v}_1\cdot\vec{v}_2,w_1\vec{v}_2+w_2\vec{v}_1+\vec{v}_2\times\vec{v}_1
\end{bmatrix}
\end{aligned}</script><p>知道了四元数乘法的定义之后，这里还有几条乘法相关的性质：</p>
<ul>
<li>乘法满足结合律，但是不满足交换律:$(ab)c=a(bc),ab \neq ba$</li>
<li>乘积的模等于模的乘积：$||q_1\cdot{q}_2||=||q_1|| \cdot ||q_2||$</li>
<li>乘积的逆等于逆的反向乘积：$({q_1q_2})^{-1}={q_2}^{-1}{q_1}^{-1}$</li>
</ul>
<h4 id="四元数的点乘"><a href="#四元数的点乘" class="headerlink" title="四元数的点乘"></a>四元数的点乘</h4><p>四元数的点乘的定义和向量的点乘类似：</p>
<script type="math/tex; mode=display">
\begin{aligned}
q_1 \cdot q_2 &= [w_1,\vec{v}_1] \cdot [w_2,\vec{v}_2]\\
&= w_1w_2+\vec{v}_1\vec{v}_2\\
&=w_1w_2+x_1x_2+y_1y_2+z_1z_2
\end{aligned}</script><p>对于单位四元数来说，点乘结果的取值范围是$(-1\sim{1})$，它的几何意义与向量类似，它的绝对值越大，表示这两个四元数代表的旋转越相似。</p>
<h4 id="四元数的共轭"><a href="#四元数的共轭" class="headerlink" title="四元数的共轭"></a>四元数的共轭</h4><p>四元数的共轭就是把虚部向量取负，记作：${q}^*$</p>
<ul>
<li>向量形式：$q^*=[w,-(x,y,z)]$</li>
<li>复数形式：$q^*=w-xi-yj-zk$</li>
</ul>
<h4 id="四元数的模"><a href="#四元数的模" class="headerlink" title="四元数的模"></a>四元数的模</h4><p>四元数的模定义为：</p>
<ul>
<li>复数形式：$||p||=\sqrt{w^2+x^2+y^2+z^2}$</li>
<li>向量形式：$||p||=\sqrt{w^2+||\vec{v}||^2}$</li>
</ul>
<p>模的平方定义为：$||p||^2=pp^*=w^2+x^2+y^2+z^2$</p>
<h4 id="四元数的逆"><a href="#四元数的逆" class="headerlink" title="四元数的逆"></a>四元数的逆</h4><p>四元数的逆记为：$q^{-1}$，满足以下性质：</p>
<script type="math/tex; mode=display">
\begin{aligned}
qq^{-1} &= [1,0]=1\\
q^{-1} &= \frac{q^*}{||q||^2}
\end{aligned}</script><p>四元数逆的几何意义和矩阵的逆类似，可以用来表示一个旋转的逆向旋转。</p>
<h4 id="四元数表示三维旋转"><a href="#四元数表示三维旋转" class="headerlink" title="四元数表示三维旋转"></a>四元数表示三维旋转</h4><p>上面说了很多四元数的性质，但还是看不到四元数是怎么表示三维空间中的旋转的，下面直接上公式，下面旋转表示绕旋转轴$n$旋转$\theta$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
q &= [\cos(\theta/2),sin(\theta/2)\vec{n}]\\
&= [\cos(\theta/2),sin(\theta/2)n_x,sin(\theta/2)n_y,sin(\theta/2)n_z]
\end{aligned}</script><p>网上的证明方法有很多：<a href="https://ccjou.wordpress.com/2014/04/23/%E5%9B%9B%E5%85%83%E6%95%B8%E8%88%87%E4%B8%89%E7%B6%AD%E7%A9%BA%E9%96%93%E6%97%8B%E8%BD%89/" target="_blank" rel="noopener">这里</a>、<a href="https://krasjet.github.io/quaternion/quaternion.pdf" target="_blank" rel="noopener">这里</a>。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>UGUI中实现Tab键切换控件</title>
    <url>/2018/12/29/uguitabcontrol/</url>
    <content><![CDATA[<p>在UGUI 中，虽然提供了控件之间的导航切换，但是存在一些问题，首先，只有方向键切换，并没有Tab键的切换；另一个问题是，对于InputField 控件来说，当Focus点按哦InputField 之后，所有的输入事件都会被使用（EventData.Use），InputFiled控件在输入时不能进行导航。<br><a id="more"></a><br>既然不能偷懒，只能自己来实现，好在实现该功能也很简单，这里先上代码，下面会对代码和使用稍作解释。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Selectable))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TabNavController</span> : <span class="title">MonoBehaviour</span>, <span class="title">IUpdateSelectedHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//功能开关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> enableSubmit = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> enableVertical = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> enableHorizontal = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义各种按键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> tabBtn = <span class="string">"Tab"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> submitBtn = <span class="string">"Submit"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> verticalNavBtn = <span class="string">"NavVertical"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> horizontalNavBtn = <span class="string">"NavHorizontal"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selectable m_Selectable;</span><br><span class="line">    <span class="keyword">private</span> AxisEventData m_AxisEventData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector2 downVec = <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector2 rightVec = <span class="keyword">new</span> Vector2(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    Selectable selectable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_Selectable == <span class="literal">null</span>)</span><br><span class="line">                m_Selectable = GetComponent&lt;Selectable&gt;();</span><br><span class="line">            <span class="keyword">return</span> m_Selectable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">MoveDirection dir, Vector2 vec</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EventSystem.current.alreadySelecting)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_AxisEventData == <span class="literal">null</span>)</span><br><span class="line">            m_AxisEventData = <span class="keyword">new</span> AxisEventData(EventSystem.current);</span><br><span class="line"></span><br><span class="line">        m_AxisEventData.moveVector = vec;</span><br><span class="line">        m_AxisEventData.moveDir = dir;</span><br><span class="line">        ExecuteEvents.Execute&lt;IMoveHandler&gt;(gameObject, m_AxisEventData, ExecuteEvents.moveHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdateSelected</span>(<span class="params">BaseEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        BaseInput input = eventData.currentInputModule.input;</span><br><span class="line">        <span class="keyword">if</span> (input.GetButtonDown(tabBtn))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectable.FindSelectableOnRight() != <span class="literal">null</span>)</span><br><span class="line">                Move(MoveDirection.Right, rightVec);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Move(MoveDirection.Down, downVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (enableSubmit &amp;&amp; input.GetButtonDown(submitBtn))</span><br><span class="line">        &#123;</span><br><span class="line">            Move(MoveDirection.Down, downVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (enableVertical &amp;&amp; input.GetButtonDown(verticalNavBtn))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> axis = input.GetAxisRaw(verticalNavBtn);</span><br><span class="line">            Move(axis &gt; <span class="number">0</span> ? MoveDirection.Up : MoveDirection.Down, <span class="keyword">new</span> Vector2(<span class="number">0.0f</span>, axis));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (enableHorizontal &amp;&amp; input.GetButtonDown(horizontalNavBtn))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> axis = input.GetAxisRaw(horizontalNavBtn);</span><br><span class="line">            Move(axis &gt; <span class="number">0</span> ? MoveDirection.Right : MoveDirection.Left, <span class="keyword">new</span> Vector2(axis, <span class="number">0.0f</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记事件为used，避免后续继续处理该事件</span></span><br><span class="line">        eventData.Use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h2><p>在使用时有两点需要注意：</p>
<ul>
<li>这里采用<em>Button</em>来定义各个切换按键，使用前需要在<em>ProjectSetting</em>里面定义Tab、Submit、NavVertical、NavHorizontal 四个按键，设置参数如下：<img src="/2018/12/29/uguitabcontrol/tabbutton.png">  
<img src="/2018/12/29/uguitabcontrol/horbutton.png">  </li>
<li>UGUI默认会自动设置导航控件，但这结果可能并不是我们想要的，所以就需要显示进行指定。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>UGUI最佳实践(5)-其他 UI 优化技术和技巧</title>
    <url>/2018/12/14/UguiOtherOptimiseMethod/</url>
    <content><![CDATA[<p>本章主要包含一些有助于提高 UI 性能的建议，但是其中的一些方法可能难以维护，或者可能产生讨厌的副作用。也有一些方法是简化开发的变通方法，还有一些是解决性能问题的变通方法。<br><a id="more"></a></p>
<h2 id="基于RectTransform的布局"><a href="#基于RectTransform的布局" class="headerlink" title="基于RectTransform的布局"></a>基于RectTransform的布局</h2><p>Layout 组件比较昂贵，因为每次标记为dirty时，它们必须重新计算子元素的大小和位置。（详细可以参考<a href="https://blog.csdn.net/salvare/article/details/82432073" target="_blank" rel="noopener">图形重构部分</a>）。如果给定布局中元素数量相对较少且固定，且布局结构相对简单，则可以使用基于RectTransform的布局。</p>
<p>通过设置 RectTransform 的锚点，RectTransform 的位置和大小能够根据父物体进行变化。例如一个两列布局，可以像下面设置锚点：</p>
<ol>
<li>左侧一列锚点x：(0,0.5)，y:(0,1)</li>
<li>右侧一列锚点x：(0.5,1)，y:(0,1)</li>
</ol>
<p>RectTransform 底层将会驱动位置和大小的计算，这通常要比 Layout 系统效率更高。可以通过编写代码来完成RectTransform的布局，这相对要复杂一点，不在一部分的讨论范围之内。</p>
<h2 id="禁用画布"><a href="#禁用画布" class="headerlink" title="禁用画布"></a>禁用画布</h2><p>当需要显示或者隐藏部分 UI 时，通常是Enable或Disable 它的根物体，来确保所有的组件都不在接收外部消息。然而，这通常会造成画布丢弃它的VBO数据缓存，进行重构。如果经常发生这种情况，就会增加 CPU的占用，影响帧率。  </p>
<p>一个可行的变通方案是，将需要显示或者隐藏的物体，放到画布或者子画布下面，通过Enable或Disable 画布组件来实现物体的隐藏和显示。这种方法能够控制网格的显示与否，但是会将批处理的数据保留在内存中，还有就是，UI层级的OnEnable、OnDisable事件将不会触发。</p>
<p>需要注意的是，这种方式只是控制网格的显示和隐藏，UI中所包含的所有脚本都不会被禁用，所以这些脚本都还会执行外部回调，比如Update。</p>
<p>为了避免这个问题，在制作UI时，不应该在UI脚本内直接实现 MonoBehavior 的回调，而是通过 UI 根物体上的 “Callback Manager” 来进行统一的管理，当启用或者禁用Canvas 时，可以通过控制 “Callback Manager” 来确定是否执行回调。</p>
<h2 id="设置EventCamera"><a href="#设置EventCamera" class="headerlink" title="设置EventCamera"></a>设置EventCamera</h2><p>在WorldSpace模式和Camera模式下，为 Canvas 设置 EventCamera 或 RenderCamera 是非常重要的。通过脚本可以设置 worldCamera 属性来完成。</p>
<p>当EventCamera、RenderCamera没有指定时，UGUI 将会查找 MainCamera（物体标签为 MainCamera 的相机组件），这个过程中至少会调用一次 <a href="http://docs.unity3d.com/ScriptReference/GameObject.FindWithTag.html?_ga=2.28819900.1880489279.1538027592-1262540629.1537842997" target="_blank" rel="noopener">GameObject.FindWithTag</a> 方法，该方法在执行效率上很慢，所以应该避免这种情况。</p>
<p>这个问题在 Overlay 模式下不会发生。</p>
<h2 id="UGUI-源码定制"><a href="#UGUI-源码定制" class="headerlink" title="UGUI 源码定制"></a>UGUI 源码定制</h2><p>UGUI系统的设计已经能够支持多数使用情形，它的扩展性非常好，这也意味着在不破坏它的功能的情况下，很难对它进行优化。如果能够通过修改 UGUI 源码来提高性能，可以对源码进行重新编译并替换到Unity项目中，这个操作过程在<a href="https://bitbucket.org/Unity-Technologies/ui/" target="_blank" rel="noopener">源码库</a>中有提到，注意，需要确保自己获取了正确版本的源码。</p>
<p>修改源码应该作为最后的选择方案，因为它存在一些重大的缺点。首先，必须有一个可靠的方式将编译后的Dll分配个开发组各个成员和机器；其次，每次更新Unity，必须重新进行源码合并。如果能够通过扩展现有类，或者实现自己的类来解决问题，就不要采用修改源码的方式来解决。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
        <tag>unity最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>UGUI最佳实践(4)-UI 控件优化</title>
    <url>/2018/12/14/UguiOptimiseControl/</url>
    <content><![CDATA[<p>本章主要讨论特定类型UI控件的优化，虽然大多数UI控件在性能方面变化不大，但是有两个控件在项目后期经常会出现性能问题，这两个控件分别是 Text 和 ScrollRect。<br><a id="more"></a></p>
<h2 id="UI-Text"><a href="#UI-Text" class="headerlink" title="UI Text"></a>UI Text</h2><p>UGUI内置的 Text 组件可以方便的显示文字，然而，我并不知道它底层的很多行为，这些往往会成为性能的热点，必须记住的一点是，当我们向 UI 添加一个 Text 组件的时候，它会为每个字符创建一个四边形，这些四边形周围存在很多的空白空间，这取决于他的形状大小，这种方式很容易在放置文本的时候中断其他 UI 元素的批处理。</p>
<h3 id="文本网格重构"><a href="#文本网格重构" class="headerlink" title="文本网格重构"></a>文本网格重构</h3><p>文本网格重构是一个非常重要的问题，当 Text 组件发生变化时，就需要重新计算各个字符的四边形网格来显示实际的字符串，当Text组件或者父物体从 disable 转换到 enable状态时，即使字符串内容没有发生变化，也会重新进行计算。</p>
<p>这对于那些包含大量 Text 组件的 UI 是有性能问题的，最常见的情况就是排行榜和统计信息面板。显示/隐藏 UI 最常用的方法就是 Enable/Disbale 包含该 UI 的游戏对象，包含大量 Text 组件的 UI 经常会引起帧率的波动。</p>
<p>一个变通的解决方式，可以参考<a href>禁用 Canvas</a>。</p>
<h3 id="动态字体和字体图集"><a href="#动态字体和字体图集" class="headerlink" title="动态字体和字体图集"></a>动态字体和字体图集</h3><p>当整个项目需要显示的字符集非常大，或者在运行之前是未知的，那么动态字体是一种很方便的选择。在运行时，Unity 会将 Text 组件中使用的字符打包到一个字符图集中。每一个加载的字体都会生成自己的字符图集，即使它与另一种字体类型相同，比如，使用 Arial 字体创建一个 blod 类型的 Text，和使用 Arial Bold 字体创建一个 normal 类型的字体，虽然他们最终的效果一样，但是使用的却是不同的字符图集，一个是 Arial、一个是 Arial Bold。</p>
<p>从性能方面考虑，最重要的是要了解，UGUI 为每种字体大小、字体样式、字符维护一个字形，比如：现在有两个 Text 组件，显示内容都是 ‘A’，那么：</p>
<ol>
<li>如果两个Text 的字体大小（fontSize）相同，字符图集中只有一个‘A’字形。</li>
<li>如果两个 Text 的字体大小不一样（一个16，一个24），字符图集将会包含两份‘A’字形的拷贝（一个对应16号字体，一个对应24号字体）。</li>
<li>如果一个Text 的字体样式是 blod，而另一个是 normal，字符图集将会包含两份‘A’字形的拷贝（一个对应 bold 样式，一个对应 normal 样式）。</li>
</ol>
<p>每当 Text 遇到字符图集中没有的字符时，都会对字符图集进行重新构建。如果字符图集能够容纳新的字形，就会将它添加到图集中，并将图集重新上传到图形设备，如果字符图集太小不能容纳新字形，系统将会尝试重新构建字符图集，这个过程主要分两个阶段：<br>第一步，使用相同尺寸重新构建图集，但是只将当前活动的 Text 组件的字形添加到图集中，如果这些字形能够成功添加到图集中，那么第二步就不需要执行了。<br>第二部，如果第一步执行失败了，说明相同尺寸的图集已经容纳不下需要显示的字符，只能采用更大尺寸的图集，新尺寸 = 当前尺寸 x 2；例如 512 x 512 增大后会变成 512 x 1024 大小。<br>由于上面的算法，图集尺寸只有在创建的时候才会增大，考虑到图集重构的资源消耗，需要将该过程的消耗降到最低，有两个可用的方法：</p>
<ol>
<li>尽可能采用非动态字体以及采用预先配置好的字符集，对于字符范围约束比较好的情况，这通常能够很好工作，例如将可用的字符集限定为拉丁/ASCii。</li>
<li>如果需要极大量的字符集，比如整个 Unicode 字符集，此时必须使用动态字体，为了避免可预见的性能问题，在启动时使用一组合适的字符来填充字符图集，利用<a href="http://docs.unity3d.com/ScriptReference/Font.RequestCharactersInTexture.html?_ga=2.151954553.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">Font.RequestCharactersInTexture</a>方法实现该功能。</li>
</ol>
<p>需要注意的是，每个变化的 Text 组件都会触发字符图集的重构，所以当布局一个具有大量 Text 组件的 UI 的时候，最好是提前将所用到的字符收集起来，然后通过调用<a href="http://docs.unity3d.com/ScriptReference/Font.RequestCharactersInTexture.html?_ga=2.151954553.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">Font.RequestCharactersInTexture</a>方法在开始的时候填充字符图集。这样可以保证字符图集只重构一次，而不用每次添加新字形的时候都进行重构。</p>
<p>另外需要注意的是，当字符图集重构的时候，不包含在当前活动的 Text 组件的任何字符，不会出现在新创建的字符图集中，即使它们当初是通过<a href="http://docs.unity3d.com/ScriptReference/Font.RequestCharactersInTexture.html?_ga=2.151954553.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">Font.RequestCharactersInTexture</a>方法添加到图集中的，为了解决这个限制，监听 <a href="https://docs.unity3d.com/ScriptReference/Font-textureRebuilt.html" target="_blank" rel="noopener">Font.textureRebuilt</a> 事件（该事件在字符集重构的时候调用），并且通过查询 <a href="http://docs.unity3d.com/ScriptReference/Font-characterInfo.html?_ga=2.177507557.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">Font.charactorInfo</a> 来确保所有期望的字符被填充到图集中。</p>
<p>在有些情况下字符集是确定的，并且字符的位置也相对固定，此时一个更好的办法是通过自定义组件展示 Sprite 来完成字符的显示，一个可能的例子是得分显示功能。对于得分显示，它所需要的字符集是确定的（0-9），可以将一个整数分解成单个数字，然后组合显示出来，这种方式在计算、显示、动画方面比是使用 Text 组件要更快。</p>
<h3 id="回退字体和内存占用"><a href="#回退字体和内存占用" class="headerlink" title="回退字体和内存占用"></a>回退字体和内存占用</h3><p>首先解释一下什么是“回退字体”，当 Text 组件要显示一个字符的时候，首先从 Text 组件指定的字体中查找字符对应的字形，但是如果找不到怎么办？Unity采用了一个回退机制来解决这个问题，当我们导入字体的时候，导入设置中有一个“Font Names”属性，该属性相当于指定了一个备胎名字（回退字体的名称），如果在字体找不到相应的字符，会根据备胎名字，在项目中和用户机器上查找回退字体，最后在回退字体中查找相应字符。有两种情况会触发回调机制：</p>
<ol>
<li>Text 组件找不到指定的字体。这种情况是在导入设置时没有勾选 Incl. Font Data 选项（如果勾选该选项，在发布项目的时候，字体会自动的打包进项目中），而且用户机器上也没有安装该字体。</li>
<li>Text 组件指定的字体不包含所请求的字形。比如在 Arial 字体中只包含了 Ascii 字符集，而不包括 Unicode 字符。</li>
</ol>
<p>一个回退字体例子，首先导入两种字体,Arial和方正舒体，在导入设置中，将Arial字体的“Font Names”设置为“FZShuTi”,然后创建一个 Text 组件，在 Text 组件中输入一些汉字，此时字体采用系统默认的 Arial，汉字显示也是采用其默认的回退字体；现在将 Text 字体设置为导入的 Arial，此时的汉字显示采用回退字体。</p>
<p>为了支持这种回退行为，Unity 必须将 “Font Names”中列出的字体加载到内存中，如果回调字体的字符集非常大，那么回调字体的内存占用将会非常大，这在使用中文字符时非常常见。</p>
<h3 id="Best-Fit与性能"><a href="#Best-Fit与性能" class="headerlink" title="Best Fit与性能"></a>Best Fit与性能</h3><p>通常来说，永远不应该使用 Text 组件的 Best Fit 选项。<br>Best Fit 选项会自动的调节字体大小到 Text 组件边框能够容纳的最大尺寸，改尺寸受指定的最大/最小约束。上面提过，对于不同字体大小的字符，Unity都会向字符图集添加新的字形，所以启用 Best Fit 时，不同尺寸的字形将会非常快的把字符图集填满。</p>
<p>在Unity2017.3中，Best Fit 的字体大小检测并不是最优的，它会为尺寸测试过程中的每种尺寸都生成字形并添加到字符图集中，这增加了后期生成图集所需的时间。同样会造成字符图集的迅速填满，这会引起字符集重构，造成旧字形（当前没有Text 组件在显示的字符）被剔除出字符集。即使后续修复了这个问题，启用 Best Fit 仍然比较慢。</p>
<h2 id="TextMeshPro-Text组件"><a href="#TextMeshPro-Text组件" class="headerlink" title="TextMeshPro Text组件"></a>TextMeshPro Text组件</h2><p>TextMeshPro（TMP）是UGUI 内置 Text/TextMesh 组件的替代方案，TMP 采用有向距离场（SDF）作为其主要的渲染管线，使得文本在任何尺寸和分辨率下都能清楚的呈现，使用一系列自定义Shader来完成 SDF 渲染，TMP能够通过改变材质的属性来动态的改变文本的展示效果，包括 Outline、Shadow。</p>
<p>在Unity2018.1之后，TMP作为一个资源包包含在项目当中。可以通过 Package Manager进行管理。</p>
<h3 id="TMP的文本网格重构"><a href="#TMP的文本网格重构" class="headerlink" title="TMP的文本网格重构"></a>TMP的文本网格重构</h3><p>与内置的 Text 组件相似，改变文本的展示效果将会触发Canvas.BuildBatch、Canvas.SendWillRendererCanvas函数被调用，尽可能少的修改 TextMeshProUGUI.text 属性，如果需要频繁的修改 TextMeshProUGUI.text 属性，那么应该为 TextMeshProUGUI 创建单独Canvas 组件，来提高 Canvas重构效率。 </p>
<p>当需要在三维场景显示文本的时候，建议使用 TextMeshPro 来替代 TextMeshProUGUI,因为Canvas 的worldSpace 渲染效率比较低，直接使用 TextMeshPro 效率更高，并且不会引起 Canvas 的重构。</p>
<h3 id="字体和内存占用"><a href="#字体和内存占用" class="headerlink" title="字体和内存占用"></a>字体和内存占用</h3><p>TMP没有提供动态字体功能，因此只能依赖于回退字体，理解回退字体如何加载和使用对于内存优化至关重要。<br>TMP采用递归的方式来查找字符，查找策略如下：</p>
<ol>
<li>如果在TMP 的 Font Asset 中没有找到字符，TMP将会遍历Font Asset 的 Fallback Font Assets列表，从列表中第一个 Font Asset 开始查找，如果没有找到，继续递归它的 Fallback Font Assets。</li>
<li>如果仍然没有找到字符，接着在 TMP 的 spriteAsset 进行递归查找。</li>
<li>如果仍然没有找到字符，接着从 TMP_Settings.fallbackFontAssets 中进行递归查找。</li>
<li>如果仍然没有找到字符，从 TMP_Settings.defaultFontAsset 进行递归查找。</li>
<li>如果仍然没有找到字符，从 TMP_Settings.defaultSpriteAsset 进行递归查找。</li>
<li>最终如果还是没有找到，TMP 就会采用 TMP_Settings.missingGlyphCharacter 替换字符显示。(通常是一个方框)</li>
</ol>
<p>当场景或者项目引用 TMP Font Assets 时，它们就会被加载，主要包括 Text 组件的引用、TMP_Setting的引用、自身回退的引用，当第一个包含TMP Text 组件的场景被加载时，TMP_Setting中引用的 FontAsset 和 SpriteAsset 将会递归的加载。</p>
<p>此外，如果一个 TMP Text 组件引用的 FontAsset 在 TMP_Setting 加载时没有被加载，那么在该组件第一次被激活时，将会被递归加载。当项目中包含许多 FontAsset 时，必须时刻谨记这一过程，特别是可用内存比较成问题时。</p>
<p>由于以上原因，使用 TMP 进行项目本土化是一个需要解决的问题，把所有语言的字体资源都通过 TMP_Setting 进行加载对内存压力非常大。如果必须进行本地化，建议只有在需要时才指定字体资源以及回退资源（当场景加载的时候），或者使用AssetBundle 进行模块化加载。</p>
<p>当程序启动时，在初始化程序中验证用户的区域，然后为配置每个 Font Asset 的回退字体：</p>
<ol>
<li>为基础的 TMP Font Assets 创建 AssetBundle。（例如只包含拉丁字符）</li>
<li>每种语言的 Font Assets 分别创建各自的 AssetBundle。</li>
<li>在初始化步骤中首先加载基础的 AssetBundle。</li>
<li>然后根据用户的区域，加载对应的 AssetBundle。</li>
<li>设置步骤3中加载的的所有基础字体，将回退字体指定为步骤4加载的字体。</li>
</ol>
<p>如果不使用默认的 Sprite Asset 中的表情图片，可以将它的引用从 TMP_Setting 中移除，能够节省一点内存资源。</p>
<h3 id="TMP-的-Best-Fit-与性能"><a href="#TMP-的-Best-Fit-与性能" class="headerlink" title="TMP 的 Best Fit 与性能"></a>TMP 的 Best Fit 与性能</h3><p>再次强调，由于TMP不支持动态字体功能，所以 UGUI 部分描述的 Best Fit 问题是不存在的，唯一需要考虑的是，当使用 Best Fit （TMP中是Auto Size）时，TMP采用二分查找来查找合适的字体大小，最好只使用 AutoSize 来查找最合适的字体大小，一旦字体大小确定下来以后，关掉AutoSize 选项，然后手动设置字体大小，这样能够提升一定的性能，并且能够避免一组 Text 的字体大小不一样。</p>
<h2 id="Scroll-View-组件"><a href="#Scroll-View-组件" class="headerlink" title="Scroll View 组件"></a>Scroll View 组件</h2><p>在填充率问题之后，Scroll View 组件是引发性能问题的第二大根源。Scroll View 通常需要在 Content 区域内显示很多的元素，Scroll View 有两种使用方式：</p>
<ol>
<li>直接将所有的元素填充进来。</li>
<li>采用对象池，通过设置元素的位置，实现元素重复利用。</li>
</ol>
<p>这两种方式各有优劣,首先第一种当元素数量增多的时候，会增加实例化时间以及ScrollView 重构的时间，如果元素的数量非常少，比如只有少量的 Text 组件，那么采用这种方式是比较简单方便的；第二种方式需要花大量代码去实现，后面会提供两种实现方式，对于任何复杂的滚动 UI，通常都需要采用对象池来解决性能问题。</p>
<p>对于所有的使用方式，都可以通过向ScrollView添加 RectMask2D 组件来提升性能，该组件能够保证在 ViewPort 范围之外的元素不被添加到绘制列表中。（该列表中的元素在Canvas重构时，必须进行网格生成、排序、分析）</p>
<h3 id="简单Scroll-View-元素对象池实现"><a href="#简单Scroll-View-元素对象池实现" class="headerlink" title="简单Scroll View 元素对象池实现"></a>简单Scroll View 元素对象池实现</h3><p>为了使 Layout 系统能正确计算 ScrollView 内容大小以及 ScollBar 能够正常工作，可以使用 LayoutElement 作为占位符，为每个要生成的元素生成一个 LayoutElement。</p>
<p>然后创建一个对象池来管理 UI元素，当 LayoutElement 占位符进入到ScrollView 的显示区时，从对象池中获取UI元素并将它放到占位符下面。</p>
<p>这种方式会减少批处理元素数量，因为批处理的消耗是随着 Canvas Renderer 的数量增长，而非随着 RectTransform的数量。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>一般，当UI元素的父物体发生变化，或者兄弟顺序发生变化时，UI元素以及他的所有子物体都会被标记为 dirty，然后强制它们的Canvas 进行重构。</p>
<p>造成这一问题的原因是Unity 没有将父物体变化回调和兄弟顺序变化回调分开处理，两者都是触发 <a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTransformParentChanged.html?_ga=2.252027977.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">OnTransformParentChanged</a> 回调，而在UGUI的Graphic源码中，OnTransformParentChanged 方法调用了 <a href="http://docs.unity3d.com/ScriptReference/UI.Graphic.SetAllDirty.html?_ga=2.177709285.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">SetAllDirty</a> 函数，对于被标记为dirty 的Graphic，系统会在下一帧显示的时候，对它的Layout 和 顶点进行重构。</p>
<p>一种可能的办法是通过给每个UI元素的跟物体添加一个 Canvas来限制重构范围，但是这样会增加draw call 数量，进一步说，如果每个元素都包含多个Graphic组件、Layout组件，那么重构它们的花销将会明显降低帧率，尤其是在低配置设备上。</p>
<h3 id="基于位置的-ScrollView-对象池"><a href="#基于位置的-ScrollView-对象池" class="headerlink" title="基于位置的 ScrollView 对象池"></a>基于位置的 ScrollView 对象池</h3><p>为了避免上述的问题，可以通过移动RectTransform 的位置来实现元素的重用，这样能够减少不必要的重构，明显提升性能。<br>为了实现这种方式，最好的办法是自定义 ScrollView 的子类，或者自定义个 LayoutGroup 组件，后一种实现方式要稍微简单一点，只需要从 <a href="http://docs.unity3d.com/ScriptReference/UI.LayoutGroup.html?_ga=2.210618709.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">LayoutGroup</a> 继承一个子类就可以。</p>
<p>自定义 LayoutGroup 组件可以分析需要显示的数据，来检查有多少个必须显示的元素，然后调整 Content 的 RectTransform 组件，通过订阅 <a href="http://docs.unity3d.com/ScriptReference/UI.ScrollRect-onValueChanged.html?_ga=2.244681925.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">ScrollView.onValueChange</a> 事件来调整元素的位置。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
        <tag>unity最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>UGUI最佳实践(3)-填充率、画布、输入</title>
    <url>/2018/12/14/FillrateCanvasInput/</url>
    <content><![CDATA[<p>在本文中将介绍 ugui 优化过程中，涉及的三个非常重要的概念，分别是填充率（Fillrate）、画布（Canvas）、输入（Input）。<br><a id="more"></a></p>
<h2 id="解决填充率问题"><a href="#解决填充率问题" class="headerlink" title="解决填充率问题"></a>解决填充率问题</h2><p>在<a href="https://blog.csdn.net/salvare/article/details/82432073" target="_blank" rel="noopener">第一篇</a>中介绍了填充率以及过度绘制，过度绘制会造成GPU片段管线处理压力，主要有两种方式来减少这种压力（片段管线主要是负责像素输出）：</p>
<ol>
<li>减少 shader 片段的复杂度，详细参考下面 “UI Shader和低配设备” 章节内容。</li>
<li>减少需要采样的像素数量，比较常用的办法是采用多边形来替代四边形网格。</li>
</ol>
<p>由于内置的UI Shader都是标准通用的，一个很大问题就是填充率过高。这通常是因为大量的 UI 元素重叠，或者多个 UI 元素大面积占用屏幕，所有这些问题都会造成填充率过高。为了降低填充率，可以考虑以下的解决办法。</p>
<h3 id="禁用不可见的-UI"><a href="#禁用不可见的-UI" class="headerlink" title="禁用不可见的 UI"></a>禁用不可见的 UI</h3><p>对已有 UI 设计影响最小的是禁用不可见的元素。很常见的问题是在一个不透明的背景后面放置的 UI 元素，这些元素因为被前面的不透明背景遮挡，所以是不可见的，但是 UGUI 还是会傻傻的去计算渲染它。解决这一问题最简单的方法就是将这些物体禁用，其他解决办法参考下面的“禁用画布”部分内容。<br>最后，对于希望隐藏的物体，不要通过设置 alpha = 0来实现，原因和上面一样，alpha = 0时 GPU 还是需要对这些物体进行计算，占用宝贵的渲染时间。节制使用 Graphic 组件，如果 UI 元素不需要 Graphic 组件，可以将之删除。</p>
<h3 id="简化-UI-结构"><a href="#简化-UI-结构" class="headerlink" title="简化 UI 结构"></a>简化 UI 结构</h3><p>为了减少重构和渲染时间，非常重要的一点是减少 UI 元素数量，不要使用图形混合的方式来改变 UI 元素的色调，而是使用改变材质属性来代替，同样，不要创建一堆像文件夹一样的空物体来组织场景。</p>
<h3 id="采用多边形网格"><a href="#采用多边形网格" class="headerlink" title="采用多边形网格"></a>采用多边形网格</h3><p>当渲染透明、镂空的UI时，采用多边形网格来替代四边形，原因是对于全透明的部分，UGUI的渲染系统依然会进行计算，并且回合当前缓冲区进行混合，这就会造成overdraw，避免这种情况的唯一方式就是采用多边形网格来显示UI。具体实现方式可以参考<a href="https://blog.csdn.net/salvare/article/details/82724338" target="_blank" rel="noopener">这里</a></p>
<h3 id="禁用输出不可见的相机"><a href="#禁用输出不可见的相机" class="headerlink" title="禁用输出不可见的相机"></a>禁用输出不可见的相机</h3><p>如果显示一个不透明的全屏 UI，三维场景的渲染相机仍然会在 UI 之后进行渲染，渲染器并不知道全屏 UI 是否会遮挡整个三维场景。因此，如果显示一个完全不透明的全屏 UI，禁用所有被遮挡的三维渲染相机，消除这种无用的渲染，能够减轻 GPU 的渲染压力。如果 UI 没有遮挡住整个三维场景，你可能会想到将三维场景渲染到 RenderTexture，通过这样一次渲染代替持续不停地渲染，这样会产生一个问题，那就是不能显示场景动画内容，但是这个问题在大多数时候是可以接受的。 </p>
<p><strong>如果一个 Canvas 设置为 Screen Space - Overlay，无论场景有多少个相机，它都会渲染到屏幕。</strong></p>
<h3 id="大部分内容被遮挡的相机"><a href="#大部分内容被遮挡的相机" class="headerlink" title="大部分内容被遮挡的相机"></a>大部分内容被遮挡的相机</h3><p>许多全屏的 UI 并没有完全的将三维场景遮挡，而是留出一小块可见的区域，在这种情况下，一个更理想的方法是，只将可见的部分渲染到 RenderTexture，渲染到 RenderTexture 之后，将三维渲染相机禁用掉，最后将 RenderTexture 放到 UI 之后进行显示，来充当三维场景显示效果。</p>
<h3 id="基于组合的-UI"><a href="#基于组合的-UI" class="headerlink" title="基于组合的 UI"></a>基于组合的 UI</h3><p>通常采用组合的方式来搭建 UI ，虽然这么做相对简单，而且具有良好可迭代性，但是由于Unity 采用透明渲染队列渲染 UI ，所以性能上并不高。考虑这样一个简单的UI：一个背景、一个Button、Button上有一些Text，因为透明渲染队列中的对象是按照深度从后向前进行排序，对于 Text 覆盖的像素，GPU必须首先采样背景贴图，然后采样 Button 的贴图，最后采样 Text 的图集贴图，总共需要进行三次采样。当 UI 变得越来越复杂的时候，越来越多的元素叠加到背景之上，采样数量增长将非常快。</p>
<p>如果发现一个大的 UI 被填充率限制，那么最好的办法就是创建 UI 精灵，尽可能的将 UI 元素合并到背景图中，这样能够减少叠加在背景上的 UI 元素，但是这样会增加相应的工作量和增加项目图集的尺寸。</p>
<p>这种优化策略也可以用到 UI 元素的创建上面，考虑一个商城的 UI 设计，它包含一个滚动的商品面板，每个商品的 UI元素都有一个边框、一个背景、以及一些图标和价格标签、名称、信息等。商店的 UI 还需要一个背景，但是由于商品 UI 需要再背景上面进行滚动，所以没有办法将 商品元素合并到背景图中，但是，商品元素的边界、图标、名称等可以合并到商品元素的背景图中，根据商品图标的大小和数量，可以节省很多填充率。</p>
<p>这种组合策略也有几个缺点，这些进行合并的元素不能够进行重复利用，需要设计师进行额外的创建，这样会增加贴图的内存占用，尤其是在没有按需加载、卸载的时候。</p>
<h3 id="UI-Shader和低配设备"><a href="#UI-Shader和低配设备" class="headerlink" title="UI Shader和低配设备"></a>UI Shader和低配设备</h3><p>UGUI 内置Shader支持遮罩、裁剪以及其他复杂的操作，由于这增加了复杂性，需要进行许多额外的计算，所以在一些低配设备上性能不如简单的 2D Shader，例如iPhone 4.</p>
<p>对于一些低配设备，如果不需要遮罩、裁剪等一些特性，那么可以自定义一个简单的 Shader 来提高渲染性能，例如下面这个就是最简单的一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;UI/Fast-Default&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123; </span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot; </span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot; </span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot; </span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cull Off</span><br><span class="line">        Lighting Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest [unity_GUIZTestMode]</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;UnityUI.cginc&quot;</span><br><span class="line">            </span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : POSITION;</span><br><span class="line">                float4 color    : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : SV_POSITION;</span><br><span class="line">                fixed4 color    : COLOR;</span><br><span class="line">                half2 texcoord  : TEXCOORD0;</span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _TextureSampleAdd;</span><br><span class="line">            v2f vert(appdata_t IN)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f OUT;</span><br><span class="line">                OUT.worldPosition = IN.vertex;</span><br><span class="line">                OUT.vertex = mul(UNITY_MATRIX_MVP, OUT.worldPosition);</span><br><span class="line"></span><br><span class="line">                OUT.texcoord = IN.texcoord;</span><br><span class="line">                </span><br><span class="line">                #ifdef UNITY_HALF_TEXEL_OFFSET</span><br><span class="line">                OUT.vertex.xy += (_ScreenParams.zw-1.0)*float2(-1,1);</span><br><span class="line">                #endif</span><br><span class="line">                </span><br><span class="line">                OUT.color = IN.color * _Color;</span><br><span class="line">                return OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 frag(v2f IN) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Canvas-重构"><a href="#Canvas-重构" class="headerlink" title="Canvas 重构"></a>Canvas 重构</h2><p>为了展示 UI ，系统必须为它构建网格，这个过程包括执行动态布局、生成多边形、合并网格以减少 drawcall，这是一个多步骤处理过程，在<a href="https://blog.csdn.net/salvare/article/details/82432073" target="_blank" rel="noopener">前文</a>有更详细的描述。  </p>
<p>Canvas 重构会产生性能影响主要是两方面的原因：</p>
<ol>
<li>如果需要绘制的 UI 元素数量很多，批处理计算将会非常耗时，这主要是因为元素排序和分析的消耗增长，与元素数量的增长是非线性的。</li>
<li>如果 Canvas 经常变脏，那么过多的时间可能被消耗用来刷新变化很少的 Canvas。</li>
</ol>
<p>随着一个 Canvas 的 UI 元素数量增长，这两个问题变得更加严重。</p>
<p><strong>重要提示：只要 Canvas 下的元素发生变化，Canvas 就必须重新进行批处理，这个过程需要重新分析 Canvas 下的每个 UI 元素，无论这个元素是否发生变化。这里说的变化，是指任何会对UI显示产生影响的变化，包括为SpriteRenderer指定Sprite、位移、缩放、旋转、Text组件文本内容变化等等。</strong></p>
<h3 id="UI-元素排序"><a href="#UI-元素排序" class="headerlink" title="UI 元素排序"></a>UI 元素排序</h3><p>UI的构建是按照从后向前进的顺序，这个顺序是由物体在层级视图的排序决定的，在层级视图越靠上的元素排序越靠后。批处理就是按照层级视图从上到下的遍历物体，然后找到所有使用相同贴图、相同材质、并且这些物体之间没有被夹层分开（这里的夹层是指与这些物体材质不相同的物体，但是会覆盖这些物体）。夹层的出现将会强制中断批处理。</p>
<p>就像在<a href="https://blog.csdn.net/salvare/article/details/82468713" target="_blank" rel="noopener">UGUI性能分析工具</a>章节中提到的，可以使用 UI Profiler 和 Frame Debugger 来检查夹层。</p>
<p>这个问题最经常出现是当 Text 和 Sprite一个挨一个的放置：Text 组件的包围盒（这里是图形的包围盒，并不是 RectTransform 的边框）能够无形之中覆盖紧邻的 Sprite，因为多数 字符轮廓多边形是透明的。有两种方法可以解决这个为题：</p>
<ol>
<li>对 UI 元素进行重新排序，将夹层从可批处理的两个对象之间移走。</li>
<li>移动物体的位置，使物体之间不再交叉覆盖。</li>
</ol>
<p>在UnityEditor中，通过启用 UnityFrameDebuger可以检测到这两种操作。通过在 UnityFrameDebugger 中观察 drawcall 数量，有可能找到一个 drawcall 数量最少的排序方式和位置。</p>
<h3 id="分割画布"><a href="#分割画布" class="headerlink" title="分割画布"></a>分割画布</h3><p>除了一些非常简单的情况之外，通常将一个Canvas 分割开来是比较好的办法，将子元素移到子画布或者兄弟画布。</p>
<p>兄弟画布最佳用处是在，UI存在一个区域必须与其他区域的深度进行分离，如果在所有层级之上、或者之下。（例如新手指引的箭头）<br>在大多数其他情况下，使用子画布更加方便，因为子画布的设置直接从父画布进行继承。<br>看上去将 UI 分割成多个 子画布是一种不错的做法，但是请记住，批处理是不能跨 Canvas 进行的，一个良好的UI设计需要再 最小化重构消耗 和 最小化drawcall 进行平衡。</p>
<h3 id="通用准则"><a href="#通用准则" class="headerlink" title="通用准则"></a>通用准则</h3><p>因为当 Canvas 下的元素发生变化时，Canvas就需要重新批处理，所以通常最好是将 Canvas 分成至少两部分，此外，如果元素需要同时进行变化，最好将这些物体放到同一个Canvas下面，一个例子就是进度条和计时器，这些都依赖于相同的底层数据，需要同时进行变化，因此他们应该放到同一个画布上。  </p>
<p>分成两部分的UI分别用两个Canvas 进行处理，一个 Canvas 用来放着静态的、不需要变化的物体，例如背景、Label，这样这个Canvas只需要在第一次显示时批处理一次，而后就不需要在进行重新批处理。另个 Canvas 用来放置 动态的、经常需要变化的物体，这可以确保通过这个Canvas 可以 重新批处理大部分的脏元素，如果动态元素数量变得非常多，可能需要将动态元素进行一步分组，例如不断变化的元素、偶尔变化的元素。</p>
<p>实际上在实践中是相当困难的，尤其是将UI控件封装到 预制体时，许多UI通过将比较耗性能的控件拆分到子画布上来细分Canvas。</p>
<h3 id="Unity5-2-和-优化批处理"><a href="#Unity5-2-和-优化批处理" class="headerlink" title="Unity5.2 和 优化批处理"></a>Unity5.2 和 优化批处理</h3><p>在Unity5.2版本中，批处理代码被大量重写，与Unity4.6、5.0、5.1版本相比，在性能上有了很大的提升，此外，在多核设备上，Unity将大部分处理移到工作线程上，总的来说，Unity5.2减少了将UI分割成大量子画布的需要，现在，在移动设备上许多 UI 可以只使用2、3个画布就可以实现性能要求。</p>
<p>更多关于5.2的优化内容，可以参考<a href="http://blogs.unity3d.com/2015/09/07/making-the-ui-backend-faster/?_ga=2.233234141.2138003680.1535892227-1079978078.1535205694" target="_blank" rel="noopener">这篇文章</a>.</p>
<h2 id="UGUI-的输入和射线检测"><a href="#UGUI-的输入和射线检测" class="headerlink" title="UGUI 的输入和射线检测"></a>UGUI 的输入和射线检测</h2><p>默认情况下，UGUI 使用 Graphic Raycaster 组件来处理射线检测，输入信息是通过 Standalone Input Manager 来处理，该组件可以处理鼠标和触摸输入。</p>
<h3 id="移动设备上的鼠标输入检测错误（5-3）"><a href="#移动设备上的鼠标输入检测错误（5-3）" class="headerlink" title="移动设备上的鼠标输入检测错误（5.3）"></a>移动设备上的鼠标输入检测错误（5.3）</h3><p>在Unity5.4之前，每个活动的 Canvas 上都挂载一个 Graphic Raycaster组件，并且每帧都需要检测一次光标的位置，即使没有有效的触摸输入。无论什么平台都会发生这种情况，没有鼠标的 IOS 和 Android 平台，仍然会检测鼠标位置以及鼠标之下的 UI 元素，并确定是否需要发送 Hover 事件。 </p>
<p>这是非常浪费 CPU 的，已经被证实浪费了 5%或者更多的 CPU 时间。</p>
<p>这个问题在 Unity5.4 之后已经得到解决，在5.4之后，没有鼠标的设备将不再查询鼠标的位置，从而减少了不必要的射线检测。</p>
<p>如果使用5.4之前的版本，强烈建议移动端开发者创建自己的 Input Manager 来替代 Standard Input System，实现方法也很简单，只需要将 Standard Input Manager 源码进行拷贝，然后将 ProcessMouseEvent 方法注释掉，同时将该方法的调用也注释掉即可。</p>
<h3 id="射线检测优化"><a href="#射线检测优化" class="headerlink" title="射线检测优化"></a>射线检测优化</h3><p>Graphic Raycaster 组件的实现比较简单，检测所有 Raycast Target 设置为 true 的 Graphic 组件，对于每个射线检测目标，Raycaster会执行一系列测试，如果检测的目标通过所有的测试，则将该目标添加到 列表中（保存射线击中的物体）。</p>
<p>Raycast 实现细节，上面说的一系列测试包括：</p>
<ol>
<li>如果目标是活动的、可以绘制的（包括 Graphic 组件）。</li>
<li>如果输入位置在目标的 RectTransform 组件范围之内。</li>
<li>如果检测目标包含 ICanvasRaycastFilter 组件，或者是该组件的子物体，那么需要 ICanvasRaycastFilter 允许进行射线检测。</li>
<li>当所有的物体检测完毕之后，在击中列表中的目标按照深度进行排序，过滤掉反向的目标，过滤掉在摄像机之后的目标。</li>
<li>如果设置了 blockingObjects选项，Graphic Raycaster 就可以检测 3D、2D的物理对象（Collider、2DCollider）。</li>
<li>如果2D、3D blockingObjects 启用了，位于 raycast blocking 指定的层中的2D、3D物体，将会从击中列表中移除。</li>
</ol>
<p>最终确定下射线检测结果。</p>
<h3 id="射线检测优化技巧"><a href="#射线检测优化技巧" class="headerlink" title="射线检测优化技巧"></a>射线检测优化技巧</h3><p>由于所有的射线检测必须由 Graphic Raycaster，所以最好的做法是只有那些必须接收UI事件的物体才开启 “Raycast Target”选项，需要进行射线检测的物体越少，层级也嵌套越少，则射线检测的速度越快。</p>
<p>对于必须相应 UI 事件并且拥有多个可绘制对象的复合型 UI 控件，例如 Button 包括一个IMage、一个Text，更好的做法是在复合控件的根物体上添加一个 Raycast Target，当根物体收到 UI 事件之后，可以转发到各个感兴趣的组件。</p>
<h3 id="嵌套深度和射线过滤"><a href="#嵌套深度和射线过滤" class="headerlink" title="嵌套深度和射线过滤"></a>嵌套深度和射线过滤</h3><p>在搜索射线过滤器的时候，每个 Graphic Raycaster 都会遍历 Transform 层次结构直到根物体。这种操作的成本与 Transform 的层次深度成正比，每个物体上的所有组件都必须进行测试，看看是否实现了 ICanvasRaycastFilter 接口，所以这不是一个便宜的操作。</p>
<p>实现 ICanvasRaycastFilter 接口的标准组件有几个，比如 CanvasGroup、Image、Mask、RectMask2D，所以不能简单的消除遍历。</p>
<h3 id="子画布和-OverrideSorting-属性"><a href="#子画布和-OverrideSorting-属性" class="headerlink" title="子画布和 OverrideSorting 属性"></a>子画布和 OverrideSorting 属性</h3><p>子画布的 overrideSorting 属性将导致图形射线检测停止往深层次遍历，如果可以在不引起排序或者射线检测问题的情况下启用它，那么可以使用它来降低射线检测层次结构遍历成本。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
        <tag>unity最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>UGUI最佳实践(2)-UGUI性能分析工具</title>
    <url>/2018/12/14/uguiprofiler/</url>
    <content><![CDATA[<p>性能分析有很多可用的工具，下面是常用的几种：<br><a id="more"></a></p>
<ol>
<li>Unity Profiler</li>
<li>Unity Frame Debugger</li>
<li>Xcode Instruments</li>
<li>Xcode Frame Debugger</li>
</ol>
<h2 id="Unity-Profiler"><a href="#Unity-Profiler" class="headerlink" title="Unity Profiler"></a>Unity Profiler</h2><p>Unity Profiler主要用来进行比较分析：在Unity Profiler运行的时候，通过启用、禁用一些 UI 元素，如果发现波形的振幅迅速变小，那么说明这部分的UI可能存在一定的性能问题。</p>
<p>为了分析这种情况，观察Unity Profiler 中的<em>Canvas.BuildBatch</em>和 <em>Canvas.SendWillRenderCanvases</em> 行。<br><img src="https://unity3d.com/sites/default/files/learn/02-sendwillrendercanvases.png" alt="Unity Profiler"></p>
<p><em>Canvas.BuildBatch</em> 是本机代码调用，主要是Canvas的批处理构建操作，可以参考<a href>前文</a>的描述。<br><em>Canvas.SendWillRenderCanvases</em> 包含对 Canvas.willRenderCanvas 事件订阅者的调用，UGUI 的 CanvasUpdateRegistry 类接收该事件，并且进行重构操作，所有被标记为 dirty 的组件，它们的 CanvasRenderer 将在此时被更新。</p>
<p><em>提示</em>：为了能够更贱方便的观察性能变化，除了 “Renderer”、“Scripts”、“UI” 之外，其他的分类可以禁用掉，通过点击分类前面的小方块可以完成禁用，通过上下拖动各个分类也可以进行排序。<br><img src="https://unity3d.com/sites/default/files/learn/02-cpu-profiler.png" alt><br>UI分类是在2017.1之后才添加的，不幸的是，部分UI更新操作的分类并不正确，所以在观察 UI 曲线的时候需要非常小心，因为它可能包括相关的UI 调用，例如，Canvas.SendWillRenderCanvases 的分类是 “UI”，但是 Canvas.BuildBatch 的分类是 “Others”、“Renderer”。</p>
<p>在2017.1之后，同时还新增了 <a href="https://docs.unity3d.com/Manual/ProfilerUI.html?_ga=2.184403302.1506199275.1535946242-1633858718.1535607747" target="_blank" rel="noopener">UI Profiler</a>，它包含两条时间线和一个 Batch 视窗。<br><img src="https://unity3d.com/sites/default/files/learn/02-ui-profiler.png" alt><br>第一个时间线按照“Layout”、“Render”两个分类来展示 CPU 的消耗，这个也存在上述问题，有些方法没有进行说明。<br>第二个时间线显示了Batch的个数、定点数量以及事件标记，在上面的截图中，可以看到在时间线上有几个按钮点击事件，这些标记可以帮助你判断是什么导致 CPU 出现尖峰。</p>
<p>最后，UI Profiler 提供的最有用的功能是 Batch 视窗，在视窗的左边，通过树形视图显示每个 Canvas以及他们声称的 Batch，数据列包含了一些关于Batch 和 Canvas 的有用信息，理解 Batch Breaking Reason（中断批处理的原因） 的含义对于更好的优化 UI 性能至关重要。</p>
<p>Canvas 在进行 Batch 的时候，可能会由于某些原因而停止，Batch Breaking Reason列指明了这个原因。其中最常见的原因是使用了不同的贴图、不同的材质，在多数情况下，该问题可以通过使用 Sprite Atlas 来解决，最后一列显示了与该 Batch 相关的一些物体，可以通过双击该物体来选择物体。</p>
<p>从2017.3开始，Batch 视窗只能在 Editor 模式下工作，通常Batch 在各个设备上是相同的，所以这依然是很有用的，如果你怀疑在不同的设备上 Batch 结果不一样，可以使用 Frame Debugger 来做进一步判断。</p>
<h2 id="Unity-Frame-Debugger"><a href="#Unity-Frame-Debugger" class="headerlink" title="Unity Frame Debugger"></a>Unity Frame Debugger</h2><p>对于减少由 UGUI 产生的drawcall，Unity Frame Debugger 是一个非常有用的工具，可以在Windwos-&gt;Frame Debugger下打开该工具，当启用时，它将显示所有由 Unity 产生的 drawcall，当然也包括UGUI产生的。</p>
<p>UGUI的 drawcall 根据渲染模式的不同，所在的位置也有所不同：<br><em>Screen Space - Overlay</em> 模式时，将会出现在 Canvas.RenderOverlays 分组。<br><em>Screen Space - Camera</em> 模式时，将会出现在所选相机的 Camera.Render 分组，作为一个 <em>Render.TransparentGeometry</em> 子组。<br><em>World Space</em>渲染模式时，将会作为一个 <em>Render.TransparentGeometry</em> 子组，出现在每个可以观察到该 Canvas 的相机下。</p>
<p>通过“Shader：UI/Default”可以找到各个UI对象（假如没有使用自定义Shader的情况下），如下图:<br><img src="https://unity3d.com/sites/default/files/learn/02-framedebugger.png" alt></p>
<p>通过这一组信息，可以很容易将 Canvas 的批处理能力放到最大化，最常见的与设计相关的中断批处理现象就是，不小心将UI进行重叠。</p>
<p>由于 UGUI 的渲染完全在透明队列中，如果在四边形A上有不能合批的其他四边形B，那么A就必须在B之前被绘制，因此A不能和在B之上的四边形C进行合批。</p>
<p>举个列子，假设有三个相互重叠的四边形A,B,C,其中A、C使用相同的材质，B使用不同的材质，因此四边形B不能和A、C进行合批。在布局UI时，从上到下它们的顺序是A、B、C，那么A和C是不能进行合批的，因为B必须在A之前、C之后进行绘制。然而，如果B放在A、C之前或者之后，那么A和C就可以进行合批。</p>
<p>更加详细的内容，会在后续章节进行研究。</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>当收集到分析数据之后，可能会得出一些结论，如果 <em>Canvas.BuildBatch</em> 或者 <em>Canvas.UpdateBatches</em> 占用了大量的CPU 时间，那么一个可能的问题是，一个Canvas 包含了过多的 CanvasRederer 组件，可以参考<a href>分割画布</a>部分内容解决该问题。</p>
<p>如果 GPU 消耗了大量的时间去渲染 UI,并且 Frame Debugger 表明片段管线是性能的瓶颈，那么可能的原因是 UI 的像素填充率（pixel fill rate）超过了GPU 的处理能力，最有可能是出现了 UI 透支，可以参考<a href>修复填充率问题</a>部分内容。</p>
<p>如果 Graphic 重构消耗了大量的 CPU 时间，大量时间用来执行 <em>Canvas.SendWillRenderCanvases</em>和<em>Canvas::SendWillRenderCanvases</em>，此时需要进一步分析该问题，Graphic 重构过程中的某些步骤可能存在问题。</p>
<p>如果大量大时间花费在了 <em>WillRenderCanvas</em> 下的 <em>IndexedSet_Sort</em> 或者 <em>CanvasUpdateRegistry_SortLayoutList</em>，那么时间是用来排序脏的Layout 组件列表。此时可以考虑减少Cavans下的Layout 组件。参考<a href>使用RectTransform 替代 Layout</a>、<a href>分隔画布</a>中的内容来解决该问题。</p>
<p>如果大量的时间花费在了 <em>Text_OnPopulateMesh</em>，那么元凶就是文本网格的生成，参考<a href>Best Fit</a>、<a href>禁用画布</a>中的内容来解决问题，如果存在大量的 Text 被重构，但实际文本内容却没变化，此时可以考虑<a href>分隔画布</a>中的一些建议。</p>
<p>如果大量的时间花费在了 <em>Shadow_ModifyMesh</em> 或者 <em>Outline_ModifyMesh</em>（或者其他的一些 ModifyMesh 实现），那么问题在于花费了大量的时间来计算网格修改器，考虑删除这些组件，然后通过静态图片实现这些效果。</p>
<p>如果在 <em>Canvas.SendWillRenderCanvases</em> 没有发现特定的性能热点，或者他好像每一帧都在执行，那么问题可能是将动态元素和静态元素分到同一个组中，这会强制整个 Canvas 重构非常频繁。参考<a href>画布分隔</a>部分内容进行解决。</p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
        <tag>unity最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua优化列表多元素移除功能</title>
    <url>/2018/12/14/luaremoveall/</url>
    <content><![CDATA[<p>在 Lua 的内置库中，table 提供了 <em>table.remove(t,[num])</em> 来删除列表中的元素，因为在该函数的执行过程涉及到了内存的移动，所以在删除多个元素的时<a id="more"></a>候，如果每次都调用该函数，就会造成多次内存移动。</p>
<p>针对这一点，对 table 进行一些删除操作上的性能优化，代码基本上是从 C# 源码中抄过来的:-D，介绍在<a href="https://blog.csdn.net/salvare/article/details/81584827" target="_blank" rel="noopener">这里</a>，下面直接附上代码，里面注释比较清楚，有什么问题，希望能够留言指出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">local TableUtil = &#123;&#125;</span><br><span class="line"></span><br><span class="line">---从列表 t 中删除从 pos 开始的 num 个元素。</span><br><span class="line">---@t 删除元素的列表</span><br><span class="line">---@pos 开始删除索引</span><br><span class="line">---@num 要删除元素的数量，如果没有指定，则删除 pos 之后的所有元素</span><br><span class="line">function TableUtil.ClearArray(t,pos,num)</span><br><span class="line">    assert(t ~= nil,<span class="string">"The array:t is nil"</span>)</span><br><span class="line">    assert(pos &gt; <span class="number">0</span> <span class="keyword">and</span> pos&lt;=#t,<span class="string">"The pos is out range"</span>)</span><br><span class="line"></span><br><span class="line">    --如果没有指定 num 值，则默认 pos 之后全部删除</span><br><span class="line">    num = num <span class="keyword">or</span> #t</span><br><span class="line"></span><br><span class="line">    --需要删除的最后一个元素的索引</span><br><span class="line">    local index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">0</span> then</span><br><span class="line">        index = pos + num - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        --为了保持从尾往头删，调换头尾索引</span><br><span class="line">        pos,index = pos + num + <span class="number">1</span>,pos</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    --对头尾索引进行限制，避免超界</span><br><span class="line">    index = index &gt; #t <span class="keyword">and</span> #t <span class="keyword">or</span> index</span><br><span class="line">    index = index &lt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> index</span><br><span class="line">    pos = pos &lt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> pos</span><br><span class="line"></span><br><span class="line">    local maxn = #t - index + pos - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    table.move(t,index+<span class="number">1</span>,#t,pos)</span><br><span class="line"></span><br><span class="line">    local temp = #t</span><br><span class="line">    <span class="keyword">while</span> temp &gt; maxn  <span class="keyword">do</span></span><br><span class="line">        table.remove(t,temp)</span><br><span class="line">        temp = temp - <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">---从列表 t 中删除，所有满足 match 条件的元素</span><br><span class="line">---@t 列表</span><br><span class="line">---@match 筛选列表</span><br><span class="line">function TableUtil.RemoveAll(t,match)</span><br><span class="line">    assert(match ~= nil,<span class="string">"Then match argument cannot be nil"</span>)</span><br><span class="line"></span><br><span class="line">    --找到第一个需要删除的元素的索引 num</span><br><span class="line">    local num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; #t <span class="keyword">and</span> <span class="keyword">not</span> match(t[num])) <span class="keyword">do</span></span><br><span class="line">        num = num + <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    --如果需要删除的索引超过列表最大索引，则表明没有满足删除条件的元素</span><br><span class="line">    <span class="keyword">if</span> num &gt; #t then</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    --将 num 之后不需要删除的元素，移动到需要删除的元素之前，这样可以避免拷贝</span><br><span class="line">    local i = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= #t) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= #t <span class="keyword">and</span> match(t[i])) <span class="keyword">do</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt;= #t then</span><br><span class="line">            t[num] = t[i]</span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    local result = #t - num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    --清楚需要删除的元素</span><br><span class="line">    ClearArray(t,num,result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TableUtil</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII与 UTF-8编码</title>
    <url>/2018/12/14/asciiwithutf8/</url>
    <content><![CDATA[<p>在计算机内部，所有的数据都是以二进制0、1表示，每个二进制位为一个比特（Bit），但是一个Bit能表示的信息太少，所以一个最小的操作单位应该包含多个多个比<a id="more"></a>特，起初这个单位并没有统一标准，有4比特一个单位的，也有7个、8个比特一个单位的，但是最终还是8比特单位一统江湖，这就有了后来的 1Byte= 8Bit。</p>
<p>为什么需要对字符编码呢？如果没有字符编码，通过计算机进行聊天时，可能是这样的：A-&gt;B:01101000 01101001，B收到信息之后可能就需要查字典去了，那为什么计算机不帮我查好呢！所以编码就是二进制与字符的转换关系。</p>
<h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>1967年美国制定了一套编码规范，其中规定了 128 个字符与二进制的对应关系，称之为 ASCII 编码，二进制范围是 0-127：[00000000,011111111]，可以看出来最高位没有使用。</p>
<p>虽然 ASCII 规范出来了，但是存在很多不足，主要原因是它所包含的字符集太小，只有拉丁字母、阿拉伯字符、英文标点和一些控制字符，此时欧洲人第一个站出来表示不高兴，比如意大利语的字符 Á 没法表示，正好ASCII 编码中最高位被闲置了，把这部分进行利用，将ASCII 从7位扩展成了8位，这就是扩展ASCII（EASCII）。</p>
<p>将 ASCII 编码扩展之后，欧洲人高兴了，但是其他语音还是不能处理。为了解决这些语言的编码问题，各国开始搞自己的编码，这期间产生了许多种编码格式，比如常见的汉字编码格式 GB-2312。各个国家都采用不同的编码，这样是没办法相互通信的，所以需要有一种编码，能够涵盖所有语言符号，这就是 Unicode。</p>
<h2 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h2><p>Unicode 也叫万国码、统一码、国际码，它是为了解决各个编码格式的不兼容问题，它为各个语言字符进行了编号，比如汉字“你”编号为 0x4f60，“好”编号为 0x597d。</p>
<p>Unicode 只是对各个语言字符进行了编号，但是没有对编号如何存储、存储几个字节进行规定，还是以汉字“你”为例，它的编号是 0x4f60，最少可以用两个字节来存储，也可以用3个、4个；另一个问题是计算机怎么判断这两个字节是一个Unicode字符还是两个ASCII字符呢。基于这些问题，产生了多种 Unicode 字符集<strong>实现</strong>格式，其中就包括 UTF-8.</p>
<h2 id="UTF-8-编码实现"><a href="#UTF-8-编码实现" class="headerlink" title="UTF-8 编码实现"></a>UTF-8 编码实现</h2><p>UTF-8 全称是 8 Bit Unicode Transformation Format，UTF-8是Unicode编码的具体实现方式之一，它最主要的优点就是可变长度，字符编码通常由 1-4 个字节来表示（存在5、6个字节的字符，但是不在 Unicode 字符集中），相比定长的实现方式，能够节省更多的空间。</p>
<p>针对任意字符编码，它的编码规则如下：</p>
<ol>
<li>对于单字节字符，字节的最高比特位设置为0。</li>
<li>多字节序列的<strong>首字节的最高有效位</strong>决定了字节序列的长度，最高有效位有几个连续的 1，表示字节序列多长，比如首字节为 11000000 表示是2个字节，11100000 表示3个字节，11110000表示4个字节。</li>
<li>多字节序列除首字节遵守规则2之外，其他字节最高有效位为10。</li>
</ol>
<p>根据上面的规则，对各个长度的字节序列总结如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节序列</th>
<th>码点位数</th>
<th>码点起值</th>
<th>码点终值</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4  </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>U+0000</td>
<td>U+007F</td>
<td>0xxxxxxx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>U+0080</td>
<td>U+07FF</td>
<td>110xxxxx</td>
<td>10xxxxxx</td>
</tr>
<tr>
<td>3</td>
<td>16</td>
<td>U+0800</td>
<td>U+FFFF</td>
<td>1110xxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
<tr>
<td>4</td>
<td>21</td>
<td>U+10000</td>
<td>U+1FFFFF</td>
<td>11110xxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
</tbody>
</table>
</div>
<p>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；</p>
<ol>
<li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；</li>
<li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；</li>
<li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；</li>
<li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；</li>
</ol>
<p>因此，对UTF-8编码中的任意字节，根据第一位，可判断是否为ASCII字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。</p>
<h2 id="关于BOM"><a href="#关于BOM" class="headerlink" title="关于BOM"></a>关于BOM</h2><p>通常在保存UTF-8的时候，这里以 NotePad++ 为例， 会出现两个可选项：UTF-8，UTF-8-BOM，那么这两个选项有什么区别呢？很明显就是一个带BOM、一个不带BOM。BOM全名是字节顺序标记（Byte-Order-Mark），它存储在文件的开头，用来表示文件的字节顺序是大端还是小端，BOM通常是一个 U+FEFF 字符，UTF-8 一般是 EF、BB、BF。</p>
<p>对于 UTF-8 来说，BOM是完全没有存在的必要的，因为 UTF-8 是直接操作的单个字节，而非操作多字节整形（比如C的int），所以不存在大小端问题，UTF-8 文件的 BOM 作用只是表示这个文件是一个 Unicode 编码文件。</p>
<p>对于需要进行网络传输的 UTF-8 文件来说，谨慎使用 BOM，因为它会影响字符内容的解析，当从数据流解析出来的 UTF-8 字符在开头出现乱码，那么八成是 BOM 引起的。</p>
<p>最后需要提醒的是，使用 Windows 的记事本存储为 UTF-8 格式的时候，默认是添加 BOM 头的！！！所以珍爱生命，远离记事本！</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII编码</a><br><a href="https://zh.wikipedia.org/wiki/UTF-8#UTF-8%E7%9A%84%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">UTF-8编码</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中实现类似C#风格format函数</title>
    <url>/2018/12/14/luaformat/</url>
    <content><![CDATA[<p>Lua 的字符串格式化是继承 C 的方式，采用%s、%d、%f 等方式进行格式化，而在 C# 中采用 {0}、{0:D2} 的方式进行格式化，下面代码在 Lua 中实现 C# 形<br><a id="more"></a>式的格式化，这里只实现了{0}形式，对于{0:D2}等形式不支持。</p>
<p><strong>这种实现与 lua 的格式化相比，并不具备性能优势，完全是因为个人习惯使用 C# 的格式化形式。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Format</span><span class="params">(fmt,...)</span></span></span><br><span class="line">  <span class="built_in">assert</span>(fmt ~= <span class="literal">nil</span>,<span class="string">"Format error:Invalid Format String"</span>)</span><br><span class="line">  <span class="keyword">local</span> parms = &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">(k)</span></span></span><br><span class="line">    <span class="comment">--从 C# 数组习惯转到 Lua</span></span><br><span class="line">    k = k+<span class="number">1</span></span><br><span class="line">    <span class="built_in">assert</span>(k &lt;= #parms <span class="keyword">and</span> k &gt;=<span class="number">0</span> ,<span class="string">"Format error:IndexOutOfRange"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tostring</span>(parms[k])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(fmt,<span class="string">"&#123;(%d)&#125;"</span>,search))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>测试代码如下：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Format(<span class="string">"&#123;0&#125;,&#123;1&#125;,&#123;2&#125;"</span>,<span class="string">"abc"</span>,<span class="string">"cc"</span>,<span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(Format(<span class="string">"&#123;2&#125;,&#123;0&#125;,&#123;1&#125;"</span>,<span class="string">"abc"</span>,<span class="string">"cc"</span>,<span class="number">12</span>))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>UGUI最佳实践(1)-UGUI基础</title>
    <url>/2018/12/11/UGUIBasic/</url>
    <content><![CDATA[<p>在学习和使用UGUI之前，首先理解UGUI的各个组成部分非常重要，UGUI是由多个类和组件构成的系统。本章主要介绍一些相关术语，这些术语将贯穿整个系统，然后还会涉及到一些UGUI底层的知识。<br><a id="more"></a></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="Canvas-画布组件"><a href="#Canvas-画布组件" class="headerlink" title="Canvas - 画布组件"></a>Canvas - 画布组件</h3><p>Canvas组件是将其下的各个排序好的图形（Image、Text）提供给渲染系统，然后再由渲染系统将之显示到屏幕或者三维世界中。</p>
<p>Canvas首先对它下面的网格进行批处理（Batch），然后生成相应的渲染指令，最后将指令发送到Unity的图形渲染系统。所有这些工作都是在C++代码中完成的，这个过程称为rebatch或者batch build。当Canvas包含的网格需要重新进行批处理时，那么认为这个Canvas是脏的（dirty）。</p>
<p>嵌套在其他Canvas下的Canvas称为子画布（Sub-Canvas），子画布将它的子物体与父画布隔离开来，一个脏的子物体不会强制父画布进行重构，反之也一样。当然存在一些例外情况，比如：父画布尺寸变化引起子画布尺寸变化，这个时候父画布和子画布都需要进行重构。</p>
<h3 id="Canvas-Renderer-组件"><a href="#Canvas-Renderer-组件" class="headerlink" title="Canvas Renderer 组件"></a>Canvas Renderer 组件</h3><p>上面提到画布对网格进行批处理，Unity利用 <em>Canvas Renderer</em> 组件将网格信息提供给Canvas。</p>
<h3 id="Graphic-组件"><a href="#Graphic-组件" class="headerlink" title="Graphic 组件"></a>Graphic 组件</h3><p><em>Graphic</em> 组件是 UGUI 的 C# 库提供的，不涉及本机代码导入，它是所有 UGUI 可绘制网格的基类，大部分内置UI图形都是通过继承 <em>MaskableGraphic</em> 基类来实现的，该基类允许通过 IMaskable 接口实现遮罩功能，主要的子类包括 Image、Text，两者都有同名的组件。</p>
<h3 id="Layout-组件"><a href="#Layout-组件" class="headerlink" title="Layout 组件"></a>Layout 组件</h3><p><em>Layout</em> 组件控制 <em>RectTransform</em> 的尺寸和位置，通常用于创建需要相对布局的复杂界面，Layout 组件仅依赖和影响 RectTransform 组件，而并不依赖于 Graphic 对象，可以单独使用。</p>
<p><em>Graphic</em> 和 <em>Layout</em> 组件都依赖于 <em>CanvasUpdateRegistry</em> 类。该类跟踪需要更新的 <em>Layout</em> 组件和 <em>Graphic</em> 组件，当与它们相关的 Canvas 组件调用 <em>willRenderCanvases</em> 事件时，<em>CanvasUpdateRegistry</em> 类会根据需要触发更新。</p>
<p>Layout 和 Graphic 组件的这种更新过程称为重构（rebuild），后面将会详细介绍这一过程。</p>
<h2 id="渲染细节"><a href="#渲染细节" class="headerlink" title="渲染细节"></a>渲染细节</h2><p>当搭建UI界面的时候，必须牢记一点，画布下的所有几何图形将在透明渲染队列（Transparent Queue)被绘制，这意味着，所有的图形总是从后向前进行 Alpha 混合。从性能的角度来看，有一点比较重要的需要知道，所有的栅格化之后的像素（图元）都会被采样计算，即使它被不透明的物体完全遮挡。在手机上，很高的 overdraw 将会超过 GPU 的填充率。</p>
<blockquote>
<p>什么是overdraw？overdraw也就是过度绘制，是指在每个渲染周期内，屏幕上每个像素最理想只渲染一次，但是由于UI元素的重叠会导致像素会被渲染多次，每次渲染从CPU阶段到GPU阶段会消耗大量资源，如果这种情况比较严重，就会造成卡顿。</p>
<p>什么是填充率（fill rate）？填充率是指 GPU 每秒内能够渲染的像素的个数，单位是MPixel/S、GPixel/S，当每个渲染周期内需要渲染的像素超过GPU处理能力时（可能是场景太复杂、也可能是 overdraw 严重），就会造成丢帧。</p>
</blockquote>
<h2 id="批处理过程"><a href="#批处理过程" class="headerlink" title="批处理过程"></a>批处理过程</h2><p>批处理是通过 Canvas 组件将所有 UI 元素的网格进行合并，然后生成并发送渲染指令给 Unity图形渲染管线。批处理的结果将被缓存起来并重复利用（顶点缓存对象VBO），直到 Canvas 组件被标记为 dirty，这种情况一般发生在 Canvas 下的UI元素的网格发生了变化。  </p>
<p>批处理过程中的网格来自其下的 CanvasRenderer 组件，但是不包括子画布下的物体。</p>
<p>网格合并过程中需要将网格按照深度进行排序、进行交叉测试、共享材质等计算。这个操作是多线程的，所以性能在不同的 CPU 上存在一定差异，这种差异在手机 CPU 和桌面 CPU 上尤其明显。</p>
<h2 id="Rebuild-过程"><a href="#Rebuild-过程" class="headerlink" title="Rebuild 过程"></a>Rebuild 过程</h2><p>在介绍<em>Layout</em>组件时，提过<em>Layout</em>和<em>Graphic</em>重新计算时，这个过程称为重构（Rebuild）。这个过程发生在 CanvasUpdateRegistry 类中，这是一个C#类，源码可以在 <a href="https://bitbucket.org/Unity-Technologies/ui/" target="_blank" rel="noopener">这里</a> 找到。  </p>
<p>在 CanvasUpdateRegistry 类中，比较核心的方法是 PerformUpdate，当 Canvas 组件调用 willRenderCanvases 事件时，PerformUpdate 就会被调用，willRenderCanvases 事件每帧都会调用一次。</p>
<p>PerformUpdate 方法的执行主要包括三个步骤：</p>
<ol>
<li>脏的<em>Layout</em>组件必须进行重构(rebuild)，通过调用 ICanvasElement.Rebuild 接口完成。</li>
<li>裁剪组件（如 Masks 组件）进行裁剪操作，通过调用 ClippingRegistry.Cull 方法完成。</li>
<li>脏的<em>Graphic</em>组件必须进行重构,也是通过 ICanvasElement.Rebuild 接口完成。  </li>
</ol>
<p>对于 Layout 和 Graphic 组件的重构过程，它被处理成多个阶段，Layout rebuild 过程包括 PreLayout、Layout、PostLayout；Graphic 的 rebuild 过程包括 PreRender、LatePreRender  </p>
<h3 id="Layout-组件重构"><a href="#Layout-组件重构" class="headerlink" title="Layout 组件重构"></a>Layout 组件重构</h3><p>为了重新计算包含一个或者多个<em>Layout</em>组件的位置和尺寸，需要对 Layout 组件进行适当的层次排序，父物体的<em>Layout</em>组件可能会影响子物体的<em>Layout</em>组件的尺寸和位置，所以需要先计算父物体的 Layout 组件，要做到这一点，Unity会将<em>Layout</em>组件按照层次深度进行排序，高层级的（越接近根物体）会被排序到最前面进行优先计算。排序完成的<em>Layout</em>组件将会进行重构，这个过程完成了UI元素位置和大小的控制。如果需要了解<em>Layout</em>组件是如何影响各个UI元素的，可以用户手册的<a href="http://docs.unity3d.com/Manual/UIAutoLayout.html?_ga=2.21241147.1489541354.1535984792-1079978078.1535205694" target="_blank" rel="noopener">UI自动布局</a>章节。</p>
<h3 id="Graphic-组件重构"><a href="#Graphic-组件重构" class="headerlink" title="Graphic 组件重构"></a>Graphic 组件重构</h3><p>当<em>Graphic</em>组件重构时，Unity 将处理方法（PreRender）传递给 ICanvasElement.Rebuild 接口，Graphic 实现了ICanvasElement 接口，在重构的 PreRender 阶段执行下面两个步骤：</p>
<ol>
<li>如果顶点数据（vertex data）被标记为脏的（例如组件的 RectTransform 尺寸发生变化），重新生成mesh 对象。</li>
<li>如果材质信息被标记为脏的（例如组件的材质或者贴图发生变化），就会更新 CanvasRenderer 的材质。</li>
</ol>
<p>与Layout rebuild不同的是，Graphic rebuild 不需要按照特定顺序进行，因此不需要进行任何的排序。 </p>
]]></content>
      <categories>
        <category>unity3d</category>
      </categories>
      <tags>
        <tag>ugui</tag>
        <tag>unity最佳实践</tag>
      </tags>
  </entry>
</search>
